{"/home/travis/build/npmtest/node-npmtest-ember-cli/test.js":"/* istanbul instrument in package npmtest_ember_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli/lib.npmtest_ember_cli.js":"/* istanbul instrument in package npmtest_ember_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_cli.__dirname + '/lib.npmtest_ember_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/cli/index.js":"'use strict';\n\nconst instrumentation = require('../utilities/instrumentation');\n\nlet initInstrumentation;\nif (instrumentation.instrumentationEnabled()) {\n  const heimdall = require('heimdalljs');\n  let initInstrumentationToken = heimdall.start('init');\n  initInstrumentation = {\n    token: initInstrumentationToken,\n    node: heimdall.current,\n  };\n}\n\n// work around misbehaving libraries, so we can correctly cleanup before\n// actually exiting.\nrequire('capture-exit').captureExit();\n\n// Main entry point\nconst requireAsHash = require('../utilities/require-as-hash');\nconst packageConfig = require('../../package.json');\nlet logger = require('heimdalljs-logger')('ember-cli:cli/index');\nconst merge = require('ember-cli-lodash-subset').merge;\nconst path = require('path');\nconst heimdall = require('heimdalljs');\n\n// ember-cli and user apps have many dependencies, many of which require\n// process.addListener('exit', ....) for cleanup, by default this limit for\n// such listeners is 10, recently users have been increasing this and not to\n// their fault, rather they are including large and more diverse sets of\n// node_modules.\n//\n// https://github.com/babel/ember-cli-babel/issues/76\nprocess.setMaxListeners(1000);\n\nlet version = packageConfig.version;\nlet name = packageConfig.name;\nlet trackingCode = packageConfig.trackingCode;\n\nfunction loadCommands() {\n  let token = heimdall.start('load-commands');\n  const Command = require('../models/command');\n  let hash = requireAsHash('../commands/*.js', Command);\n  token.stop();\n  return hash;\n}\n\nfunction loadTasks() {\n  let token = heimdall.start('load-tasks');\n  const Task = require('../models/task');\n  let hash = requireAsHash('../tasks/*.js', Task);\n  token.stop();\n  return hash;\n}\n\nfunction clientId() {\n  const ConfigStore = require('configstore');\n  let configStore = new ConfigStore('ember-cli');\n  let id = configStore.get('client-id');\n\n  if (id) {\n    return id;\n  } else {\n    id = require('uuid').v4().toString();\n    configStore.set('client-id', id);\n    return id;\n  }\n}\n\nfunction configureLogger(env) {\n  let depth = Number(env['DEBUG_DEPTH']);\n  if (depth) {\n    let logConfig = require('heimdalljs').configFor('logging');\n    logConfig.depth = depth;\n  }\n}\n\n// Options: Array cliArgs, Stream inputStream, Stream outputStream\nmodule.exports = function(options) {\n  let UI = options.UI || require('console-ui');\n  let Yam = options.Yam || require('yam');\n  const CLI = require('./cli');\n  let Leek = options.Leek || require('leek');\n  const Project = require('../models/project');\n\n  configureLogger(process.env);\n\n  // TODO: one UI (lib/models/project.js also has one for now...)\n  let ui = new UI({\n    inputStream: options.inputStream,\n    outputStream: options.outputStream,\n    errorStream: options.errorStream || process.stderr,\n    errorLog: options.errorLog || [],\n    ci: process.env.CI || (/^(dumb|emacs)$/).test(process.env.TERM),\n    writeLevel: (process.argv.indexOf('--silent') !== -1) ? 'ERROR' : undefined,\n  });\n\n  let config = new Yam('ember-cli', {\n    primary: Project.getProjectRoot(),\n  });\n\n  let leekOptions;\n\n  let disableAnalytics = (options.cliArgs &&\n    (options.cliArgs.indexOf('--disable-analytics') > -1 ||\n    options.cliArgs.indexOf('-v') > -1 ||\n    options.cliArgs.indexOf('--version') > -1)) ||\n    config.get('disableAnalytics');\n\n  let defaultLeekOptions = {\n    trackingCode,\n    globalName: name,\n    name: clientId(),\n    version,\n    silent: disableAnalytics,\n  };\n\n  let defaultUpdateCheckerOptions = {\n    checkForUpdates: false,\n  };\n\n  if (config.get('leekOptions')) {\n    leekOptions = merge(defaultLeekOptions, config.get('leekOptions'));\n  } else {\n    leekOptions = defaultLeekOptions;\n  }\n\n  logger.info('leek: %o', leekOptions);\n\n  let leek = new Leek(leekOptions);\n\n  let cli = new CLI({\n    ui,\n    analytics: leek,\n    testing: options.testing,\n    name: options.cli ? options.cli.name : 'ember',\n    disableDependencyChecker: options.disableDependencyChecker,\n    root: options.cli ? options.cli.root : path.resolve(__dirname, '..', '..'),\n    npmPackage: options.cli ? options.cli.npmPackage : 'ember-cli',\n    initInstrumentation,\n  });\n\n  let project = Project.projectOrnullProject(ui, cli);\n\n  let environment = {\n    tasks: loadTasks(),\n    cliArgs: options.cliArgs,\n    commands: loadCommands(),\n    project,\n    settings: merge(defaultUpdateCheckerOptions, config.getAll()),\n  };\n\n  return cli.run(environment);\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/instrumentation.js":"'use strict';\n\nlet _hasWarnedLegacyViz = false;\n\nfunction vizEnabled() {\n  let isEnabled = process.env.BROCCOLI_VIZ === '1';\n  let isLegacyEnabled = !!process.env.BROCCOLI_VIZ && !isEnabled;\n\n  if (isLegacyEnabled && !_hasWarnedLegacyViz) {\n    // TODO: this.ui\n    console.warn(`Please set BROCCOLI_VIZ=1 to enable visual instrumentation, rather than '${process.env.BROCCOLI_VIZ}'`);\n    _hasWarnedLegacyViz = true;\n  }\n\n  return isEnabled || isLegacyEnabled;\n}\n\nfunction instrumentationEnabled() {\n  return vizEnabled() || process.env.EMBER_CLI_INSTRUMENTATION === '1';\n}\n\n\nmodule.exports = {\n  vizEnabled,\n  instrumentationEnabled,\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/require-as-hash.js":"'use strict';\nconst stringUtils = require('ember-cli-string-utils');\n\n// Gathers subclasses of a certain specified base class into a hash.\n//\n// e.g.:\n// Files:\n// - ./hamster.js which exports a class of Hamster subclass of Rodent\n// - ./parrot.js which exports an instance of Parrot (not a Rodent!)\n//\n// requireAsHash('./*.js', Rodent):\n// {\n//   Hamster: Hamster // Same as require('./hamster.js')\n// }\n\n\nconst globSync = require('glob').sync;\nconst path = require('path');\nconst getCallerFile = require('get-caller-file');\n\nmodule.exports = requireAsHash;\nfunction requireAsHash(pattern, type) {\n  let callerFileDir = path.dirname(getCallerFile());\n  return globSync(pattern, { cwd: callerFileDir }).reduce((hash, file) => {\n\n    const klass = require(`${callerFileDir}/${file}`);\n    if (!type || (klass.prototype instanceof type)) {\n      hash[stringUtils.classify(path.basename(file, '.js'))] = klass;\n    }\n    return hash;\n  }, {});\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-string-utils/index.js":"'use strict';\n\nvar STRING_DASHERIZE_REGEXP = (/[ _]/g);\nvar STRING_DASHERIZE_CACHE = {};\nvar STRING_DECAMELIZE_REGEXP = (/([a-z\\d])([A-Z])/g);\nvar STRING_CAMELIZE_REGEXP = (/(\\-|_|\\.|\\s)+(.)?/g);\nvar STRING_UNDERSCORE_REGEXP_1 = (/([a-z\\d])([A-Z]+)/g);\nvar STRING_UNDERSCORE_REGEXP_2 = (/\\-|\\s+/g);\n\n/**\n  Converts a camelized string into all lower case separated by underscores.\n\n  ```javascript\n  decamelize('innerHTML');         // 'inner_html'\n  decamelize('action_name');       // 'action_name'\n  decamelize('css-class-name');    // 'css-class-name'\n  decamelize('my favorite items'); // 'my favorite items'\n  ```\n\n  @method decamelize\n  @param {String} str The string to decamelize.\n  @return {String} the decamelized string.\n*/\nfunction decamelize(str) {\n  return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();\n}\n\n/**\n  Replaces underscores, spaces, or camelCase with dashes.\n\n  ```javascript\n  dasherize('innerHTML');         // 'inner-html'\n  dasherize('action_name');       // 'action-name'\n  dasherize('css-class-name');    // 'css-class-name'\n  dasherize('my favorite items'); // 'my-favorite-items'\n  ```\n\n  @method dasherize\n  @param {String} str The string to dasherize.\n  @return {String} the dasherized string.\n*/\nfunction dasherize(str) {\n  var cache = STRING_DASHERIZE_CACHE,\n      hit   = cache.hasOwnProperty(str),\n      ret;\n\n  if (hit) {\n    return cache[str];\n  } else {\n    ret = decamelize(str).replace(STRING_DASHERIZE_REGEXP,'-');\n    cache[str] = ret;\n  }\n\n  return ret;\n}\n\n/**\n  Returns the lowerCamelCase form of a string.\n\n  ```javascript\n  camelize('innerHTML');          // 'innerHTML'\n  camelize('action_name');        // 'actionName'\n  camelize('css-class-name');     // 'cssClassName'\n  camelize('my favorite items');  // 'myFavoriteItems'\n  camelize('My Favorite Items');  // 'myFavoriteItems'\n  ```\n\n  @method camelize\n  @param {String} str The string to camelize.\n  @return {String} the camelized string.\n*/\nfunction camelize(str) {\n  return str.replace(STRING_CAMELIZE_REGEXP, function(match, separator, chr) {\n    return chr ? chr.toUpperCase() : '';\n  }).replace(/^([A-Z])/, function(match) {\n    return match.toLowerCase();\n  });\n}\n\n/**\n  Returns the UpperCamelCase form of a string.\n\n  ```javascript\n  'innerHTML'.classify();          // 'InnerHTML'\n  'action_name'.classify();        // 'ActionName'\n  'css-class-name'.classify();     // 'CssClassName'\n  'my favorite items'.classify();  // 'MyFavoriteItems'\n  ```\n\n  @method classify\n  @param {String} str the string to classify\n  @return {String} the classified string\n*/\nfunction classify(str) {\n  var parts = str.split('.'),\n      out = [];\n\n  for (var i=0, l=parts.length; i<l; i++) {\n    var camelized = camelize(parts[i]);\n    out.push(camelized.charAt(0).toUpperCase() + camelized.substr(1));\n  }\n\n  return out.join('.');\n}\n\n/**\n  More general than decamelize. Returns the lower\\_case\\_and\\_underscored\n  form of a string.\n\n  ```javascript\n  'innerHTML'.underscore();          // 'inner_html'\n  'action_name'.underscore();        // 'action_name'\n  'css-class-name'.underscore();     // 'css_class_name'\n  'my favorite items'.underscore();  // 'my_favorite_items'\n  ```\n\n  @method underscore\n  @param {String} str The string to underscore.\n  @return {String} the underscored string.\n*/\nfunction underscore(str) {\n  return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').\n    replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();\n}\n\n/**\n  Returns the Capitalized form of a string\n\n  ```javascript\n  'innerHTML'.capitalize()         // 'InnerHTML'\n  'action_name'.capitalize()       // 'Action_name'\n  'css-class-name'.capitalize()    // 'Css-class-name'\n  'my favorite items'.capitalize() // 'My favorite items'\n  ```\n\n  @method capitalize\n  @param {String} str The string to capitalize.\n  @return {String} The capitalized string.\n*/\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n}\n\nmodule.exports = {\n  decamelize: decamelize,\n  dasherize: dasherize,\n  camelize: camelize,\n  classify: classify,\n  underscore: underscore,\n  capitalize: capitalize\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-lodash-subset/index.js":"!function(){\"use strict\";function t(t){var r=Mn.call(t,$n),n=t[$n];try{t[$n]=void 0;var e=!0}catch(t){}var o=Un.call(t);return e&&(r?t[$n]=n:delete t[$n]),o}function r(t){return Bn.call(t)}function n(n){return null==n?void 0===n?In:Dn:(n=Object(n),Nn&&Nn in n?t(n):r(n))}function e(t){var r=typeof t;return null!=t&&(\"object\"==r||\"function\"==r)}function o(t){if(!e(t))return!1;var r=n(t);return r==Ln||r==Rn||r==Cn||r==Vn}function u(t){return!!qn&&qn in t}function i(t){if(null!=t){try{return Hn.call(t)}catch(t){}try{return t+\"\"}catch(t){}}return\"\"}function c(t){if(!e(t)||u(t))return!1;var r=o(t)?te:Kn;return r.test(i(t))}function a(t,r){return null==t?void 0:t[r]}function f(t,r){var n=a(t,r);return c(n)?n:void 0}function l(t,r,n){\"__proto__\"==r&&re?re(t,r,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[r]=n}function s(t,r){return t===r||t!==t&&r!==r}function v(t,r,n){var e=t[r];ee.call(t,r)&&s(e,n)&&(void 0!==n||r in t)||l(t,r,n)}function p(t,r,n,e){var o=!n;n||(n={});for(var u=-1,i=r.length;++u<i;){var c=r[u],a=e?e(n[c],t[c],c,n,t):void 0;void 0===a&&(a=t[c]),o?l(n,c,a):v(n,c,a)}return n}function h(t){return t}function b(t,r,n){switch(n.length){case 0:return t.call(r);case 1:return t.call(r,n[0]);case 2:return t.call(r,n[0],n[1]);case 3:return t.call(r,n[0],n[1],n[2])}return t.apply(r,n)}function y(t,r,n){return r=oe(void 0===r?t.length-1:r,0),function(){for(var e=arguments,o=-1,u=oe(e.length-r,0),i=Array(u);++o<u;)i[o]=e[r+o];o=-1;for(var c=Array(r+1);++o<r;)c[o]=e[o];return c[r]=n(i),b(t,this,c)}}function d(t){return function(){return t}}function j(t){var r=0,n=0;return function(){var e=ae(),o=ce-(e-n);if(n=e,o>0){if(++r>=ie)return arguments[0]}else r=0;return t.apply(void 0,arguments)}}function g(t,r){return fe(y(t,r,h),t+\"\")}function _(t){return\"number\"==typeof t&&t>-1&&t%1==0&&t<=le}function w(t){return null!=t&&_(t.length)&&!o(t)}function O(t,r){return r=null==r?se:r,!!r&&(\"number\"==typeof t||ve.test(t))&&t>-1&&t%1==0&&t<r}function m(t,r,n){if(!e(n))return!1;var o=typeof r;return!!(\"number\"==o?w(n)&&O(r,n.length):\"string\"==o&&r in n)&&s(n[r],t)}function A(t){return g(function(r,n){var e=-1,o=n.length,u=o>1?n[o-1]:void 0,i=o>2?n[2]:void 0;for(u=t.length>3&&\"function\"==typeof u?(o--,u):void 0,i&&m(n[0],n[1],i)&&(u=o<3?void 0:u,o=1),r=Object(r);++e<o;){var c=n[e];c&&t(r,c,e,u)}return r})}function x(t){var r=t&&t.constructor,n=\"function\"==typeof r&&r.prototype||pe;return t===n}function S(t,r){for(var n=-1,e=Array(t);++n<t;)e[n]=r(n);return e}function z(t){return null!=t&&\"object\"==typeof t}function P(t){return z(t)&&n(t)==he}function E(){return!1}function T(t){return z(t)&&_(t.length)&&!!Qe[n(t)]}function F(t){return function(r){return t(r)}}function M(t,r){var n=ge(t),e=!n&&je(t),o=!n&&!e&&xe(t),u=!n&&!e&&!o&&eo(t),i=n||e||o||u,c=i?S(t.length,String):[],a=c.length;for(var f in t)!r&&!uo.call(t,f)||i&&(\"length\"==f||o&&(\"offset\"==f||\"parent\"==f)||u&&(\"buffer\"==f||\"byteLength\"==f||\"byteOffset\"==f)||O(f,a))||c.push(f);return c}function U(t,r){return function(n){return t(r(n))}}function $(t){if(!x(t))return io(t);var r=[];for(var n in Object(t))ao.call(t,n)&&\"constructor\"!=n&&r.push(n);return r}function k(t){return w(t)?M(t):$(t)}function B(){this.__data__=[],this.size=0}function D(t,r){for(var n=t.length;n--;)if(s(t[n][0],r))return n;return-1}function I(t){var r=this.__data__,n=D(r,t);if(n<0)return!1;var e=r.length-1;return n==e?r.pop():po.call(r,n,1),--this.size,!0}function N(t){var r=this.__data__,n=D(r,t);return n<0?void 0:r[n][1]}function C(t){return D(this.__data__,t)>-1}function L(t,r){var n=this.__data__,e=D(n,t);return e<0?(++this.size,n.push([t,r])):n[e][1]=r,this}function R(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1])}}function V(){this.__data__=new R,this.size=0}function W(t){var r=this.__data__,n=r.delete(t);return this.size=r.size,n}function q(t){return this.__data__.get(t)}function G(t){return this.__data__.has(t)}function H(){this.__data__=bo?bo(null):{},this.size=0}function J(t){var r=this.has(t)&&delete this.__data__[t];return this.size-=r?1:0,r}function K(t){var r=this.__data__;if(bo){var n=r[t];return n===yo?void 0:n}return go.call(r,t)?r[t]:void 0}function Q(t){var r=this.__data__;return bo?void 0!==r[t]:wo.call(r,t)}function X(t,r){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=bo&&void 0===r?Oo:r,this}function Y(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1])}}function Z(){this.size=0,this.__data__={hash:new Y,map:new(ho||R),string:new Y}}function tt(t){var r=typeof t;return\"string\"==r||\"number\"==r||\"symbol\"==r||\"boolean\"==r?\"__proto__\"!==t:null===t}function rt(t,r){var n=t.__data__;return tt(r)?n[\"string\"==typeof r?\"string\":\"hash\"]:n.map}function nt(t){var r=rt(this,t).delete(t);return this.size-=r?1:0,r}function et(t){return rt(this,t).get(t)}function ot(t){return rt(this,t).has(t)}function ut(t,r){var n=rt(this,t),e=n.size;return n.set(t,r),this.size+=n.size==e?0:1,this}function it(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1])}}function ct(t,r){var n=this.__data__;if(n instanceof R){var e=n.__data__;if(!ho||e.length<mo-1)return e.push([t,r]),this.size=++n.size,this;n=this.__data__=new it(e)}return n.set(t,r),this.size=n.size,this}function at(t){var r=this.__data__=new R(t);this.size=r.size}function ft(t,r){for(var n=-1,e=null==t?0:t.length;++n<e&&r(t[n],n,t)!==!1;);return t}function lt(t,r){return t&&p(r,k(r),t)}function st(t,r){if(r)return t.slice();var n=t.length,e=Po?Po(n):new t.constructor(n);return t.copy(e),e}function vt(t,r){var n=-1,e=t.length;for(r||(r=Array(e));++n<e;)r[n]=t[n];return r}function pt(){return[]}function ht(t,r){return p(t,To(t),r)}function bt(t,r){for(var n=-1,e=r.length,o=t.length;++n<e;)t[o+n]=r[n];return t}function yt(t,r,n){var e=r(t);return ge(t)?e:bt(e,n(t))}function dt(t){return yt(t,k,To)}function jt(t){var r=t.length,n=t.constructor(r);return r&&\"string\"==typeof t[0]&&Ko.call(t,\"index\")&&(n.index=t.index,n.input=t.input),n}function gt(t){var r=new t.constructor(t.byteLength);return new Qo(r).set(new Qo(t)),r}function _t(t,r){var n=r?gt(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)}function wt(t,r){return t.set(r[0],r[1]),t}function Ot(t,r,n,e){var o=-1,u=null==t?0:t.length;for(e&&u&&(n=t[++o]);++o<u;)n=r(n,t[o],o,t);return n}function mt(t){var r=-1,n=Array(t.size);return t.forEach(function(t,e){n[++r]=[e,t]}),n}function At(t,r,n){var e=r?n(mt(t),!0):mt(t);return Ot(e,wt,new t.constructor)}function xt(t){var r=new t.constructor(t.source,Xo.exec(t));return r.lastIndex=t.lastIndex,r}function St(t,r){return t.add(r),t}function zt(t){var r=-1,n=Array(t.size);return t.forEach(function(t){n[++r]=t}),n}function Pt(t,r,n){var e=r?n(zt(t),!0):zt(t);return Ot(e,St,new t.constructor)}function Et(t){return Zo?Object(Zo.call(t)):{}}function Tt(t,r){var n=r?gt(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}function Ft(t,r,n,e){var o=t.constructor;switch(r){case au:return gt(t);case tu:case ru:return new o(+t);case fu:return _t(t,e);case lu:case su:case vu:case pu:case hu:case bu:case yu:case du:case ju:return Tt(t,e);case nu:return At(t,e,n);case eu:case iu:return new o(t);case ou:return xt(t);case uu:return Pt(t,e,n);case cu:return Et(t)}}function Mt(t){return\"function\"!=typeof t.constructor||x(t)?{}:_u(wu(t))}function Ut(t,r,n,o,u,i,c){var a;if(o&&(a=i?o(t,u,i,c):o(t)),void 0!==a)return a;if(!e(t))return t;var f=ge(t);if(f){if(a=jt(t),!r)return vt(t,a)}else{var l=Ho(t),s=l==zu||l==Pu;if(xe(t))return st(t,r);if(l==Fu||l==Ou||s&&!i){if(a=Mt(s?{}:t),!r)return ht(t,lt(a,t))}else{if(!Ju[l])return i?t:{};a=Ft(t,l,Ut,r)}}c||(c=new at);var p=c.get(t);if(p)return p;c.set(t,a);var h=f?void 0:(n?dt:k)(t);return ft(h||t,function(e,u){h&&(u=e,e=t[u]),v(a,u,Ut(e,r,n,o,u,t,c))}),a}function $t(t){return Ut(t,!1,!0)}function kt(t){return Ut(t,!0,!0)}function Bt(t){for(var r=-1,n=null==t?0:t.length,e=0,o=[];++r<n;){var u=t[r];u&&(o[e++]=u)}return o}function Dt(t){return\"symbol\"==typeof t||z(t)&&n(t)==Qu}function It(t){if(\"number\"==typeof t)return t;if(Dt(t))return Xu;if(e(t)){var r=\"function\"==typeof t.valueOf?t.valueOf():t;t=e(r)?r+\"\":r}if(\"string\"!=typeof t)return 0===t?t:+t;t=t.replace(Yu,\"\");var n=ti.test(t);return n||ri.test(t)?ni(t.slice(2),n?2:8):Zu.test(t)?Xu:+t}function Nt(t,r,n){function o(r){var n=p,e=h;return p=h=void 0,g=r,y=t.apply(e,n)}function u(t){return g=t,d=setTimeout(a,r),_?o(t):y}function i(t){var n=t-j,e=t-g,o=r-n;return w?ui(o,b-e):o}function c(t){var n=t-j,e=t-g;return void 0===j||n>=r||n<0||w&&e>=b}function a(){var t=Ku();return c(t)?f(t):void(d=setTimeout(a,i(t)))}function f(t){return d=void 0,O&&p?o(t):(p=h=void 0,y)}function l(){void 0!==d&&clearTimeout(d),g=0,p=j=h=d=void 0}function s(){return void 0===d?y:f(Ku())}function v(){var t=Ku(),n=c(t);if(p=arguments,h=this,j=t,n){if(void 0===d)return u(j);if(w)return d=setTimeout(a,r),o(j)}return void 0===d&&(d=setTimeout(a,r)),y}var p,h,b,y,d,j,g=0,_=!1,w=!1,O=!0;if(\"function\"!=typeof t)throw new TypeError(ei);return r=It(r)||0,e(n)&&(_=!!n.leading,w=\"maxWait\"in n,b=w?oi(It(n.maxWait)||0,r):b,O=\"trailing\"in n?!!n.trailing:O),v.cancel=l,v.flush=s,v}function Ct(t,r,n,e){return void 0===t||s(t,ii[n])&&!ci.call(e,n)?r:t}function Lt(t){var r=[];if(null!=t)for(var n in Object(t))r.push(n);return r}function Rt(t){if(!e(t))return Lt(t);var r=x(t),n=[];for(var o in t)(\"constructor\"!=o||!r&&fi.call(t,o))&&n.push(o);return n}function Vt(t){return w(t)?M(t,!0):Rt(t)}function Wt(t,r,n){(void 0===n||s(t[r],n))&&(void 0!==n||r in t)||l(t,r,n)}function qt(t){return function(r,n,e){for(var o=-1,u=Object(r),i=e(r),c=i.length;c--;){var a=i[t?c:++o];if(n(u[a],a,u)===!1)break}return r}}function Gt(t){return z(t)&&w(t)}function Ht(t){if(!z(t)||n(t)!=pi)return!1;var r=wu(t);if(null===r)return!0;var e=di.call(r,\"constructor\")&&r.constructor;return\"function\"==typeof e&&e instanceof e&&yi.call(e)==ji}function Jt(t){return p(t,Vt(t))}function Kt(t,r,n,u,i,c,a){var f=t[n],l=r[n],s=a.get(l);if(s)return void Wt(t,n,s);var v=c?c(f,l,n+\"\",t,r,a):void 0,p=void 0===v;if(p){var h=ge(l),b=!h&&xe(l),y=!h&&!b&&eo(l);v=l,h||b||y?ge(f)?v=f:Gt(f)?v=vt(f):b?(p=!1,v=st(l,!0)):y?(p=!1,v=Tt(l,!0)):v=[]:Ht(l)||je(l)?(v=f,je(f)?v=Jt(f):(!e(f)||u&&o(f))&&(v=Mt(l))):p=!1}p&&(a.set(l,v),i(v,l,u,c,a),a.delete(l)),Wt(t,n,v)}function Qt(t,r,n,o,u){t!==r&&vi(r,function(i,c){if(e(i))u||(u=new at),Kt(t,r,c,n,Qt,o,u);else{var a=o?o(t[c],i,c+\"\",t,r,u):void 0;void 0===a&&(a=i),Wt(t,c,a)}},Vt)}function Xt(t,r,n,o,u,i){return e(t)&&e(r)&&(i.set(r,t),Qt(t,r,void 0,Xt,i),i.delete(r)),t}function Yt(t,r){for(var n=-1,e=null==t?0:t.length,o=0,u=[];++n<e;){var i=t[n];r(i,n,t)&&(u[o++]=i)}return u}function Zt(t,r){return t&&vi(t,r,k)}function tr(t,r){return function(n,e){if(null==n)return n;if(!w(n))return t(n,e);for(var o=n.length,u=r?o:-1,i=Object(n);(r?u--:++u<o)&&e(i[u],u,i)!==!1;);return n}}function rr(t,r){var n=[];return wi(t,function(t,e,o){r(t,e,o)&&n.push(t)}),n}function nr(t){return this.__data__.set(t,Oi),this}function er(t){return this.__data__.has(t)}function or(t){var r=-1,n=null==t?0:t.length;for(this.__data__=new it;++r<n;)this.add(t[r])}function ur(t,r){for(var n=-1,e=null==t?0:t.length;++n<e;)if(r(t[n],n,t))return!0;return!1}function ir(t,r){return t.has(r)}function cr(t,r,n,e,o,u){var i=o&Ai,c=t.length,a=r.length;if(c!=a&&!(i&&a>c))return!1;var f=u.get(t);if(f&&u.get(r))return f==r;var l=-1,s=!0,v=o&mi?new or:void 0;for(u.set(t,r),u.set(r,t);++l<c;){var p=t[l],h=r[l];if(e)var b=i?e(h,p,l,r,t,u):e(p,h,l,t,r,u);if(void 0!==b){if(b)continue;s=!1;break}if(v){if(!ur(r,function(t,r){if(!ir(v,r)&&(p===t||n(p,t,e,o,u)))return v.push(r)})){s=!1;break}}else if(p!==h&&!n(p,h,e,o,u)){s=!1;break}}return u.delete(t),u.delete(r),s}function ar(t,r,n,e,o,u,i){switch(n){case Di:if(t.byteLength!=r.byteLength||t.byteOffset!=r.byteOffset)return!1;t=t.buffer,r=r.buffer;case Bi:return!(t.byteLength!=r.byteLength||!e(new Qo(t),new Qo(r)));case zi:case Pi:case Fi:return s(+t,+r);case Ei:return t.name==r.name&&t.message==r.message;case Mi:case $i:return t==r+\"\";case Ti:var c=mt;case Ui:var a=u&Si;if(c||(c=zt),t.size!=r.size&&!a)return!1;var f=i.get(t);if(f)return f==r;u|=xi,i.set(t,r);var l=cr(c(t),c(r),e,o,u,i);return i.delete(t),l;case ki:if(Ni)return Ni.call(t)==Ni.call(r)}return!1}function fr(t,r,n,e,o,u){var i=o&Ci,c=k(t),a=c.length,f=k(r),l=f.length;if(a!=l&&!i)return!1;for(var s=a;s--;){var v=c[s];if(!(i?v in r:Ri.call(r,v)))return!1}var p=u.get(t);if(p&&u.get(r))return p==r;var h=!0;u.set(t,r),u.set(r,t);for(var b=i;++s<a;){v=c[s];var y=t[v],d=r[v];if(e)var j=i?e(d,y,v,r,t,u):e(y,d,v,t,r,u);if(!(void 0===j?y===d||n(y,d,e,o,u):j)){h=!1;break}b||(b=\"constructor\"==v)}if(h&&!b){var g=t.constructor,_=r.constructor;g!=_&&\"constructor\"in t&&\"constructor\"in r&&!(\"function\"==typeof g&&g instanceof g&&\"function\"==typeof _&&_ instanceof _)&&(h=!1)}return u.delete(t),u.delete(r),h}function lr(t,r,n,e,o,u){var i=ge(t),c=ge(r),a=qi,f=qi;i||(a=Ho(t),a=a==Wi?Gi:a),c||(f=Ho(r),f=f==Wi?Gi:f);var l=a==Gi,s=f==Gi,v=a==f;if(v&&xe(t)){if(!xe(r))return!1;i=!0,l=!1}if(v&&!l)return u||(u=new at),i||eo(t)?cr(t,r,n,e,o,u):ar(t,r,a,n,e,o,u);if(!(o&Vi)){var p=l&&Ji.call(t,\"__wrapped__\"),h=s&&Ji.call(r,\"__wrapped__\");if(p||h){var b=p?t.value():t,y=h?r.value():r;return u||(u=new at),n(b,y,e,o,u)}}return!!v&&(u||(u=new at),fr(t,r,n,e,o,u))}function sr(t,r,n,o,u){return t===r||(null==t||null==r||!e(t)&&!z(r)?t!==t&&r!==r:lr(t,r,sr,n,o,u))}function vr(t,r,n,e){var o=n.length,u=o,i=!e;if(null==t)return!u;for(t=Object(t);o--;){var c=n[o];if(i&&c[2]?c[1]!==t[c[0]]:!(c[0]in t))return!1}for(;++o<u;){c=n[o];var a=c[0],f=t[a],l=c[1];if(i&&c[2]){if(void 0===f&&!(a in t))return!1}else{var s=new at;if(e)var v=e(f,l,a,t,r,s);if(!(void 0===v?sr(l,f,e,Ki|Qi,s):v))return!1}}return!0}function pr(t){return t===t&&!e(t)}function hr(t){for(var r=k(t),n=r.length;n--;){var e=r[n],o=t[e];r[n]=[e,o,pr(o)]}return r}function br(t,r){return function(n){return null!=n&&(n[t]===r&&(void 0!==r||t in Object(n)))}}function yr(t){var r=hr(t);return 1==r.length&&r[0][2]?br(r[0][0],r[0][1]):function(n){return n===t||vr(n,t,r)}}function dr(t,r){if(\"function\"!=typeof t||null!=r&&\"function\"!=typeof r)throw new TypeError(Xi);var n=function(){var e=arguments,o=r?r.apply(this,e):e[0],u=n.cache;if(u.has(o))return u.get(o);var i=t.apply(this,e);return n.cache=u.set(o,i)||u,i};return n.cache=new(dr.Cache||it),n}function jr(t){var r=dr(t,function(t){return n.size===Yi&&n.clear(),t}),n=r.cache;return r}function gr(t,r){for(var n=-1,e=null==t?0:t.length,o=Array(e);++n<e;)o[n]=r(t[n],n,t);return o}function _r(t){if(\"string\"==typeof t)return t;if(ge(t))return gr(t,_r)+\"\";if(Dt(t))return rc?rc.call(t):\"\";var r=t+\"\";return\"0\"==r&&1/t==-Zi?\"-0\":r}function wr(t){return null==t?\"\":_r(t)}function Or(t){return ge(t)?t:uc(t)}function mr(t,r){if(ge(t))return!1;var n=typeof t;return!(\"number\"!=n&&\"symbol\"!=n&&\"boolean\"!=n&&null!=t&&!Dt(t))||(cc.test(t)||!ic.test(t)||null!=r&&t in Object(r))}function Ar(t){if(\"string\"==typeof t||Dt(t))return t;var r=t+\"\";return\"0\"==r&&1/t==-ac?\"-0\":r}function xr(t,r){r=mr(r,t)?[r]:Or(r);for(var n=0,e=r.length;null!=t&&n<e;)t=t[Ar(r[n++])];return n&&n==e?t:void 0}function Sr(t,r,n){var e=null==t?void 0:xr(t,r);return void 0===e?n:e}function zr(t,r){return null!=t&&r in Object(t)}function Pr(t,r,n){r=mr(r,t)?[r]:Or(r);for(var e=-1,o=r.length,u=!1;++e<o;){var i=Ar(r[e]);if(!(u=null!=t&&n(t,i)))break;t=t[i]}return u||++e!=o?u:(o=null==t?0:t.length,!!o&&_(o)&&O(i,o)&&(ge(t)||je(t)))}function Er(t,r){return null!=t&&Pr(t,r,zr)}function Tr(t,r){return mr(t)&&pr(r)?br(Ar(t),r):function(n){var e=Sr(n,t);return void 0===e&&e===r?Er(n,t):sr(r,e,void 0,fc|lc)}}function Fr(t){return function(r){return null==r?void 0:r[t]}}function Mr(t){return function(r){return xr(r,t)}}function Ur(t){return mr(t)?Fr(Ar(t)):Mr(t)}function $r(t){return\"function\"==typeof t?t:null==t?h:\"object\"==typeof t?ge(t)?Tr(t[0],t[1]):yr(t):Ur(t)}function kr(t,r){var n=ge(t)?Yt:rr;return n(t,$r(r,3))}function Br(t){return function(r,n,e){var o=Object(r);if(!w(r)){var u=$r(n,3);r=k(r),n=function(t){return u(o[t],t,o)}}var i=t(r,n,e);return i>-1?o[u?r[i]:i]:void 0}}function Dr(t,r,n,e){for(var o=t.length,u=n+(e?1:-1);e?u--:++u<o;)if(r(t[u],u,t))return u;return-1}function Ir(t){if(!t)return 0===t?t:0;if(t=It(t),t===sc||t===-sc){var r=t<0?-1:1;return r*vc}return t===t?t:0}function Nr(t){var r=Ir(t),n=r%1;return r===r?n?r-n:r:0}function Cr(t,r,n){var e=null==t?0:t.length;if(!e)return-1;var o=null==n?0:Nr(n);return o<0&&(o=pc(e+o,0)),Dr(t,$r(r,3),o)}function Lr(t){return\"function\"==typeof t?t:h}function Rr(t,r){var n=ge(t)?ft:wi;return n(t,Lr(r))}function Vr(t,r){return t&&Zt(t,Lr(r))}function Wr(t){return t!==t}function qr(t,r,n){for(var e=n-1,o=t.length;++e<o;)if(t[e]===r)return e;return-1}function Gr(t,r,n){return r===r?qr(t,r,n):Dr(t,Wr,n)}function Hr(t){return\"string\"==typeof t||!ge(t)&&z(t)&&n(t)==bc}function Jr(t,r){return gr(r,function(r){return t[r]})}function Kr(t){return null==t?[]:Jr(t,k(t))}function Qr(t,r,n,e){t=w(t)?t:Kr(t),n=n&&!e?Nr(n):0;var o=t.length;return n<0&&(n=yc(o+n,0)),Hr(t)?n<=o&&t.indexOf(r,n)>-1:!!o&&Gr(t,r,n)>-1}function Xr(t,r){var n=null==t?0:t.length;return!!n&&Gr(t,r,0)>-1}function Yr(t,r,n){for(var e=-1,o=null==t?0:t.length;++e<o;)if(n(r,t[e]))return!0;return!1}function Zr(t,r,n){for(var e=n?Yr:Xr,o=t[0].length,u=t.length,i=u,c=Array(u),a=1/0,f=[];i--;){var l=t[i];i&&r&&(l=gr(l,F(r))),a=dc(l.length,a),c[i]=!n&&(r||o>=120&&l.length>=120)?new or(i&&l):void 0}l=t[0];var s=-1,v=c[0];t:for(;++s<o&&f.length<a;){var p=l[s],h=r?r(p):p;if(p=n||0!==p?p:0,!(v?ir(v,h):e(f,h,n))){for(i=u;--i;){var b=c[i];if(!(b?ir(b,h):e(t[i],h,n)))continue t}v&&v.push(h),f.push(p)}}return f}function tn(t){return Gt(t)?t:[]}function rn(t,r){return sr(t,r)}function nn(t){return null===t}function en(t,r){var n=-1,e=w(t)?Array(t.length):[];return wi(t,function(t,o,u){e[++n]=r(t,o,u)}),e}function on(t,r){var n=ge(t)?gr:en;return n(t,$r(r,3))}function un(t){if(\"function\"!=typeof t)throw new TypeError(_c);return function(){var r=arguments;switch(r.length){case 0:return!t.call(this);case 1:return!t.call(this,r[0]);case 2:return!t.call(this,r[0],r[1]);case 3:return!t.call(this,r[0],r[1],r[2])}return!t.apply(this,r)}}function cn(t,r,n){for(var e=-1,o=r.length,u={};++e<o;){var i=r[e],c=t[i];n(c,i)&&l(u,i,c)}return u}function an(t){return yt(t,Vt,Oc)}function fn(t,r){return null==t?{}:cn(t,an(t),$r(r))}function ln(t,r){return fn(t,un($r(r)))}function sn(t,r){var n=ge(t)?Yt:rr;return n(t,un($r(r,3)))}function vn(t){var r=null==t?0:t.length;return r?t[r-1]:void 0}function pn(t,r,n){var e=-1,o=t.length;r<0&&(r=-r>o?0:o+r),n=n>o?o:n,n<0&&(n+=o),o=r>n?0:n-r>>>0,r>>>=0;for(var u=Array(o);++e<o;)u[e]=t[e+r];return u}function hn(t,r){return 1==r.length?t:xr(t,pn(r,0,-1))}function bn(t,r){for(var n=t?r.length:0,e=n-1;n--;){var o=r[n];if(n==e||o!==u){var u=o;if(O(o))Ac.call(t,o,1);else if(mr(o,t))delete t[Ar(o)];else{var i=Or(o),c=hn(t,i);null!=c&&delete c[Ar(vn(i))]}}}return t}function yn(t,r){var n=[];if(!t||!t.length)return n;var e=-1,o=[],u=t.length;for(r=$r(r,3);++e<u;){var i=t[e];r(i,e,t)&&(n.push(i),o.push(e))}return bn(t,o),n}function dn(t,r){var n;return wi(t,function(t,e,o){return n=r(t,e,o),!n}),!!n}function jn(t,r,n){var e=ge(t)?ur:dn;return n&&m(t,r,n)&&(r=void 0),e(t,$r(r,3))}function gn(t){return ge(t)||je(t)||!!(xc&&t&&t[xc])}function _n(t,r,n,e,o){var u=-1,i=t.length;for(n||(n=gn),o||(o=[]);++u<i;){var c=t[u];r>0&&n(c)?r>1?_n(c,r-1,n,e,o):bt(o,c):e||(o[o.length]=c)}return o}function wn(){}function On(t,r,n){var e=-1,o=Xr,u=t.length,i=!0,c=[],a=c;if(n)i=!1,o=Yr;else if(u>=Pc){var f=r?null:zc(t);if(f)return zt(f);i=!1,o=ir,a=new or}else a=r?[]:c;t:for(;++e<u;){var l=t[e],s=r?r(l):l;if(l=n||0!==l?l:0,i&&s===s){for(var v=a.length;v--;)if(a[v]===s)continue t;r&&a.push(s),c.push(l)}else o(a,s,n)||(a!==c&&a.push(s),c.push(l))}return c}function mn(t){return t&&t.length?On(t):[]}function An(t,r){return t&&t.length?On(t,$r(r,2)):[]}function xn(t,r,n){for(var e=-1,o=t.length,u=r.length,i={};++e<o;){var c=e<u?r[e]:void 0;n(i,t[e],c)}return i}function Sn(t,r){return xn(t||[],r||[],v)}var zn=\"object\"==typeof global&&global&&global.Object===Object&&global,Pn=\"object\"==typeof self&&self&&self.Object===Object&&self,En=zn||Pn||Function(\"return this\")(),Tn=En.Symbol,Fn=Object.prototype,Mn=Fn.hasOwnProperty,Un=Fn.toString,$n=Tn?Tn.toStringTag:void 0,kn=Object.prototype,Bn=kn.toString,Dn=\"[object Null]\",In=\"[object Undefined]\",Nn=Tn?Tn.toStringTag:void 0,Cn=\"[object AsyncFunction]\",Ln=\"[object Function]\",Rn=\"[object GeneratorFunction]\",Vn=\"[object Proxy]\",Wn=En[\"__core-js_shared__\"],qn=function(){var t=/[^.]+$/.exec(Wn&&Wn.keys&&Wn.keys.IE_PROTO||\"\");return t?\"Symbol(src)_1.\"+t:\"\"}(),Gn=Function.prototype,Hn=Gn.toString,Jn=/[\\\\^$.*+?()[\\]{}|]/g,Kn=/^\\[object .+?Constructor\\]$/,Qn=Function.prototype,Xn=Object.prototype,Yn=Qn.toString,Zn=Xn.hasOwnProperty,te=RegExp(\"^\"+Yn.call(Zn).replace(Jn,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),re=function(){try{var t=f(Object,\"defineProperty\");return t({},\"\",{}),t}catch(t){}}(),ne=Object.prototype,ee=ne.hasOwnProperty,oe=Math.max,ue=re?function(t,r){return re(t,\"toString\",{configurable:!0,enumerable:!1,value:d(r),writable:!0})}:h,ie=800,ce=16,ae=Date.now,fe=j(ue),le=9007199254740991,se=9007199254740991,ve=/^(?:0|[1-9]\\d*)$/,pe=Object.prototype,he=\"[object Arguments]\",be=Object.prototype,ye=be.hasOwnProperty,de=be.propertyIsEnumerable,je=P(function(){return arguments}())?P:function(t){return z(t)&&ye.call(t,\"callee\")&&!de.call(t,\"callee\")},ge=Array.isArray,_e=\"object\"==typeof exports&&exports&&!exports.nodeType&&exports,we=_e&&\"object\"==typeof module&&module&&!module.nodeType&&module,Oe=we&&we.exports===_e,me=Oe?En.Buffer:void 0,Ae=me?me.isBuffer:void 0,xe=Ae||E,Se=\"[object Arguments]\",ze=\"[object Array]\",Pe=\"[object Boolean]\",Ee=\"[object Date]\",Te=\"[object Error]\",Fe=\"[object Function]\",Me=\"[object Map]\",Ue=\"[object Number]\",$e=\"[object Object]\",ke=\"[object RegExp]\",Be=\"[object Set]\",De=\"[object String]\",Ie=\"[object WeakMap]\",Ne=\"[object ArrayBuffer]\",Ce=\"[object DataView]\",Le=\"[object Float32Array]\",Re=\"[object Float64Array]\",Ve=\"[object Int8Array]\",We=\"[object Int16Array]\",qe=\"[object Int32Array]\",Ge=\"[object Uint8Array]\",He=\"[object Uint8ClampedArray]\",Je=\"[object Uint16Array]\",Ke=\"[object Uint32Array]\",Qe={};Qe[Le]=Qe[Re]=Qe[Ve]=Qe[We]=Qe[qe]=Qe[Ge]=Qe[He]=Qe[Je]=Qe[Ke]=!0,Qe[Se]=Qe[ze]=Qe[Ne]=Qe[Pe]=Qe[Ce]=Qe[Ee]=Qe[Te]=Qe[Fe]=Qe[Me]=Qe[Ue]=Qe[$e]=Qe[ke]=Qe[Be]=Qe[De]=Qe[Ie]=!1;var Xe=\"object\"==typeof exports&&exports&&!exports.nodeType&&exports,Ye=Xe&&\"object\"==typeof module&&module&&!module.nodeType&&module,Ze=Ye&&Ye.exports===Xe,to=Ze&&zn.process,ro=function(){try{return to&&to.binding(\"util\")}catch(t){}}(),no=ro&&ro.isTypedArray,eo=no?F(no):T,oo=Object.prototype,uo=oo.hasOwnProperty,io=U(Object.keys,Object),co=Object.prototype,ao=co.hasOwnProperty,fo=Object.prototype,lo=fo.hasOwnProperty,so=A(function(t,r){if(x(r)||w(r))return void p(r,k(r),t);for(var n in r)lo.call(r,n)&&v(t,n,r[n])}),vo=Array.prototype,po=vo.splice;R.prototype.clear=B,R.prototype.delete=I,R.prototype.get=N,R.prototype.has=C,R.prototype.set=L;var ho=f(En,\"Map\"),bo=f(Object,\"create\"),yo=\"__lodash_hash_undefined__\",jo=Object.prototype,go=jo.hasOwnProperty,_o=Object.prototype,wo=_o.hasOwnProperty,Oo=\"__lodash_hash_undefined__\";Y.prototype.clear=H,Y.prototype.delete=J,Y.prototype.get=K,Y.prototype.has=Q,Y.prototype.set=X,it.prototype.clear=Z,it.prototype.delete=nt,it.prototype.get=et,it.prototype.has=ot,it.prototype.set=ut;var mo=200;at.prototype.clear=V,at.prototype.delete=W,at.prototype.get=q,at.prototype.has=G,at.prototype.set=ct;var Ao=\"object\"==typeof exports&&exports&&!exports.nodeType&&exports,xo=Ao&&\"object\"==typeof module&&module&&!module.nodeType&&module,So=xo&&xo.exports===Ao,zo=So?En.Buffer:void 0,Po=zo?zo.allocUnsafe:void 0,Eo=Object.getOwnPropertySymbols,To=Eo?U(Eo,Object):pt,Fo=f(En,\"DataView\"),Mo=f(En,\"Promise\"),Uo=f(En,\"Set\"),$o=f(En,\"WeakMap\"),ko=\"[object Map]\",Bo=\"[object Object]\",Do=\"[object Promise]\",Io=\"[object Set]\",No=\"[object WeakMap]\",Co=\"[object DataView]\",Lo=i(Fo),Ro=i(ho),Vo=i(Mo),Wo=i(Uo),qo=i($o),Go=n;(Fo&&Go(new Fo(new ArrayBuffer(1)))!=Co||ho&&Go(new ho)!=ko||Mo&&Go(Mo.resolve())!=Do||Uo&&Go(new Uo)!=Io||$o&&Go(new $o)!=No)&&(Go=function(t){var r=n(t),e=r==Bo?t.constructor:void 0,o=e?i(e):\"\";if(o)switch(o){case Lo:return Co;case Ro:return ko;case Vo:return Do;case Wo:return Io;case qo:return No}return r});var Ho=Go,Jo=Object.prototype,Ko=Jo.hasOwnProperty,Qo=En.Uint8Array,Xo=/\\w*$/,Yo=Tn?Tn.prototype:void 0,Zo=Yo?Yo.valueOf:void 0,tu=\"[object Boolean]\",ru=\"[object Date]\",nu=\"[object Map]\",eu=\"[object Number]\",ou=\"[object RegExp]\",uu=\"[object Set]\",iu=\"[object String]\",cu=\"[object Symbol]\",au=\"[object ArrayBuffer]\",fu=\"[object DataView]\",lu=\"[object Float32Array]\",su=\"[object Float64Array]\",vu=\"[object Int8Array]\",pu=\"[object Int16Array]\",hu=\"[object Int32Array]\",bu=\"[object Uint8Array]\",yu=\"[object Uint8ClampedArray]\",du=\"[object Uint16Array]\",ju=\"[object Uint32Array]\",gu=Object.create,_u=function(){function t(){}return function(r){if(!e(r))return{};if(gu)return gu(r);t.prototype=r;var n=new t;return t.prototype=void 0,n}}(),wu=U(Object.getPrototypeOf,Object),Ou=\"[object Arguments]\",mu=\"[object Array]\",Au=\"[object Boolean]\",xu=\"[object Date]\",Su=\"[object Error]\",zu=\"[object Function]\",Pu=\"[object GeneratorFunction]\",Eu=\"[object Map]\",Tu=\"[object Number]\",Fu=\"[object Object]\",Mu=\"[object RegExp]\",Uu=\"[object Set]\",$u=\"[object String]\",ku=\"[object Symbol]\",Bu=\"[object WeakMap]\",Du=\"[object ArrayBuffer]\",Iu=\"[object DataView]\",Nu=\"[object Float32Array]\",Cu=\"[object Float64Array]\",Lu=\"[object Int8Array]\",Ru=\"[object Int16Array]\",Vu=\"[object Int32Array]\",Wu=\"[object Uint8Array]\",qu=\"[object Uint8ClampedArray]\",Gu=\"[object Uint16Array]\",Hu=\"[object Uint32Array]\",Ju={};Ju[Ou]=Ju[mu]=Ju[Du]=Ju[Iu]=Ju[Au]=Ju[xu]=Ju[Nu]=Ju[Cu]=Ju[Lu]=Ju[Ru]=Ju[Vu]=Ju[Eu]=Ju[Tu]=Ju[Fu]=Ju[Mu]=Ju[Uu]=Ju[$u]=Ju[ku]=Ju[Wu]=Ju[qu]=Ju[Gu]=Ju[Hu]=!0,Ju[Su]=Ju[zu]=Ju[Bu]=!1;var Ku=function(){return En.Date.now()},Qu=\"[object Symbol]\",Xu=NaN,Yu=/^\\s+|\\s+$/g,Zu=/^[-+]0x[0-9a-f]+$/i,ti=/^0b[01]+$/i,ri=/^0o[0-7]+$/i,ni=parseInt,ei=\"Expected a function\",oi=Math.max,ui=Math.min,ii=Object.prototype,ci=ii.hasOwnProperty,ai=Object.prototype,fi=ai.hasOwnProperty,li=A(function(t,r,n,e){p(r,Vt(r),t,e)}),si=g(function(t){return t.push(void 0,Ct),b(li,void 0,t)}),vi=qt(),pi=\"[object Object]\",hi=Function.prototype,bi=Object.prototype,yi=hi.toString,di=bi.hasOwnProperty,ji=yi.call(Object),gi=A(function(t,r,n,e){Qt(t,r,n,e)}),_i=g(function(t){return t.push(void 0,Xt),b(gi,void 0,t)}),wi=tr(Zt),Oi=\"__lodash_hash_undefined__\";or.prototype.add=or.prototype.push=nr,or.prototype.has=er;var mi=1,Ai=2,xi=1,Si=2,zi=\"[object Boolean]\",Pi=\"[object Date]\",Ei=\"[object Error]\",Ti=\"[object Map]\",Fi=\"[object Number]\",Mi=\"[object RegExp]\",Ui=\"[object Set]\",$i=\"[object String]\",ki=\"[object Symbol]\",Bi=\"[object ArrayBuffer]\",Di=\"[object DataView]\",Ii=Tn?Tn.prototype:void 0,Ni=Ii?Ii.valueOf:void 0,Ci=2,Li=Object.prototype,Ri=Li.hasOwnProperty,Vi=2,Wi=\"[object Arguments]\",qi=\"[object Array]\",Gi=\"[object Object]\",Hi=Object.prototype,Ji=Hi.hasOwnProperty,Ki=1,Qi=2,Xi=\"Expected a function\";dr.Cache=it;var Yi=500,Zi=1/0,tc=Tn?Tn.prototype:void 0,rc=tc?tc.toString:void 0,nc=/^\\./,ec=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,oc=/\\\\(\\\\)?/g,uc=jr(function(t){t=wr(t);var r=[];return nc.test(t)&&r.push(\"\"),t.replace(ec,function(t,n,e,o){r.push(e?o.replace(oc,\"$1\"):n||t)}),r}),ic=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,cc=/^\\w*$/,ac=1/0,fc=1,lc=2,sc=1/0,vc=1.7976931348623157e308,pc=Math.max,hc=Br(Cr),bc=\"[object String]\",yc=Math.max,dc=Math.min,jc=g(function(t){var r=gr(t,tn);return r.length&&r[0]===t[0]?Zr(r):[]}),gc=A(function(t,r,n){Qt(t,r,n)}),_c=\"Expected a function\",wc=Object.getOwnPropertySymbols,Oc=wc?function(t){for(var r=[];t;)bt(r,To(t)),t=wu(t);return r}:pt,mc=Array.prototype,Ac=mc.splice,xc=Tn?Tn.isConcatSpreadable:void 0,Sc=1/0,zc=Uo&&1/zt(new Uo([,-0]))[1]==Sc?function(t){return new Uo(t)}:wn,Pc=200,Ec=g(function(t){return On(_n(t,1,Gt,!0))});module.exports={any:jn,assign:so,clone:$t,cloneDeep:kt,compact:Bt,debounce:Nt,defaults:si,defaultsDeep:_i,filter:kr,find:hc,forEach:Rr,forOwn:Vr,includes:Qr,intersection:jc,isEqual:rn,isNull:nn,keys:k,map:on,merge:gc,omitBy:ln,reject:sn,remove:yn,some:jn,union:Ec,uniq:mn,uniqBy:An,values:Kr,zipObject:Sn}}();\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/blueprints/addon-import/index.js":"'use strict';\n\nconst stringUtil = require('ember-cli-string-utils');\nconst path = require('path');\nconst inflector = require('inflection');\nconst SilentError = require('silent-error');\n\nmodule.exports = {\n  description: 'Generates an import wrapper.',\n  beforeInstall(options) {\n    if (options.originBlueprintName === 'addon-import') {\n      throw new SilentError('You cannot call the addon-import blueprint directly.');\n    }\n  },\n\n  fileMapTokens() {\n    return {\n      __name__(options) {\n        if (options.pod && options.hasPathToken) {\n          return options.locals.blueprintName;\n        }\n        return options.dasherizedModuleName;\n      },\n      __path__(options) {\n        if (options.pod && options.hasPathToken) {\n          return path.join(options.podPath, options.dasherizedModuleName);\n        }\n        return inflector.pluralize(options.locals.blueprintName);\n      },\n      __root__(options) {\n        if (options.inRepoAddon) {\n          return path.join('lib', options.inRepoAddon, 'app');\n        }\n        return 'app';\n      },\n    };\n  },\n  locals(options) {\n    let addonRawName = options.inRepoAddon ? options.inRepoAddon : options.project.name();\n    let addonName = stringUtil.dasherize(addonRawName);\n    let fileName = stringUtil.dasherize(options.entity.name);\n    let blueprintName = options.originBlueprintName;\n    let modulePathSegments = [addonName, inflector.pluralize(options.originBlueprintName), fileName];\n\n    if (blueprintName.match(/-addon/)) {\n      blueprintName = blueprintName.substr(0, blueprintName.indexOf('-addon'));\n      modulePathSegments = [addonName, inflector.pluralize(blueprintName), fileName];\n    }\n\n    if (options.pod) {\n      modulePathSegments = [addonName, fileName, blueprintName];\n    }\n\n    return {\n      modulePath: modulePathSegments.join('/'),\n      blueprintName,\n    };\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/amd-shim.js":"'use strict';\nconst stew = require('broccoli-stew');\n\nmodule.exports = function shimAmd(tree, nameMapping) {\n  return stew.map(tree, (content, relativePath) => {\n    let name = nameMapping[relativePath];\n    if (name) {\n      return [\n        '(function(define){\\n',\n        content,\n        '\\n})((function(){ function newDefine(){ var args = Array.prototype.slice.call(arguments); args.unshift(\"',\n        name,\n        '\"); return define.apply(null, args); }; newDefine.amd = true; return newDefine; })());',\n      ].join('');\n    } else {\n      return content;\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/app-boot.js":"{{content-for 'app-boot'}}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/app-config-from-meta.js":"try {\n  var metaName = prefix + '/config/environment';\n  var rawConfig = document.querySelector('meta[name=\"' + metaName + '\"]').getAttribute('content');\n  var config = JSON.parse(unescape(rawConfig));\n\n  var exports = { 'default': config };\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n}\ncatch(err) {\n  throw new Error('Could not read config from meta tag with name \"' + metaName + '\".');\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/app-config.js":"define('{{MODULE_PREFIX}}/config/environment', ['ember'], function(Ember) {\n  {{content-for 'config-module'}}\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/app-prefix.js":"\"use strict\";\n\n{{content-for 'app-prefix'}}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/app-suffix.js":"{{content-for 'app-suffix'}}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/ember-addon.js":"'use strict';\n\n/**\n@module ember-cli\n*/\nconst defaultsDeep = require('ember-cli-lodash-subset').defaultsDeep;\nconst Funnel = require('broccoli-funnel');\nconst EmberApp = require('./ember-app');\n\nmodule.exports = EmberAddon;\n\n/**\n  EmberAddon is used during addon development.\n\n  @class EmberAddon\n  @extends EmberApp\n  @constructor\n  @param {Object} [defaults]\n  @param {Object} [options={}] Configuration options\n*/\nfunction EmberAddon(defaults, options) {\n  if (arguments.length === 0) {\n    options = {};\n  } else if (arguments.length === 1) {\n    options = defaults;\n  } else {\n    defaultsDeep(options, defaults);\n  }\n\n  process.env.EMBER_ADDON_ENV = process.env.EMBER_ADDON_ENV || 'development';\n\n  this.appConstructor(defaultsDeep(options, {\n    name: 'dummy',\n    configPath: './tests/dummy/config/environment',\n    trees: {\n      app: 'tests/dummy/app',\n      styles: 'tests/dummy/app/styles',\n      templates: 'tests/dummy/app/templates',\n      public: 'tests/dummy/public',\n      tests: new Funnel('tests', {\n        exclude: [/^dummy/],\n      }),\n    },\n    jshintrc: {\n      tests: './tests',\n      app: './tests/dummy',\n    },\n  }));\n}\n\nEmberAddon.__proto__ = EmberApp;\n\nEmberAddon.prototype = Object.create(EmberApp.prototype);\nEmberAddon.prototype.constructor = EmberAddon;\nEmberAddon.prototype.appConstructor = EmberApp.prototype.constructor;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/ember-app.js":"/* global require, module, escape */\n'use strict';\n\n/**\n@module ember-cli\n*/\nconst fs = require('fs');\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst p = require('ember-cli-preprocess-registry/preprocessors');\nconst chalk = require('chalk');\nconst escapeRegExp = require('escape-string-regexp');\nconst crypto = require('crypto');\n\nconst Project = require('../models/project');\nconst cleanBaseURL = require('clean-base-url');\nconst SilentError = require('silent-error');\n\nlet preprocessJs = p.preprocessJs;\nlet preprocessCss = p.preprocessCss;\nlet isType = p.isType;\n\nlet preprocessTemplates = p.preprocessTemplates;\n\nlet preprocessMinifyCss = p.preprocessMinifyCss;\n\nconst Babel = require('broccoli-babel-transpiler');\nconst concat = require('broccoli-concat');\n\nconst ConfigReplace = require('broccoli-config-replace');\nconst ConfigLoader = require('broccoli-config-loader');\nconst mergeTrees = require('./merge-trees');\nconst shimAmd = require('./amd-shim');\nconst WatchedDir = require('broccoli-source').WatchedDir;\nconst UnwatchedDir = require('broccoli-source').UnwatchedDir;\n\nconst merge = require('ember-cli-lodash-subset').merge;\nconst defaultsDeep = require('ember-cli-lodash-subset').defaultsDeep;\nconst omitBy = require('ember-cli-lodash-subset').omitBy;\nconst isNull = require('ember-cli-lodash-subset').isNull;\nconst Funnel = require('broccoli-funnel');\nconst funnelReducer = require('broccoli-funnel-reducer');\nconst logger = require('heimdalljs-logger')('ember-cli:ember-app');\nconst addonProcessTree = require('../utilities/addon-process-tree');\n\nlet SECRET_DEPRECATION_PREVENTION_SYMBOL = crypto.randomBytes(8).toString('hex');\n\nlet DEFAULT_CONFIG = {\n  storeConfigInMeta: true,\n  autoRun: true,\n  outputPaths: {\n    app: {\n      html: 'index.html',\n    },\n    tests: {\n      js: '/assets/tests.js',\n    },\n    vendor: {\n      css: '/assets/vendor.css',\n      js: '/assets/vendor.js',\n    },\n    testSupport: {\n      css: '/assets/test-support.css',\n      js: {\n        testSupport: '/assets/test-support.js',\n        testLoader: '/assets/test-loader.js',\n      },\n    },\n  },\n  minifyCSS: {\n    options: { relativeTo: 'assets' },\n  },\n  sourcemaps: {},\n  trees: {},\n  jshintrc: {},\n  addons: {},\n};\n\nmodule.exports = EmberApp;\n\n/**\n  EmberApp is the main class Ember CLI uses to manage the Broccoli trees\n  for your application. It is very tightly integrated with Broccoli and has\n  a `toTree()` method you can use to get the entire tree for your application.\n\n  Available init options:\n    - storeConfigInMeta, defaults to `true`\n    - autoRun, defaults to `true`\n    - outputPaths, defaults to `{}`\n    - minifyCSS, defaults to `{enabled: !!isProduction,options: { relativeTo: 'assets' }}\n    - minifyJS, defaults to `{enabled: !!isProduction}\n    - sourcemaps, defaults to `{}`\n    - trees, defaults to `{}`\n    - jshintrc, defaults to `{}`\n    - vendorFiles, defaults to `{}`\n    - addons, defaults to `{ blacklist: [], whitelist: [] }`\n\n  @class EmberApp\n  @constructor\n  @param {Object} [defaults]\n  @param {Object} [options={}] Configuration options\n*/\nfunction EmberApp(defaults, options) {\n  if (arguments.length === 0) {\n    options = {};\n  } else if (arguments.length === 1) {\n    options = defaults;\n  } else {\n    defaultsDeep(options, defaults);\n  }\n\n  this._initProject(options);\n  this.name = options.name || this.project.name();\n\n  this.env = EmberApp.env();\n  this.isProduction = (this.env === 'production');\n\n  this.registry = options.registry || p.defaultRegistry(this);\n\n  this.bowerDirectory = this.project.bowerDirectory;\n\n  this._initTestsAndHinting(options);\n  this._initOptions(options);\n  this._initVendorFiles();\n\n  this._styleOutputFiles = {};\n  this._scriptOutputFiles = {};\n  this.amdModuleNames = null;\n\n  this.legacyFilesToAppend = [];\n  this.vendorStaticStyles = [];\n  this.otherAssetPaths = [];\n  this.legacyTestFilesToAppend = [];\n  this.vendorTestStaticStyles = [];\n\n  this.trees = this.options.trees;\n\n  this.populateLegacyFiles();\n  p.setupRegistry(this);\n  this._notifyAddonIncluded();\n\n  if (!this._addonInstalled('loader.js') && !this.options._ignoreMissingLoader) {\n    throw new SilentError('The loader.js addon is missing from your project, please add it to `package.json`.');\n  }\n}\n\n/**\n  Initializes the `tests` and `hinting` properties.\n\n  Defaults to `false` unless `ember test` was used or this is *not* a production build.\n\n  @private\n  @method _initTestsAndHinting\n  @param {Object} options\n*/\nEmberApp.prototype._initTestsAndHinting = function(options) {\n  let testsEnabledDefault = process.env.EMBER_CLI_TEST_COMMAND || !this.isProduction;\n\n  this.tests = options.hasOwnProperty('tests') ? options.tests : testsEnabledDefault;\n  this.hinting = options.hasOwnProperty('hinting') ? options.hinting : testsEnabledDefault;\n};\n\n/**\n  Initializes the `project` property from `options.project` or the\n  closest Ember CLI project from the current working directory.\n\n  @private\n  @method _initProject\n  @param {Object} options\n*/\nEmberApp.prototype._initProject = function(options) {\n  let app = this;\n\n  this.project = options.project || Project.closestSync(process.cwd());\n\n  if (options.configPath) {\n    this.project.configPath = function() { return app._resolveLocal(options.configPath); };\n  }\n};\n\n/**\n  Initializes the `options` property from the `options` parameter and\n  a set of default values from Ember CLI.\n\n  @private\n  @method _initOptions\n  @param {Object} options\n*/\nEmberApp.prototype._initOptions = function(options) {\n  let appTree = new WatchedDir(this._resolveLocal('app'));\n\n  let testsPath = this._resolveLocal('tests');\n  let testsTree = existsSync(testsPath) ? new WatchedDir(testsPath) : null;\n\n  // these are contained within app/ no need to watch again\n  // (we should probably have the builder or the watcher dedup though)\n  let stylesTree = new UnwatchedDir(this._resolveLocal('app/styles'));\n  let templatesPath = this._resolveLocal('app/templates');\n  let templatesTree = existsSync(templatesPath) ? new UnwatchedDir(templatesPath) : null;\n\n  // do not watch bower's default directory by default\n  let bowerTree = this.project._watchmanInfo.enabled ? this.bowerDirectory : new UnwatchedDir(this.bowerDirectory);\n\n  let vendorPath = this._resolveLocal('vendor');\n  let vendorTree = existsSync(vendorPath) ? new WatchedDir(vendorPath) : null;\n\n  let publicPath = this._resolveLocal('public');\n  let publicTree = existsSync(publicPath) ? new WatchedDir(publicPath) : null;\n\n  let detectedDefaultOptions = {\n    babel: {\n      modules: 'amdStrict',\n      moduleIds: true,\n      resolveModuleSource: require('amd-name-resolver').moduleResolve,\n    },\n    jshintrc: {\n      app: this.project.root,\n      tests: this._resolveLocal('tests'),\n    },\n    minifyCSS: {\n      enabled: this.isProduction,\n      options: { processImport: false },\n    },\n    minifyJS: {\n      enabled: this.isProduction,\n    },\n    outputPaths: {\n      app: {\n        css: {\n          'app': `/assets/${this.name}.css`,\n        },\n        js: `/assets/${this.name}.js`,\n      },\n    },\n    sourcemaps: {\n      enabled: !this.isProduction,\n      extensions: ['js'],\n    },\n    trees: {\n      app: appTree,\n      tests: testsTree,\n      styles: stylesTree,\n      templates: templatesTree,\n      bower: bowerTree,\n      vendor: vendorTree,\n      public: publicTree,\n    },\n  };\n\n  let emberCLIBabelInstance = this.project.findAddonByName('ember-cli-babel');\n  if (emberCLIBabelInstance) {\n    // future versions of ember-cli-babel will be moving the location for its\n    // own configuration options out of `babel` and will be issuing a deprecation\n    // if used in the older way\n    //\n    // see: https://github.com/babel/ember-cli-babel/pull/105\n    let emberCLIBabelConfigKey = emberCLIBabelInstance.configKey || 'babel';\n    detectedDefaultOptions[emberCLIBabelConfigKey] = detectedDefaultOptions[emberCLIBabelConfigKey] || {};\n    detectedDefaultOptions[emberCLIBabelConfigKey].compileModules = true;\n  }\n\n  this.options = defaultsDeep(options, detectedDefaultOptions, DEFAULT_CONFIG);\n\n  // For now we must disable Babel sourcemaps due to unforseen\n  // performance regressions.\n  if (!('sourceMaps' in this.options.babel)) {\n    this.options.babel.sourceMaps = false;\n  }\n};\n\n/**\n  Resolves a path relative to the project's root\n\n  @private\n  @method _resolveLocal\n*/\nEmberApp.prototype._resolveLocal = function(to) {\n  return path.join(this.project.root, to);\n};\n\n/**\n  @private\n  @method _initVendorFiles\n*/\nEmberApp.prototype._initVendorFiles = function() {\n  let bowerDeps = this.project.bowerDependencies();\n  let ember = this.project.findAddonByName('ember-source');\n  let addonEmberCliShims = this.project.findAddonByName('ember-cli-shims');\n  let bowerEmberCliShims = bowerDeps['ember-cli-shims'];\n  let developmentEmber;\n  let productionEmber;\n  let emberTesting;\n  let emberShims = null;\n  let jquery;\n\n  if (ember) {\n    developmentEmber = ember.paths.debug;\n    productionEmber = ember.paths.prod;\n    emberTesting = ember.paths.testing;\n    emberShims = ember.paths.shims;\n    jquery = ember.paths.jquery;\n  } else {\n    jquery = `${this.bowerDirectory}/jquery/dist/jquery.js`;\n\n    if (bowerEmberCliShims) {\n      emberShims = `${this.bowerDirectory}/ember-cli-shims/app-shims.js`;\n    }\n\n    // in Ember 1.10 and higher `ember.js` is deprecated in favor of\n    // the more aptly named `ember.debug.js`.\n    productionEmber = `${this.bowerDirectory}/ember/ember.prod.js`;\n    developmentEmber = `${this.bowerDirectory}/ember/ember.debug.js`;\n    if (!existsSync(this._resolveLocal(developmentEmber))) {\n      developmentEmber = `${this.bowerDirectory}/ember/ember.js`;\n    }\n\n    emberTesting = `${this.bowerDirectory}/ember/ember-testing.js`;\n  }\n\n  let handlebarsVendorFiles;\n  if ('handlebars' in bowerDeps) {\n    handlebarsVendorFiles = {\n      development: `${this.bowerDirectory}/handlebars/handlebars.js`,\n      production: `${this.bowerDirectory}/handlebars/handlebars.runtime.js`,\n    };\n  } else {\n    handlebarsVendorFiles = null;\n  }\n\n  this.vendorFiles = omitBy(merge({\n    'jquery.js': jquery,\n    'handlebars.js': handlebarsVendorFiles,\n    'ember.js': {\n      development: developmentEmber,\n      production: productionEmber,\n    },\n    'ember-testing.js': [\n      emberTesting,\n      { type: 'test' },\n    ],\n    'app-shims.js': emberShims,\n    'ember-resolver.js': [\n      `${this.bowerDirectory}/ember-resolver/dist/modules/ember-resolver.js`, {\n        exports: {\n          'ember/resolver': ['default'],\n        },\n      },\n    ],\n  }, this.options.vendorFiles), isNull);\n\n  if (this._addonInstalled('ember-resolver') || !bowerDeps['ember-resolver']) {\n    // if the project is using `ember-resolver` as an addon\n    // remove it from `vendorFiles` (the NPM version properly works\n    // without `app.import`s)\n    delete this.vendorFiles['ember-resolver.js'];\n  }\n\n  // Warn if ember-cli-shims is not included.\n  // certain versions of `ember-source` bundle them by default,\n  // so we must check if that is the load mechanism of ember\n  // before checking `bower`.\n  if (!emberShims && !addonEmberCliShims && !bowerEmberCliShims) {\n    this.project.ui.writeWarnLine('You have not included `ember-cli-shims` in your project\\'s `bower.json` or `package.json`. This only works if you provide an alternative yourself and unset `app.vendorFiles[\\'app-shims.js\\']`.');\n  }\n\n  // If ember-testing.js is coming from Bower (not ember-source) and it does not\n  // exist, then we remove it from vendor files. This is needed to support versions\n  // of Ember older than 1.8.0 (when ember-testing.js was incldued in ember.js itself)\n  if (!ember && this.vendorFiles['ember-testing.js'] && !existsSync(this.vendorFiles['ember-testing.js'][0])) {\n    delete this.vendorFiles['ember-testing.js'];\n  }\n};\n\n/**\n  Returns the environment name\n\n  @public\n  @static\n  @method env\n  @return {String} Environment name\n */\nEmberApp.env = function() {\n  return process.env.EMBER_ENV || 'development';\n};\n\n/**\n  Provides a broccoli files concatenation filter that's configured\n  properly for this application.\n\n  @deprecated\n  @method concatFiles\n  @param tree\n  @param options\n  @return\n*/\nEmberApp.prototype.concatFiles = function(tree, options) {\n  this.project.ui.writeDeprecateLine('EmberApp.concatFiles() is deprecated. Please use the `broccoli-concat` module directly.',\n    arguments[2] === SECRET_DEPRECATION_PREVENTION_SYMBOL);\n\n  options.sourceMapConfig = this.options.sourcemaps;\n\n  return concat(tree, options);\n};\n\n/**\n  Delegates to `broccoli-concat` with the `sourceMapConfig` option set to `options.sourcemaps`.\n\n  @private\n  @method _concatFiles\n  @param tree\n  @param options\n  @return\n*/\nEmberApp.prototype._concatFiles = function(tree, options) {\n  return this.concatFiles(tree, options, SECRET_DEPRECATION_PREVENTION_SYMBOL);\n};\n\n/**\n  Checks the result of `addon.isEnabled()` if it exists, defaults to `true` otherwise.\n\n  @private\n  @method _addonEnabled\n  @param {Addon} addon\n  @return {Boolean}\n*/\nEmberApp.prototype._addonEnabled = function(addon) {\n  return !addon.isEnabled || addon.isEnabled();\n};\n\n/**\n  @private\n  @method _addonDisabledByBlacklist\n  @param {Addon} addon\n  @return {Boolean}\n*/\nEmberApp.prototype._addonDisabledByBlacklist = function(addon) {\n  let blacklist = this.options.addons.blacklist;\n  return !!blacklist && blacklist.indexOf(addon.name) !== -1;\n};\n\n/**\n  @private\n  @method _addonDisabledByWhitelist\n  @param {Addon} addon\n  @return {Boolean}\n*/\nEmberApp.prototype._addonDisabledByWhitelist = function(addon) {\n  let whitelist = this.options.addons.whitelist;\n  return !!whitelist && whitelist.indexOf(addon.name) === -1;\n};\n\n/**\n  Returns whether an addon should be added to the project\n\n  @private\n  @method shouldIncludeAddon\n  @param {Addon} addon\n  @return {Boolean}\n*/\nEmberApp.prototype.shouldIncludeAddon = function(addon) {\n  if (!this._addonEnabled(addon)) {\n    return false;\n  }\n\n  return !this._addonDisabledByBlacklist(addon) && !this._addonDisabledByWhitelist(addon);\n};\n\n\n\n/**\n  @private\n  @method _notifyAddonIncluded\n*/\nEmberApp.prototype._notifyAddonIncluded = function() {\n  this.initializeAddons();\n\n  let addonNames = this.project.addons.map(addon => addon.name);\n\n  if (this.options.addons.blacklist) {\n    this.options.addons.blacklist.forEach(addonName => {\n      if (addonNames.indexOf(addonName) === -1) {\n        throw new Error(`Addon \"${addonName}\" defined in blacklist is not found`);\n      }\n    });\n  }\n\n  if (this.options.addons.whitelist) {\n    this.options.addons.whitelist.forEach(addonName => {\n      if (addonNames.indexOf(addonName) === -1) {\n        throw new Error(`Addon \"${addonName}\" defined in whitelist is not found`);\n      }\n    });\n  }\n\n  this.project.addons = this.project.addons.filter(function(addon) {\n    addon.app = this;\n\n    if (this.shouldIncludeAddon(addon)) {\n      if (addon.included) {\n        addon.included(this);\n      }\n\n      return addon;\n    }\n  }, this);\n};\n\n/**\n  Loads and initializes addons for this project.\n  Calls initializeAddons on the Project.\n\n  @private\n  @method initializeAddons\n*/\nEmberApp.prototype.initializeAddons = function() {\n  this.project.initializeAddons();\n};\n\n/**\n  Returns a list of trees for a given type, returned by all addons.\n\n  @private\n  @method addonTreesFor\n  @param  {String} type Type of tree\n  @return {Array}       List of trees\n */\nEmberApp.prototype.addonTreesFor = function(type) {\n  return this.project.addons.map(addon => {\n    if (addon.treeFor) {\n      return addon.treeFor(type);\n    }\n  }).filter(Boolean);\n};\n\n/**\n  Runs addon post-processing on a given tree and returns the processed tree.\n\n  This enables addons to do process immediately **after** the preprocessor for a\n  given type is run, but before concatenation occurs. If an addon wishes to\n  apply a transform before the preprocessors run, they can instead implement the\n  preprocessTree hook.\n\n  To utilize this addons implement `postprocessTree` hook.\n\n  An example, would be to apply some broccoli transform on all JS files, but\n  only after the existing pre-processors have run.\n\n  ```js\n  module.exports = {\n    name: 'my-cool-addon',\n    postprocessTree: function(type, tree) {\n      if (type === 'js') {\n        return someBroccoliTransform(tree);\n      }\n\n      return tree;\n    }\n  }\n\n  ```\n\n  @private\n  @method addonPostprocessTree\n  @param  {String} type Type of tree\n  @param  {Tree}   tree Tree to process\n  @return {Tree}        Processed tree\n */\nEmberApp.prototype.addonPostprocessTree = function(type, tree) {\n  return addonProcessTree(this.project, 'postprocessTree', type, tree);\n};\n\n\n/**\n  Runs addon pre-processing on a given tree and returns the processed tree.\n\n  This enables addons to do process immediately **before** the preprocessor for a\n  given type is run.  If an addon wishes to apply a transform  after the\n  preprocessors run, they can instead implement the postprocessTree hook.\n\n  To utilize this addons implement `preprocessTree` hook.\n\n  An example, would be to remove some set of files before the preprocessors run.\n\n  ```js\n  var stew = require('broccoli-stew');\n\n  module.exports = {\n    name: 'my-cool-addon',\n    preprocessTree: function(type, tree) {\n      if (type === 'js' && type === 'template') {\n        return stew.rm(tree, someGlobPattern);\n      }\n\n      return tree;\n    }\n  }\n  ```\n\n  @private\n  @method addonPreprocessTree\n  @param  {String} type Type of tree\n  @param  {Tree}   tree Tree to process\n  @return {Tree}        Processed tree\n */\nEmberApp.prototype.addonPreprocessTree = function(type, tree) {\n  return addonProcessTree(this.project, 'preprocessTree', type, tree);\n};\n\n/**\n  Runs addon lintTree hooks and returns a single tree containing all\n  their output.\n\n  @private\n  @method addonLintTree\n  @param  {String} type Type of tree\n  @param  {Tree}   tree Tree to process\n  @return {Tree}        Processed tree\n */\nEmberApp.prototype.addonLintTree = function(type, tree) {\n  let output = this.project.addons.map(addon => {\n    if (addon.lintTree) {\n      return addon.lintTree(type, tree);\n    }\n  }).filter(Boolean);\n\n  return mergeTrees(output, {\n    overwrite: true,\n    annotation: `TreeMerger (lint ${type})`,\n  });\n};\n\n/**\n  Imports legacy imports in this.vendorFiles\n\n  @private\n  @method populateLegacyFiles\n*/\nEmberApp.prototype.populateLegacyFiles = function() {\n  let name;\n  for (name in this.vendorFiles) {\n    let args = this.vendorFiles[name];\n\n    if (args === null) { continue; }\n\n    this.import.apply(this, [].concat(args));\n  }\n};\n\n/**\n  Returns the tree for app/index.html\n\n  @private\n  @method index\n  @return {Tree} Tree for app/index.html\n*/\nEmberApp.prototype.index = function() {\n  let htmlName = this.options.outputPaths.app.html;\n  let files = [\n    'index.html',\n  ];\n\n  let index = new Funnel(this.trees.app, {\n    files,\n    getDestinationPath(relativePath) {\n      if (relativePath === 'index.html') {\n        relativePath = htmlName;\n      }\n      return relativePath;\n    },\n    annotation: 'Funnel: index.html',\n  });\n\n  return new ConfigReplace(index, this._configTree(), {\n    configPath: path.join(this.name, 'config', 'environments', `${this.env}.json`),\n    files: [htmlName],\n    patterns: this._configReplacePatterns(),\n  });\n};\n\n/**\n  Filters styles and templates from the `app` tree.\n\n  @private\n  @method _filterAppTree\n  @return {Tree}\n*/\nEmberApp.prototype._filterAppTree = function() {\n  if (this._cachedFilterAppTree) {\n    return this._cachedFilterAppTree;\n  }\n\n  let podPatterns = this._podTemplatePatterns();\n  let excludePatterns = podPatterns.concat([\n    // note: do not use path.sep here Funnel uses\n    // walk-sync which always joins with `/` (not path.sep)\n    'styles/**/*',\n    'templates/**/*',\n  ]);\n\n  this._cachedFilterAppTree = new Funnel(this.trees.app, {\n    exclude: excludePatterns,\n    annotation: 'Funnel: Filtered App',\n  });\n\n  return this._cachedFilterAppTree;\n};\n\nEmberApp.prototype.podTemplates = function() {\n  return new Funnel(this.trees.app, {\n    include: this._podTemplatePatterns(),\n    exclude: ['templates/**/*'],\n    destDir: `${this.name}/`,\n    annotation: 'Funnel: Pod Templates',\n  });\n};\n\nEmberApp.prototype._templatesTree = function() {\n  if (this._cachedTemplateTree) {\n    return this._cachedTemplateTree;\n  }\n\n  let trees = [];\n  if (this.trees.templates) {\n    let standardTemplates = new Funnel(this.trees.templates, {\n      srcDir: '/',\n      destDir: `${this.name}/templates`,\n      annotation: 'Funnel: Templates',\n    });\n\n    trees.push(standardTemplates);\n  }\n\n  if (this.trees.app) {\n    trees.push(this.podTemplates());\n  }\n\n  this._cachedTemplateTree = mergeTrees(trees, {\n    annotation: 'TreeMerge (templates)',\n  });\n\n  return this._cachedTemplateTree;\n};\n\n/**\n  @private\n  @method _configReplacePatterns\n  @return\n*/\nEmberApp.prototype._configReplacePatterns = function() {\n  return [{\n    match: /\\{\\{rootURL\\}\\}/g,\n    replacement: calculateRootURL,\n  }, {\n    match: /\\{\\{EMBER_ENV\\}\\}/g,\n    replacement: calculateEmberENV,\n  }, {\n    match: /\\{\\{content-for ['\"](.+)[\"']\\}\\}/g,\n    replacement: this.contentFor.bind(this),\n  }, {\n    match: /\\{\\{MODULE_PREFIX\\}\\}/g,\n    replacement: calculateModulePrefix,\n  }];\n};\n\n/**\n  Returns the tree for /tests/index.html\n\n  @private\n  @method testIndex\n  @return {Tree} Tree for /tests/index.html\n */\nEmberApp.prototype.testIndex = function() {\n  let index = new Funnel(this.trees.tests, {\n    srcDir: '/',\n    files: ['index.html'],\n    destDir: '/tests',\n    annotation: 'Funnel (test index)',\n  });\n\n  return new ConfigReplace(index, this._configTree(), {\n    configPath: path.join(this.name, 'config', 'environments', 'test.json'),\n    files: ['tests/index.html'],\n    env: 'test',\n    patterns: this._configReplacePatterns(),\n  });\n};\n\n/**\n  Returns the tree for /public\n\n  @private\n  @method publicTree\n  @return {Tree} Tree for /public\n */\nEmberApp.prototype.publicTree = function() {\n  let trees = this.addonTreesFor('public');\n\n  if (this.trees.public) {\n    trees.push(this.trees.public);\n  }\n\n  return mergeTrees(trees, {\n    overwrite: true,\n    annotation: 'TreeMerge (public)',\n  });\n};\n\n\n/**\n  @private\n  @method _processedAppTree\n  @return\n*/\nEmberApp.prototype._processedAppTree = function() {\n  let addonTrees = this.addonTreesFor('app');\n  let mergedApp = mergeTrees(addonTrees.concat(this._filterAppTree()), {\n    overwrite: true,\n    annotation: 'TreeMerger (app)',\n  });\n\n  return new Funnel(mergedApp, {\n    srcDir: '/',\n    destDir: this.name,\n    annotation: 'ProcessedAppTree',\n  });\n};\n\n/**\n  @private\n  @method _processedTemplatesTree\n  @return\n*/\nEmberApp.prototype._processedTemplatesTree = function() {\n  let addonTrees = this.addonTreesFor('templates');\n  let mergedTemplates = mergeTrees(addonTrees, {\n    overwrite: true,\n    annotation: 'TreeMerger (templates)',\n  });\n\n  let addonTemplates = new Funnel(mergedTemplates, {\n    srcDir: '/',\n    destDir: `${this.name}/templates`,\n    annotation: 'ProcessedTemplateTree',\n  });\n\n  let combinedTemplates = mergeTrees([\n    addonTemplates,\n    this._templatesTree(),\n  ], {\n    annotation: 'addonPreprocessTree(template)',\n    overwrite: true,\n  });\n\n  let templates = this.addonPreprocessTree('template', combinedTemplates);\n\n  return this.addonPostprocessTree('template', preprocessTemplates(templates, {\n    registry: this.registry,\n    annotation: 'TreeMerger (pod & standard templates)',\n  }));\n};\n\n/**\n  @private\n  @method _podTemplatePatterns\n  @return {Array} An array of regular expressions.\n*/\nEmberApp.prototype._podTemplatePatterns = function() {\n  return this.registry.extensionsForType('template')\n    .map(extension => `**/*/template.${extension}`);\n};\n\n/**\n  @private\n  @method _processedTestsTree\n  @return\n*/\nEmberApp.prototype._processedTestsTree = function() {\n  let addonTrees = this.addonTreesFor('test-support');\n  let mergedTests = mergeTrees(addonTrees.concat(this.trees.tests), {\n    overwrite: true,\n    annotation: 'TreeMerger (tests)',\n  });\n\n  return new Funnel(mergedTests, {\n    srcDir: '/',\n    destDir: `${this.name}/tests`,\n    annotation: 'ProcessedTestTree',\n  });\n};\n\n/**\n  @private\n  @method _processedBowerTree\n  @return\n*/\nEmberApp.prototype._processedBowerTree = function() {\n  if (this._cachedBowerTree) {\n    return this._cachedBowerTree;\n  }\n\n  // do not attempt to merge bower and vendor together\n  // if they are the same tree\n  if (this.bowerDirectory === 'vendor') {\n    return;\n  }\n\n    // Don't blow up if there is no bower_components folder.\n  if (!existsSync(this.bowerDirectory)) {\n    return;\n  }\n\n  this._cachedBowerTree = new Funnel(this.trees.bower, {\n    srcDir: '/',\n    destDir: `${this.bowerDirectory}/`,\n    annotation: 'Funnel (bower)',\n  });\n\n  return this._cachedBowerTree;\n};\n\nEmberApp.prototype._addonTree = function _addonTree() {\n  if (this._cachedAddonTree) {\n    return this._cachedAddonTree;\n  }\n\n  let addonTrees = mergeTrees(this.addonTreesFor('addon'), {\n    overwrite: true,\n    annotation: 'TreeMerger (addons)',\n  });\n\n  let addonTranspiledModules = new Funnel(addonTrees, {\n    srcDir: 'modules',\n    allowEmpty: true,\n    annotation: 'Funnel: Addon JS',\n  });\n\n  return this._cachedAddonTree = [\n    this._concatFiles(addonTrees, {\n      inputFiles: ['**/*.css'],\n      outputFile: '/addons.css',\n      allowNone: true,\n      annotation: 'Concat: Addon CSS',\n    }),\n\n    this._concatFiles(addonTranspiledModules, {\n      inputFiles: ['**/*.js'],\n      outputFile: '/addons.js',\n      allowNone: true,\n      annotation: 'Concat: Addon JS',\n    }),\n  ];\n};\n\n/**\n  @private\n  @method _processedVendorTree\n  @return\n*/\nEmberApp.prototype._processedVendorTree = function() {\n  if (this._cachedVendorTree) {\n    return this._cachedVendorTree;\n  }\n\n  let trees = this._addonTree();\n  trees = trees.concat(this.addonTreesFor('vendor'));\n\n  if (this.trees.vendor) {\n    trees.push(this.trees.vendor);\n  }\n\n  let mergedVendor = mergeTrees(trees, {\n    overwrite: true,\n    annotation: 'TreeMerger (vendor)',\n  });\n\n  this._cachedVendorTree = new Funnel(mergedVendor, {\n    srcDir: '/',\n    destDir: 'vendor/',\n    annotation: 'Funnel (vendor)',\n  });\n\n  return this._cachedVendorTree;\n};\n\n/**\n  @private\n  @method _processedExternalTree\n  @return\n*/\nEmberApp.prototype._processedExternalTree = function() {\n  if (this._cachedExternalTree) {\n    return this._cachedExternalTree;\n  }\n\n  let vendor = this._processedVendorTree();\n  let bower = this._processedBowerTree();\n\n  let trees = [vendor];\n  if (bower) {\n    trees.unshift(bower);\n  }\n\n  let externalTree = mergeTrees(trees, {\n    annotation: 'TreeMerger (ExternalTree)',\n  });\n\n  if (this.amdModuleNames) {\n    let anonymousAmd = new Funnel(externalTree, {\n      files: Object.keys(this.amdModuleNames),\n      annotation: 'Funnel (named AMD)',\n    });\n    externalTree = mergeTrees([externalTree, shimAmd(anonymousAmd, this.amdModuleNames)], {\n      annotation: 'TreeMerger (named AMD)',\n      overwrite: true,\n    });\n  }\n\n  return this._cachedExternalTree = externalTree;\n};\n\n/**\n  @private\n  @method _configTree\n  @return\n*/\nEmberApp.prototype._configTree = function() {\n  if (this._cachedConfigTree) {\n    return this._cachedConfigTree;\n  }\n\n  let configPath = this.project.configPath();\n  let configTree = new ConfigLoader(path.dirname(configPath), {\n    env: this.env,\n    tests: this.tests,\n    project: this.project,\n  });\n\n  this._cachedConfigTree = new Funnel(configTree, {\n    srcDir: '/',\n    destDir: `${this.name}/config`,\n    annotation: 'Funnel (config)',\n  });\n\n  return this._cachedConfigTree;\n};\n\n/**\n  @private\n  @method _processedEmberCLITree\n  @return\n*/\nEmberApp.prototype._processedEmberCLITree = function() {\n  if (this._cachedEmberCLITree) {\n    return this._cachedEmberCLITree;\n  }\n\n  let files = [\n    'vendor-prefix.js',\n    'vendor-suffix.js',\n    'app-prefix.js',\n    'app-suffix.js',\n    'app-config.js',\n    'app-boot.js',\n    'test-support-prefix.js',\n    'test-support-suffix.js',\n    'tests-prefix.js',\n    'tests-suffix.js',\n  ];\n  let emberCLITree = new ConfigReplace(new UnwatchedDir(__dirname), this._configTree(), {\n    configPath: path.join(this.name, 'config', 'environments', `${this.env}.json`),\n    files,\n\n    patterns: this._configReplacePatterns(),\n  });\n\n  return this._cachedEmberCLITree = new Funnel(emberCLITree, {\n    files,\n    srcDir: '/',\n    destDir: '/vendor/ember-cli/',\n    annotation: 'Funnel (ember-cli-tree)',\n  });\n};\n\n/**\n  Returns the tree for the app and its dependencies\n\n  @private\n  @method appAndDependencies\n  @return {Tree} Merged tree\n*/\nEmberApp.prototype.appAndDependencies = function() {\n  let sourceTrees = [];\n  let config = this._configTree();\n  let templates = this._processedTemplatesTree();\n\n  let app = this.addonPreprocessTree('js', mergeTrees([\n    this._processedAppTree(),\n    templates,\n  ].concat(sourceTrees), {\n    annotation: 'TreeMerger (preprocessedApp & templates)',\n    overwrite: true,\n  }));\n\n  let external = this._processedExternalTree();\n  let preprocessedApp = preprocessJs(app, '/', this.name, {\n    registry: this.registry,\n  });\n\n  let postprocessedApp = this.addonPostprocessTree('js', preprocessedApp);\n  sourceTrees = sourceTrees.concat([\n    external,\n    postprocessedApp,\n    config,\n  ]);\n\n  let emberCLITree = this._processedEmberCLITree();\n\n  sourceTrees.push(emberCLITree);\n\n  return mergeTrees(sourceTrees, {\n    overwrite: true,\n    annotation: 'TreeMerger (appAndDependencies)',\n  });\n};\n\nEmberApp.prototype.test = function() {\n  let tests = this.addonPreprocessTree('test', this._processedTestsTree());\n  let preprocessedTests = preprocessJs(tests, '/tests', this.name, {\n    registry: this.registry,\n  });\n  let coreTestTree = this.addonPostprocessTree('test', preprocessedTests);\n\n  let appTestTree = this.appTests(coreTestTree);\n  let testFilesTree = this.testFiles(coreTestTree);\n\n  return mergeTrees([appTestTree, testFilesTree], {\n    annotation: 'TreeMerger (test)',\n  });\n};\n\n/**\n  @private\n  @method appTests\n*/\nEmberApp.prototype.appTests = function(coreTestTree) {\n  let appTestTrees = [coreTestTree];\n\n  if (this.hinting) {\n    Array.prototype.push.apply(appTestTrees, this.lintTestTrees());\n  }\n\n  appTestTrees.push(this._processedEmberCLITree());\n\n  appTestTrees = mergeTrees(appTestTrees, {\n    overwrite: true,\n    annotation: 'TreeMerger (appTestTrees)',\n  });\n\n  return this._concatFiles(appTestTrees, {\n    inputFiles: [`${this.name}/tests/**/*.js`],\n    headerFiles: ['vendor/ember-cli/tests-prefix.js'],\n    footerFiles: ['vendor/ember-cli/tests-suffix.js'],\n    outputFile: this.options.outputPaths.tests.js,\n    annotation: 'Concat: App Tests',\n  });\n};\n\n/**\n  Runs the `app`, `tests` and `templates` trees through the chain of addons that produces lint trees.\n\n  Those lint trees are afterwards funneled into the `tests` folder, babel-ified and returned as an array.\n\n  @private\n  @method lintTestsTrees\n  @return {Array}\n */\nEmberApp.prototype.lintTestTrees = function() {\n  let lintedApp = this.addonLintTree('app', this._filterAppTree());\n  let lintedTests = this.addonLintTree('tests', this.trees.tests);\n  let lintedTemplates = this.addonLintTree('templates', this._templatesTree());\n\n  lintedApp = new Babel(new Funnel(lintedApp, {\n    srcDir: '/',\n    destDir: `${this.name}/tests/`,\n    annotation: 'Funnel (lint app)',\n  }), this._prunedBabelOptions());\n\n  lintedTests = new Babel(new Funnel(lintedTests, {\n    srcDir: '/',\n    destDir: `${this.name}/tests/`,\n    annotation: 'Funnel (lint tests)',\n  }), this._prunedBabelOptions());\n\n  lintedTemplates = new Babel(new Funnel(lintedTemplates, {\n    srcDir: '/',\n    destDir: `${this.name}/tests/`,\n    annotation: 'Funnel (lint templates)',\n  }), this._prunedBabelOptions());\n\n  return [lintedApp, lintedTests, lintedTemplates];\n};\n\n/**\n * @private\n * @method _addonInstalled\n * @param  {String} addonName The name of the addon we are checking to see if it's installed\n * @return {Boolean}\n */\nEmberApp.prototype._addonInstalled = function(addonName) {\n  return !!this.registry.availablePlugins[addonName];\n};\n\n/**\n * Returns `options.babel` without the `compileModules` and `includePolyfill` properties.\n *\n * @private\n * @method _prunedBabelOptions\n * @return {Object} The pruned babel options\n */\nEmberApp.prototype._prunedBabelOptions = function() {\n  let babelOptions = merge({}, this.options.babel);\n  delete babelOptions.compileModules;\n  delete babelOptions.includePolyfill;\n  return babelOptions;\n};\n\n/**\n  Returns the tree for javascript files\n\n  @private\n  @method javascript\n  @return {Tree} Merged tree\n*/\nEmberApp.prototype.javascript = function() {\n  let deprecate = this.project.ui.writeDeprecateLine.bind(this.project.ui);\n  let applicationJs = this.appAndDependencies();\n  let appOutputPath = this.options.outputPaths.app.js;\n  let appJs = applicationJs;\n\n  // Note: If ember-cli-babel is installed we have already performed the transpilation at this point\n  if (!this._addonInstalled('ember-cli-babel')) {\n    appJs = new Babel(\n      new Funnel(applicationJs, {\n        include: [`${escapeRegExp(`${this.name}/`)}**/*.js`],\n        annotation: 'Funnel: App JS Files',\n      }),\n      merge(this._prunedBabelOptions())\n    );\n  }\n\n  appJs = mergeTrees([\n    appJs,\n    this._processedEmberCLITree(),\n  ], {\n    annotation: 'TreeMerger (appJS  & processedEmberCLITree)',\n    overwrite: true,\n  });\n\n  appJs = this._concatFiles(appJs, {\n    inputFiles: [`${this.name}/**/*.js`],\n    headerFiles: [\n      'vendor/ember-cli/app-prefix.js',\n    ],\n    footerFiles: [\n      'vendor/ember-cli/app-suffix.js',\n      'vendor/ember-cli/app-config.js',\n      'vendor/ember-cli/app-boot.js',\n    ],\n    outputFile: appOutputPath,\n    annotation: 'Concat: App',\n  });\n\n  if (this.legacyFilesToAppend.length > 0) {\n    deprecate(`Usage of EmberApp.legacyFilesToAppend is deprecated. ` +\n      `Please use EmberApp.import instead for the following files: '${this.legacyFilesToAppend.join('\\', \\'')}'`);\n\n    this.legacyFilesToAppend.forEach(legacyFile => {\n      this.import(legacyFile);\n    });\n  }\n\n  this.import('vendor/ember-cli/vendor-prefix.js', { prepend: true });\n  this.import('vendor/addons.js');\n  this.import('vendor/ember-cli/vendor-suffix.js');\n\n  let vendorFiles = [];\n  for (let outputFile in this._scriptOutputFiles) {\n    let headerFiles = this._scriptOutputFiles[outputFile];\n\n    vendorFiles.push(\n      this._concatFiles(applicationJs, {\n        headerFiles,\n        outputFile,\n        separator: '\\n;',\n        annotation: `Concat: Vendor ${outputFile}`,\n      })\n    );\n  }\n\n  return mergeTrees(vendorFiles.concat(appJs), {\n    annotation: 'TreeMerger (vendor & appJS)',\n  });\n};\n\n/**\n  Returns the tree for styles\n\n  @private\n  @method styles\n  @return {Tree} Merged tree for styles\n*/\nEmberApp.prototype.styles = function() {\n  if (this._cachedStylesTree) {\n    return this._cachedStylesTree;\n  }\n\n  if (existsSync(`app/styles/${this.name}.css`)) {\n    throw new SilentError(`Style file cannot have the name of the application - ${this.name}`);\n  }\n\n  let addonTrees = this.addonTreesFor('styles');\n  let external = this._processedExternalTree();\n  let styles = new Funnel(this.trees.styles, {\n    srcDir: '/',\n    destDir: '/app/styles',\n    annotation: 'Funnel (styles)',\n  });\n\n  let trees = [external].concat(addonTrees);\n  trees.push(styles);\n\n  let options = { outputPaths: this.options.outputPaths.app.css };\n  options.registry = this.registry;\n\n  let stylesAndVendor = this.addonPreprocessTree('css', mergeTrees(trees, {\n    annotation: 'TreeMerger (stylesAndVendor)',\n    overwrite: true,\n  }));\n\n  let preprocessedStyles = preprocessCss(stylesAndVendor, '/app/styles', '/assets', options);\n\n  if (this.vendorStaticStyles.length > 0) {\n    this.project.ui.writeDeprecateLine(`Usage of EmberApp.vendorStaticStyles is deprecated. Please use EmberApp.import instead for the following files: '${this.vendorStaticStyles.join('\\', \\'')}'`);\n    this.vendorStaticStyles.forEach(filename => {\n      this.import(filename);\n    });\n  }\n\n  this.import('vendor/addons.css');\n\n  let vendorStyles = [];\n  for (let outputFile in this._styleOutputFiles) {\n    let headerFiles = this._styleOutputFiles[outputFile];\n\n    vendorStyles.push(this._concatFiles(stylesAndVendor, {\n      headerFiles,\n      outputFile,\n      annotation: `Concat: Vendor Styles${outputFile}`,\n    }));\n  }\n\n  vendorStyles = this.addonPreprocessTree('css', mergeTrees(vendorStyles, {\n    annotation: 'TreeMerger (vendorStyles)',\n    overwrite: true,\n  }));\n\n  if (this.options.minifyCSS.enabled === true) {\n    options = this.options.minifyCSS.options || {};\n    options.registry = this.registry;\n    preprocessedStyles = preprocessMinifyCss(preprocessedStyles, options);\n    vendorStyles = preprocessMinifyCss(vendorStyles, options);\n  }\n\n  let mergedTrees = mergeTrees([\n    preprocessedStyles,\n    vendorStyles,\n  ], {\n    annotation: 'styles',\n  });\n\n  return this._cachedStylesTree = this.addonPostprocessTree('css', mergedTrees);\n};\n\n/**\n  Returns the tree for test files\n\n  @private\n  @method testFiles\n  @return {Tree} Merged tree for test files\n */\nEmberApp.prototype.testFiles = function(coreTestTree) {\n  let testSupportPath = this.options.outputPaths.testSupport.js;\n\n  testSupportPath = testSupportPath.testSupport || testSupportPath;\n\n  let external = this._processedExternalTree();\n  let emberCLITree = this._processedEmberCLITree();\n\n  let addonTestSupportTree = mergeTrees(this.addonTreesFor('addon-test-support'), {\n    overwrite: true,\n    annotation: 'TreeMerger (addon-test-support)',\n  });\n\n  let finalAddonTestSupportTree = new Funnel(addonTestSupportTree, {\n    allowEmpty: true,\n    destDir: 'addon-test-support',\n    annotation: 'Funnel: Addon Test Support',\n  });\n\n  let headerFiles = [].concat(\n    'vendor/ember-cli/test-support-prefix.js',\n    this.legacyTestFilesToAppend\n  );\n\n  let inputFiles = ['addon-test-support/**/*.js'];\n\n  let footerFiles = ['vendor/ember-cli/test-support-suffix.js'];\n\n  let baseMergedTree = mergeTrees([emberCLITree, external, coreTestTree, finalAddonTestSupportTree]);\n  let testJs = this._concatFiles(baseMergedTree, {\n    headerFiles,\n    inputFiles,\n    footerFiles,\n    outputFile: testSupportPath,\n    annotation: 'Concat: Test Support JS',\n    allowNone: true,\n  });\n\n  let testemPath = path.join(__dirname, 'testem');\n  testemPath = path.dirname(testemPath);\n\n  let testemTree = new Funnel(new UnwatchedDir(testemPath), {\n    files: ['testem.js'],\n    srcDir: '/',\n    destDir: '/',\n    annotation: 'Funnel (testem)',\n  });\n\n  if (this.options.fingerprint && this.options.fingerprint.exclude) {\n    this.options.fingerprint.exclude.push('testem');\n  }\n\n  let sourceTrees = [\n    testemTree,\n    testJs,\n  ];\n\n  let bowerDeps = this.project.bowerDependencies();\n  if (bowerDeps['ember-cli-test-loader']) {\n    this.project.ui.writeDeprecateLine('ember-cli-test-loader should now be included as an NPM module with version 1.1.0 or greater.');\n    let testLoaderPath = this.options.outputPaths.testSupport.js.testLoader;\n    let testLoader = new Funnel(external, {\n      files: ['test-loader.js'],\n      srcDir: `/${this.bowerDirectory}/ember-cli-test-loader`,\n      destDir: path.dirname(testLoaderPath),\n      annotation: 'Funnel (testLoader)',\n    });\n\n    sourceTrees.push(testLoader);\n  }\n\n  if (this.vendorTestStaticStyles.length > 0) {\n    sourceTrees.push(\n      this._concatFiles(external, {\n        headerFiles: this.vendorTestStaticStyles,\n        outputFile: this.options.outputPaths.testSupport.css,\n        annotation: 'Concat: Test Support CSS',\n      })\n    );\n  }\n\n  return mergeTrees(sourceTrees, {\n    overwrite: true,\n    annotation: 'TreeMerger (testFiles)',\n  });\n};\n\n/**\n  Returns the tree for the additional assets which are not in\n  one of the default trees.\n\n  @private\n  @method otherAssets\n  @return {Tree} Merged tree for other assets\n */\nEmberApp.prototype.otherAssets = function() {\n  let external = this._processedExternalTree();\n  // combine obviously shared funnels.\n  let otherAssetTrees = funnelReducer(this.otherAssetPaths).map(options => {\n    options.annotation = `Funnel\n  ${options.srcDir}\n  ${options.destDir}\n include:${options.include.length}`;\n\n    return new Funnel(external, options);\n  });\n\n  return mergeTrees(otherAssetTrees, {\n    annotation: 'TreeMerger (otherAssetTrees)',\n  });\n};\n\n/**\n  @public\n  @method dependencies\n  @return {Object} Alias to the project's dependencies function\n*/\nEmberApp.prototype.dependencies = function(pkg) {\n  return this.project.dependencies(pkg);\n};\n\n/**\n  Imports an asset into the application.\n\n  @public\n  @method import\n  @param {Object|String} asset Either a path to the asset or an object with environment names and paths as key-value pairs.\n  @param {Object} [options] Options object\n  @param {String} [options.type='vendor'] Either 'vendor' or 'test'\n  @param {Boolean} [options.prepend=false] Whether or not this asset should be prepended\n  @param {String} [options.destDir] Destination directory, defaults to the name of the directory the asset is in\n  @param {String} [options.outputFile] Specifies the output file for given import. Defaults to assets/vendor.{js,css}\n */\nEmberApp.prototype.import = function(asset, options) {\n  let assetPath = this._getAssetPath(asset);\n\n  if (!assetPath) {\n    return;\n  }\n\n  options = defaultsDeep(options || {}, {\n    type: 'vendor',\n    prepend: false,\n  });\n\n  let directory = path.dirname(assetPath);\n  let subdirectory = directory.replace(new RegExp(`^vendor/|${this.bowerDirectory}`), '');\n  let extension = path.extname(assetPath);\n\n  if (!extension) {\n    throw new Error('You must pass a file to `app.import`. For directories specify them to the constructor under the `trees` option.');\n  }\n\n  this._import(\n    assetPath,\n    options,\n    directory,\n    subdirectory,\n    extension\n  );\n};\n\n/**\n  @private\n  @method _import\n  @param {String} assetPath\n  @param {Object} options\n  @param {String} directory\n  @param {String} subdirectory\n  @param {String} extension\n */\nEmberApp.prototype._import = function(assetPath, options, directory, subdirectory, extension) {\n  // TODO: refactor, this has gotten very messy. Relevant tests: tests/unit/broccoli/ember-app-test.js\n  let basename = path.basename(assetPath);\n\n  if (isType(assetPath, 'js', { registry: this.registry })) {\n    if (options.using) {\n      let self = this;\n      options.using.forEach(entry => {\n        if (!entry.transformation) {\n          throw new Error(`while importing ${assetPath}: each entry in the \\`using\\` list must have a \\`transformation\\` name`);\n        }\n        if (entry.transformation !== 'amd') {\n          throw new Error(`while importing ${assetPath}: unknown transformation \\`${entry.transformation}\\``);\n        }\n        if (!entry.as) {\n          throw new Error(`while importing ${assetPath}: amd transformation requires an \\`as\\` argument that specifies the desired module name`);\n        }\n        if (!self.amdModuleNames) {\n          self.amdModuleNames = {};\n        }\n        // If the import is specified to be a different name we must break because of the broccoli rewrite behavior.\n        if (self.amdModuleNames[assetPath] && self.amdModuleNames[assetPath] !== entry.as) {\n          throw new Error(`Highlander error while importing ${assetPath}. You may not import an AMD transformed asset at different module names.`);\n        }\n        self.amdModuleNames[assetPath] = entry.as;\n      });\n    }\n\n    if (options.type === 'vendor') {\n      options.outputFile = options.outputFile || this.options.outputPaths.vendor.js;\n      addOutputFile('firstOneWins', this._scriptOutputFiles, assetPath, options);\n    } else if (options.type === 'test') {\n      if (!allowImport('firstOneWins', this.legacyTestFilesToAppend, assetPath, options)) { return; }\n      if (options.prepend) {\n        this.legacyTestFilesToAppend.unshift(assetPath);\n      } else {\n        this.legacyTestFilesToAppend.push(assetPath);\n      }\n    } else {\n      throw new Error(`You must pass either \\`vendor\\` or \\`test\\` for options.type in your call to \\`app.import\\` for file: ${basename}`);\n    }\n  } else if (extension === '.css') {\n    if (options.type === 'vendor') {\n      options.outputFile = options.outputFile || this.options.outputPaths.vendor.css;\n      addOutputFile('lastOneWins', this._styleOutputFiles, assetPath, options);\n    } else {\n      if (!allowImport('lastOneWins', this.vendorTestStaticStyles, assetPath, options)) { return; }\n      if (options.prepend) {\n        this.vendorTestStaticStyles.unshift(assetPath);\n      } else {\n        this.vendorTestStaticStyles.push(assetPath);\n      }\n    }\n  } else {\n    let destDir = options.destDir;\n    if (destDir === '') {\n      destDir = '/';\n    }\n    this.otherAssetPaths.push({\n      src: directory,\n      file: basename,\n      dest: destDir || subdirectory,\n    });\n  }\n};\n\n/**\n  @private\n  @method _getAssetPath\n  @param {(Object|String)} asset\n  @return {(String|undefined)} assetPath\n */\nEmberApp.prototype._getAssetPath = function(asset) {\n  /* @type {String} */\n  let assetPath;\n\n  if (typeof asset !== 'object') {\n    assetPath = asset;\n  } else if (this.env in asset) {\n    assetPath = asset[this.env];\n  } else {\n    assetPath = asset.development;\n  }\n\n  if (!assetPath) {\n    return;\n  }\n\n  assetPath = assetPath.split('\\\\').join('/');\n\n  if (assetPath.split('/').length < 2) {\n    console.log(chalk.red(`Using \\`app.import\\` with a file in the root of \\`vendor/\\` causes a significant performance penalty. Please move \\`${assetPath}\\` into a subdirectory.`));\n  }\n\n  if (/[\\*\\,]/.test(assetPath)) {\n    throw new Error(`You must pass a file path (without glob pattern) to \\`app.import\\`.  path was: \\`${assetPath}\\``);\n  }\n\n  return assetPath;\n};\n\n/**\n  Returns an array of trees for this application\n\n  @private\n  @method toArray\n  @return {Array} An array of trees\n */\nEmberApp.prototype.toArray = function() {\n  let sourceTrees = [\n    this.index(),\n    this.javascript(),\n    this.styles(),\n    this.otherAssets(),\n    this.publicTree(),\n  ];\n\n  if (this.tests && this.trees.tests) {\n    sourceTrees = sourceTrees.concat(this.testIndex(), this.test());\n  }\n\n  return sourceTrees;\n};\n\n/**\n  Returns the merged tree for this application\n\n  @public\n  @method toTree\n  @param  {Array} additionalTrees Array of additional trees to merge\n  @return {Tree}                  Merged tree for this application\n */\nEmberApp.prototype.toTree = function(additionalTrees) {\n  let tree = mergeTrees(this.toArray().concat(additionalTrees || []), {\n    overwrite: true,\n    annotation: 'TreeMerger (allTrees)',\n  });\n\n  return this.addonPostprocessTree('all', tree);\n};\n\n/**\n  Returns the content for a specific type (section) for index.html.\n\n  Currently supported types:\n  - 'head'\n  - 'config-module'\n  - 'head-footer'\n  - 'test-header-footer'\n  - 'body-footer'\n  - 'test-body-footer'\n\n  Addons can also implement this method and could also define additional\n  types (eg. 'some-addon-section').\n\n  @private\n  @method contentFor\n  @param  {Object} config Application configuration\n  @param  {RegExp} match  Regular expression to match against\n  @param  {String} type   Type of content\n  @return {String}        The content.\n */\nEmberApp.prototype.contentFor = function(config, match, type) {\n  let content = [];\n  let deprecatedHooks = ['app-prefix', 'app-suffix', 'vendor-prefix', 'vendor-suffix'];\n  let deprecate = this.project.ui.writeDeprecateLine.bind(this.project.ui);\n\n  // This normalizes `rootURL` to the value which we use everywhere inside of Ember CLI.\n  // This makes sure that the user doesn't have to account for it in application code.\n  if ('rootURL' in config) {\n    config.rootURL = calculateRootURL(config);\n  }\n\n  switch (type) {\n    case 'head': this._contentForHead(content, config); break;\n    case 'config-module': this._contentForConfigModule(content, config); break;\n    case 'app-boot': this._contentForAppBoot(content, config); break;\n    case 'test-body-footer': this._contentForTestBodyFooter(content); break;\n  }\n\n  content = this.project.addons.reduce((content, addon) => {\n    let addonContent = addon.contentFor ? addon.contentFor(type, config, content) : null;\n    if (addonContent) {\n      deprecate(`The \\`${type}\\` hook used in ${addon.name} is deprecated. The addon should generate a module and have consumers \\`require\\` it.`, deprecatedHooks.indexOf(type) === -1);\n      return content.concat(addonContent);\n    }\n\n    return content;\n  }, content);\n\n  return content.join('\\n');\n};\n\n/**\n  @private\n  @method _contentForTestBodyFooter\n  @param {Array} content\n*/\nEmberApp.prototype._contentForTestBodyFooter = function(content) {\n  content.push('<script>Ember.assert(\\'The tests file was not loaded. Make sure your tests index.html includes \"assets/tests.js\".\\', EmberENV.TESTS_FILE_LOADED);</script>');\n};\n\n/**\n  @private\n  @method _contentForHead\n  @param {Array} content\n  @param {Object} config\n*/\nEmberApp.prototype._contentForHead = function(content, config) {\n  content.push(calculateBaseTag(config));\n\n  if (this.options.storeConfigInMeta) {\n    content.push(`<meta name=\"${config.modulePrefix}/config/environment\" content=\"${escape(JSON.stringify(config))}\" />`);\n  }\n};\n\n/**\n  @private\n  @method _contentForConfigModule\n  @param {Array} content\n  @param {Object} config\n*/\nEmberApp.prototype._contentForConfigModule = function(content, config) {\n  if (this.options.storeConfigInMeta) {\n    content.push(`var prefix = '${config.modulePrefix}';`);\n    content.push(fs.readFileSync(path.join(__dirname, 'app-config-from-meta.js')));\n  } else {\n    content.push(`var exports = \\{'default': ${JSON.stringify(config)}};` +\n      `Object.defineProperty(exports, '__esModule', \\{value: true});` +\n      `return exports;`);\n  }\n};\n\n/**\n  @private\n  @method _contentForAppBoot\n  @param {Array} content\n  @param {Object} config\n*/\nEmberApp.prototype._contentForAppBoot = function(content, config) {\n  if (this.options.autoRun) {\n    content.push('if (!runningTests) {');\n    content.push(`  require(\"${config.modulePrefix}/app\")[\"default\"].create(${calculateAppConfig(config)});`);\n    content.push('}');\n  }\n};\n\n/*\n  Returns the <base> tag for index.html\n\n  @param  {Object} config Application configuration\n  @return {String}        Base tag or empty string\n */\nfunction calculateBaseTag(config) {\n  let baseURL = cleanBaseURL(config.baseURL);\n  let locationType = config.locationType;\n\n  if (locationType === 'hash') {\n    return '';\n  }\n\n  if (baseURL) {\n    return `<base href=\"${baseURL}\" />`;\n  } else {\n    return '';\n  }\n}\n\nfunction calculateRootURL(config) {\n  if (config.rootURL === '') {\n    return config.rootURL;\n  }\n\n  return cleanBaseURL(config.rootURL) || '';\n}\n\nfunction calculateEmberENV(config) {\n  return JSON.stringify(config.EmberENV || {});\n}\n\nfunction calculateAppConfig(config) {\n  return JSON.stringify(config.APP || {});\n}\n\nfunction calculateModulePrefix(config) {\n  return config.modulePrefix;\n}\n\nfunction addOutputFile(strategy, container, assetPath, options) {\n  let outputFile = options.outputFile;\n\n  if (!outputFile) {\n    throw new Error('outputFile is not specified');\n  }\n\n  if (!container[outputFile]) {\n    container[outputFile] = [];\n  }\n  if (!allowImport(strategy, container[outputFile], assetPath, options)) { return; }\n\n  if (options.prepend) {\n    container[outputFile].unshift(assetPath);\n  } else {\n    container[outputFile].push(assetPath);\n  }\n}\n\n// In this strategy the last instance of the asset in the array is the one which will be used.\n// This applies to CSS where the last asset always \"wins\" no matter what.\nfunction _lastOneWins(fileList, assetPath, options) {\n  let assetIndex = fileList.indexOf(assetPath);\n\n  // Doesn't exist in the current fileList. Safe to remove.\n  if (assetIndex === -1) { return true; }\n\n  logger.info(`Highlander Rule: duplicate \\`app.import(${assetPath})\\`. Only including the last by order.`);\n\n  if (options.prepend) {\n    // The existing asset is _already after_ this inclusion and would win.\n    // Therefore this branch is a no-op.\n    return false;\n  } else {\n    // The existing asset is _before_ this inclusion and needs to be removed.\n    fileList.splice(fileList.indexOf(assetPath), 1);\n    return true;\n  }\n}\n\n// In JS the asset which would be first will win.\n// If it is something which includes globals we want those defined as early as\n// possible. Any initialization would likely be repeated. Any mutation of global\n// state that occurs on initialization is likely _fixed_.\n// Any module definitions will be identical except in the scenario where they'red\n// reified to reassignment. This is likely fine.\nfunction _firstOneWins(fileList, assetPath, options) {\n  let assetIndex = fileList.indexOf(assetPath);\n\n  // Doesn't exist in the current fileList. Safe to remove.\n  if (assetIndex === -1) { return true; }\n\n  logger.info(`Highlander Rule: duplicate \\`app.import(${assetPath})\\`. Only including the first by order.`);\n\n  if (options.prepend) {\n    // The existing asset is _after_ this inclusion and needs to be removed.\n    fileList.splice(fileList.indexOf(assetPath), 1);\n    return true;\n  } else {\n    // The existing asset is _already before_ this inclusion and would win.\n    // Therefore this branch is a no-op.\n    return false;\n  }\n}\n\nfunction allowImport(strategy, fileList, assetPath, options) {\n  if (strategy === 'firstOneWins') {\n    // We must find all occurrences and decide what to do with each.\n    return _firstOneWins.call(undefined, fileList, assetPath, options);\n  } else if (strategy === 'lastOneWins') {\n    // We can simply use the \"last one wins\" strategy.\n    return _lastOneWins.call(undefined, fileList, assetPath, options);\n  } else {\n    return true;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/preprocessors.js":"'use strict';\n\nvar path     = require('path');\nvar Registry = require('./');\nvar relativeRequire = require('process-relative-require');\nvar debug = require('debug')('ember-cli:preprocessors');\n\n/**\n  Invokes the `setupRegistryForEachAddon('parent', registry)` hook for each of the parent objects addons.\n\n  @private\n  @method setupRegistryForEachAddon\n  @param {Registry} registry the registry being setup\n  @param {Addon|EmberApp} parent the parent object of the registry being setup. Will be an addon for nested\n    addons, or the `EmberApp` for addons in the project directly.\n*/\nfunction setupRegistryForEachAddon(registry, parent) {\n  parent.initializeAddons();\n  var addons = parent.addons || (parent.project && parent.project.addons);\n\n  if (!addons) {\n    return;\n  }\n\n  addons.forEach(function(addon) {\n    if (addon.setupPreprocessorRegistry) {\n      addon.setupPreprocessorRegistry('parent', registry);\n    }\n  });\n}\n\n/**\n  Invokes the `setupPreprocessorRegistry` hook for a given addon. The `setupPreprocessorRegistry` will be\n  invoked first on the addon itself (with the first argument of `'self'`), and then on each nested addon\n  (with the first argument of `'parent'`).\n\n  @private\n  @method setupRegistry\n  @param {Addon|EmberApp}\n*/\nmodule.exports.setupRegistry = function(appOrAddon) {\n  var registry = appOrAddon.registry;\n  if (appOrAddon.setupPreprocessorRegistry) {\n    appOrAddon.setupPreprocessorRegistry('self', registry);\n  }\n  setupRegistryForEachAddon(registry, appOrAddon);\n\n  addLegacyPreprocessors(registry);\n};\n\n/**\n  Creates a Registry instance, and prepopulates it with a few static default\n  preprocessors.\n\n  @private\n  @method defaultRegistry\n  @param app\n*/\nmodule.exports.defaultRegistry = function(app) {\n  var registry = new Registry(app.dependencies(), app);\n\n  return registry;\n};\n\n/**\n  Add old / grandfathered preprocessor that is not an ember-cli addon.\n\n  These entries should be removed, once they have good addon replacements.\n  @private\n  @method addLegacyPreprocessors\n  @param registry\n*/\nfunction addLegacyPreprocessors(registry) {\n  registry.add('minify-css', 'broccoli-csso', null);\n\n  registry.add('template', 'broccoli-emblem-compiler', ['embl', 'emblem']);\n  registry.add('template', 'broccoli-ember-hbs-template-compiler', ['hbs', 'handlebars']);\n}\n\n/**\n  Returns true if the given path would be considered of a specific type.\n\n  For example:\n\n  ```\n  isType('somefile.js', 'js', addon); // => true\n  isType('somefile.css', 'css', addon); // => true\n  isType('somefile.blah', 'css', addon); // => false\n  isType('somefile.sass', 'css', addon); // => true if a sass preprocessor is available\n  ```\n  @private\n  @method isType\n  @param {String} file the path to check\n  @param {String} type the type to compare with\n  @param {Object} registryOwner the object whose registry we should search\n*/\nmodule.exports.isType = function(file, type, registryOwner) {\n  var extension = path.extname(file).replace('.', '');\n\n  if (extension === type) { return true; }\n\n  if (registryOwner.registry.extensionsForType(type).indexOf(extension) > -1) {\n    return true;\n  }\n};\n\nmodule.exports.preprocessMinifyCss = function(tree, options) {\n  var plugins = options.registry.load('minify-css');\n\n  if (plugins.length === 0) {\n    var compiler = require('broccoli-clean-css');\n    return compiler(tree, options);\n  } else if (plugins.length > 1) {\n    throw new Error('You cannot use more than one minify-css plugin at once.');\n  }\n\n  var plugin = plugins[0];\n\n  return relativeRequire(plugin.name).call(null, tree, options);\n};\n\nmodule.exports.preprocessCss = function(tree, inputPath, outputPath, options) {\n  var plugins = options.registry.load('css');\n\n  if (plugins.length === 0) {\n    var Funnel = require('broccoli-funnel');\n\n    return new Funnel(tree, {\n      srcDir: inputPath,\n\n      getDestinationPath: function(relativePath) {\n        if (options.outputPaths) {\n          // options.outputPaths is not present when compiling\n          // an addon's styles\n          var path = relativePath.replace(/\\.css$/, '');\n\n          // is a rename rule present?\n          if (options.outputPaths[path]) {\n            return options.outputPaths[path];\n          }\n        }\n\n        return outputPath + '/' + relativePath;\n      }\n    });\n  }\n\n  return processPlugins(plugins, arguments);\n};\n\nmodule.exports.preprocessTemplates = function(/* tree */) {\n  var options = arguments[arguments.length - 1];\n  var plugins = options.registry.load('template');\n\n  debug('plugins found for templates: %s', plugins.map(function(p) { return p.name; }));\n\n  if (plugins.length === 0) {\n    throw new Error('Missing template processor');\n  }\n\n  return processPlugins(plugins, arguments);\n};\n\nmodule.exports.preprocessJs = function(/* tree, inputPath, outputPath, options */) {\n  var options = arguments[arguments.length - 1];\n  var plugins = options.registry.load('js');\n  var tree    = arguments[0];\n\n  if (plugins.length === 0) { return tree; }\n\n  return processPlugins(plugins, arguments);\n};\n\nfunction processPlugins(plugins, args) {\n  args = Array.prototype.slice.call(args);\n  var tree = args.shift();\n\n  plugins.forEach(function(plugin) {\n    debug('processing %s', plugin.name);\n    tree = plugin.toTree.apply(plugin, [tree].concat(args));\n  });\n\n  return tree;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/index.js":"'use strict';\n\nvar Plugin           = require('./lib/plugin');\nvar TemplatePlugin   = require('./lib/template-plugin');\nvar JavascriptPlugin = require('./lib/javascript-plugin');\nvar debug            = require('debug')('ember-cli:registry');\n\nfunction Registry(plugins, app) {\n  this.registry = {\n    js: [],\n    css: [],\n    'minify-css': [],\n    template: []\n  };\n\n  this.instantiatedPlugins = [];\n  this.availablePlugins = plugins;\n  this.app = app;\n  this.pluginTypes = {\n    'js': JavascriptPlugin,\n    'template': TemplatePlugin\n  };\n}\n\nmodule.exports = Registry;\n\nRegistry.prototype.extensionsForType = function(type) {\n  var registered = this.registeredForType(type);\n\n  var extensions =  registered.reduce(function(memo, plugin) {\n    return memo.concat(plugin.ext);\n  }, [type]).filter(Boolean);\n\n  extensions = require('ember-cli-lodash-subset').uniq(extensions);\n\n  debug('extensions for type %s: %s', type, extensions);\n\n  return extensions;\n};\n\nRegistry.prototype.load = function(type) {\n  var knownPlugins = this.registeredForType(type);\n  var plugins = knownPlugins.map(function(plugin) {\n    if(this.instantiatedPlugins.indexOf(plugin) > -1 || this.availablePlugins.hasOwnProperty(plugin.name)) {\n      return plugin;\n    }\n  }.bind(this))\n  .filter(Boolean);\n\n  debug('loading %s: available plugins %s; found plugins %s;', type, knownPlugins.map(function(p) { return p.name; }), plugins.map(function(p) { return p.name; }));\n\n  return plugins;\n};\n\nRegistry.prototype.registeredForType = function(type) {\n  return this.registry[type] = this.registry[type] || [];\n};\n\nRegistry.prototype.add = function(type, name, extension, options) {\n  var registered = this.registeredForType(type);\n  var plugin, PluginType;\n\n  // plugin is being added directly do not instantiate it\n  if (typeof name === 'object') {\n    plugin = name;\n    this.instantiatedPlugins.push(plugin);\n  } else {\n    PluginType = this.pluginTypes[type] || Plugin;\n    options = options || {};\n    options.applicationName = this.app.name;\n    options.app = this.app;\n\n    plugin = new PluginType(name, extension, options);\n  }\n\n  debug('add type: %s, name: %s, extension:%s, options:%s', type, plugin.name, plugin.ext, options);\n\n  registered.push(plugin);\n};\n\nRegistry.prototype.remove = function(type /* name */) {\n  var registered = this.registeredForType(type);\n  var registeredIndex, name;\n\n  if (typeof arguments[1] === 'object') {\n    name = arguments[1].name;\n  } else {\n    name = arguments[1];\n  }\n\n  debug('remove type: %s, name: %s', type, name);\n\n  for (var i = 0, l = registered.length; i < l; i++) {\n    if (registered[i].name === name) {\n      registeredIndex = i;\n    }\n  }\n\n  var plugin = registered[registeredIndex];\n  var instantiatedPluginIndex = this.instantiatedPlugins.indexOf(plugin);\n\n  if (instantiatedPluginIndex > -1) {\n    this.instantiatedPlugins.splice(instantiatedPluginIndex, 1);\n  }\n\n  if (registeredIndex !== undefined && registeredIndex > -1) {\n    registered.splice(registeredIndex, 1);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/lib/plugin.js":"'use strict';\n\nvar path       = require('path');\nvar existsSync = require('exists-sync');\n\nfunction Plugin(name, ext, options) {\n  this.name = name;\n  this.ext = ext;\n  this.options = options || {};\n  this.registry = this.options.registry;\n  this.applicationName = this.options.applicationName;\n\n  if (this.options.toTree) {\n    this.toTree = this.options.toTree;\n  }\n}\n\nPlugin.prototype.toTree = function() {\n  throw new Error('A Plugin must implement the `toTree` method.');\n};\n\nPlugin.prototype.getExt = function(inputTreeRoot, inputPath, filename) {\n  if(Array.isArray(this.ext)) {\n    var detect = require('ember-cli-lodash-subset').find;\n    return detect(this.ext, function(ext) {\n      var filenameAndExt = filename + '.' + ext;\n      return existsSync(path.join(inputTreeRoot, inputPath, filenameAndExt));\n    });\n  } else {\n    return this.ext;\n  }\n};\n\nmodule.exports = Plugin;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/node_modules/exists-sync/index.js":"'use strict';\nvar path         = require('path');\nvar root         = process.cwd();\nvar accessSync   = require('fs').accessSync;\nvar lstatSync    = require('fs').lstatSync;\nvar readlinkSync = require('fs').readlinkSync;\n\nfunction existsSync(filepath, parent){\n  var depth, link, linkError, linkRoot, relativeLink, resolvedLink, stats;\n  var resolvedPath = path.resolve(filepath);\n  try {\n    stats = lstatSync(resolvedPath);\n    // if symlink, check if target\n    if (stats && stats.isSymbolicLink()) {\n      link         = readlinkSync(resolvedPath);\n      linkRoot     = path.dirname(resolvedPath);\n      \n      if (link && link.indexOf('..') !== -1) {\n        // resolve relative path\n        depth = pathDepth(link);\n        relativeLink = path.relative(path.resolve(linkRoot, depth), path.basename(link));\n        resolvedLink = path.resolve(linkRoot, relativeLink);\n        \n      } else {\n        // assume root and resolve\n        resolvedLink = path.resolve(root, link);\n      }\n      \n      try {\n        accessSync(path.dirname(resolvedLink));\n        \n      } catch (err) {\n        if (err.code === \"ENOENT\") {\n          // Log message for user so they can investigate\n          console.log(err.message);\n          console.log('Please verify that the symlink for ' + resolvedPath + ' can be resolved from ' + root + '.');\n        }\n      }\n      \n      if (parent && parent === resolvedLink) {\n        linkError = new Error('Circular symlink detected: ' + resolvedPath + ' -> ' + resolvedLink);\n        throw linkError;\n      }\n      return existsSync(resolvedLink, resolvedPath);\n      \n    }\n    return true;\n    \n  } catch (err) {\n    if (err.message.match(/Circular symlink detected/)) {\n      throw err;\n    }\n    \n    return checkError(err);\n  }\n}\n\nfunction checkError(err) {\n  return err && err.code === \"ENOENT\" ? false : true;\n}\n\nfunction pathDepth(filepath) {\n  return new Array(filepath.split(path.sep).length).join('..' + path.sep);\n}\n\nmodule.exports = existsSync;","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/lib/template-plugin.js":"'use strict';\n\nvar Plugin = require('./plugin');\nvar relativeRequire = require('process-relative-require');\n\nfunction TemplatePlugin () {\n  this.type = 'template';\n  this._superConstructor.apply(this, arguments);\n}\n\nTemplatePlugin.prototype = Object.create(Plugin.prototype);\nTemplatePlugin.prototype.constructor = TemplatePlugin;\nTemplatePlugin.prototype._superConstructor = Plugin;\n\nTemplatePlugin.prototype.toTree = function(tree) {\n  return relativeRequire(this.name).call(null, tree, {\n    extensions: this.ext,\n    module: true\n  });\n};\n\n\nmodule.exports = TemplatePlugin;\n\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-preprocess-registry/lib/javascript-plugin.js":"'use strict';\n\nvar Plugin = require('./plugin');\nvar relativeRequire = require('process-relative-require');\n\nfunction JavascriptPlugin () {\n  this.type = 'js';\n  this._superConstructor.apply(this, arguments);\n}\n\nJavascriptPlugin.prototype = Object.create(Plugin.prototype);\nJavascriptPlugin.prototype.constructor = JavascriptPlugin;\nJavascriptPlugin.prototype._superConstructor = Plugin;\n\nJavascriptPlugin.prototype.toTree = function(tree, inputPath, outputPath, options) {\n  if (this.name.indexOf('ember-script') !== -1) {\n    options = options || {};\n    options.bare = true;\n    options.srcDir = inputPath;\n    options.destDir = outputPath;\n  }\n\n  return relativeRequire(this.name).call(null, tree, options);\n};\n\nmodule.exports = JavascriptPlugin;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/project.js":"'use strict';\n\n/**\n@module ember-cli\n*/\nconst RSVP = require('rsvp');\nconst path = require('path');\nconst findup = require('find-up');\nlet resolve = RSVP.denodeify(require('resolve'));\nconst fs = require('fs-extra');\nconst existsSync = require('exists-sync');\nconst _ = require('ember-cli-lodash-subset');\nlet logger = require('heimdalljs-logger')('ember-cli:project');\nconst nodeModulesPath = require('node-modules-path');\nconst versionUtils = require('../utilities/version-utils');\nlet emberCLIVersion = versionUtils.emberCLIVersion;\nconst findAddonByName = require('../utilities/find-addon-by-name');\nconst Instrumentation = require('./instrumentation');\nconst heimdall = require('heimdalljs');\n\nlet processCwd = process.cwd();\n// ensure NULL_PROJECT is a singleton\nlet NULL_PROJECT;\n\nclass Project {\n  /**\n    The Project model is tied to your package.json. It is instantiated\n    by giving {{#crossLink \"Project/closestSync:method\"}}{{/crossLink}}\n    the path to your project.\n\n    @class Project\n    @constructor\n    @param {String} root Root directory for the project\n    @param {Object} pkg  Contents of package.json\n    @param {UI} ui\n    @param {CLI} cli\n  */\n  constructor(root, pkg, ui, cli) {\n    const AddonDiscovery = require('../models/addon-discovery');\n    const AddonsFactory = require('../models/addons-factory');\n\n    logger.info('init root: %s', root);\n\n    this.root = root;\n    this.pkg = pkg;\n    this.ui = ui;\n    this.cli = cli;\n    this.addonPackages = {};\n    this.addons = [];\n    this.liveReloadFilterPatterns = [];\n    this.setupBowerDirectory();\n    this.setupNodeModulesPath();\n    this.addonDiscovery = new AddonDiscovery(this.ui);\n    this.addonsFactory = new AddonsFactory(this, this);\n\n    /**\n      Set when the `Watcher.detectWatchman` helper method finishes running,\n      so that other areas of the system can be aware that watchman is being used.\n\n      For example, this information is used in the broccoli build pipeline to know\n      if we can watch additional directories (like bower_components) \"cheaply\".\n\n      Contains `enabled` and `version`.\n\n      @private\n      @property _watchmanInfo\n      @return {Object}\n      @default false\n    */\n    this._watchmanInfo = {\n      enabled: false,\n      version: null,\n      canNestRoots: false,\n    };\n\n    let instrumentation = this._instrumentation = ensureInstrumentation(cli, ui);\n    instrumentation.project = this;\n\n    this.emberCLIVersion = emberCLIVersion;\n  }\n\n  /**\n    Sets the name of the bower directory for this project\n\n    @private\n    @method setupBowerDirectory\n   */\n  setupBowerDirectory() {\n    let bowerrcPath = path.join(this.root, '.bowerrc');\n\n    logger.info('bowerrc path: %s', bowerrcPath);\n\n    if (existsSync(bowerrcPath)) {\n      try {\n        this.bowerDirectory = fs.readJsonSync(bowerrcPath).directory;\n      } catch (exception) {\n        logger.info('failed to parse bowerc: %s', exception);\n        this.bowerDirectory = null;\n      }\n    }\n\n    this.bowerDirectory = this.bowerDirectory || 'bower_components';\n    logger.info('bowerDirectory: %s', this.bowerDirectory);\n  }\n\n  hasDependencies() {\n    return !!this.nodeModulesPath;\n  }\n\n  /**\n    Sets the path to the node_modules directory for this\n    project.\n\n    @private\n    @method setupNodeModulesPath\n   */\n  setupNodeModulesPath() {\n    this.nodeModulesPath = nodeModulesPath(this.root);\n\n    logger.info('nodeModulesPath: %s', this.nodeModulesPath);\n  }\n\n  static nullProject(ui, cli) {\n    if (NULL_PROJECT) { return NULL_PROJECT; }\n\n    NULL_PROJECT = new Project(processCwd, {}, ui, cli);\n\n    NULL_PROJECT.isEmberCLIProject = function() {\n      return false;\n    };\n\n    NULL_PROJECT.isEmberCLIAddon = function() {\n      return false;\n    };\n\n    NULL_PROJECT.name = function() {\n      return path.basename(process.cwd());\n    };\n\n    NULL_PROJECT.initializeAddons();\n\n    return NULL_PROJECT;\n  }\n\n  /**\n    Returns the name from package.json.\n\n    @private\n    @method name\n    @return {String} Package name\n   */\n  name() {\n    const getPackageBaseName = require('../utilities/get-package-base-name');\n\n    return getPackageBaseName(this.pkg.name);\n  }\n\n  /**\n    Returns whether or not this is an Ember CLI project.\n    This checks whether ember-cli is listed in devDependencies.\n\n    @private\n    @method isEmberCLIProject\n    @return {Boolean} Whether this is an Ember CLI project\n   */\n  isEmberCLIProject() {\n    return (this.cli ? this.cli.npmPackage : 'ember-cli') in this.dependencies();\n  }\n\n  /**\n    Returns whether or not this is an Ember CLI addon.\n\n    @method isEmberCLIAddon\n    @return {Boolean} Whether or not this is an Ember CLI Addon.\n   */\n  isEmberCLIAddon() {\n    return !!this.pkg.keywords && this.pkg.keywords.indexOf('ember-addon') > -1;\n  }\n\n  /**\n    Returns the path to the configuration.\n\n    @private\n    @method configPath\n    @return {String} Configuration path\n   */\n  configPath() {\n    let configPath = 'config';\n\n    if (this.pkg['ember-addon'] && this.pkg['ember-addon']['configPath']) {\n      configPath = this.pkg['ember-addon']['configPath'];\n    }\n\n    return path.join(this.root, configPath, 'environment');\n  }\n\n  /**\n    Loads the configuration for this project and its addons.\n\n    @public\n    @method config\n    @param  {String} env Environment name\n    @return {Object}     Merged confiration object\n   */\n  config(env) {\n    let configPath = this.configPath();\n\n    if (existsSync(`${configPath}.js`)) {\n      let appConfig = this.require(configPath)(env);\n      let addonsConfig = this.getAddonsConfig(env, appConfig);\n\n      return _.merge(addonsConfig, appConfig);\n    } else {\n      return this.getAddonsConfig(env, {});\n    }\n  }\n\n  /**\n    Returns the addons configuration.\n\n    @private\n    @method getAddonsConfig\n    @param  {String} env       Environment name\n    @param  {Object} appConfig Application configuration\n    @return {Object}           Merged configuration of all addons\n   */\n  getAddonsConfig(env, appConfig) {\n    this.initializeAddons();\n\n    let initialConfig = _.merge({}, appConfig);\n\n    return this.addons.reduce((config, addon) => {\n      if (addon.config) {\n        _.merge(config, addon.config(env, config));\n      }\n\n      return config;\n    }, initialConfig);\n  }\n\n  /**\n    Returns whether or not the given file name is present in this project.\n\n    @private\n    @method has\n    @param  {String}  file File name\n    @return {Boolean}      Whether or not the file is present\n   */\n  has(file) {\n    return existsSync(path.join(this.root, file)) || existsSync(path.join(this.root, `${file}.js`));\n  }\n\n  /**\n    Resolves the absolute path to a file.\n\n    @private\n    @method resolve\n    @param  {String} file File to resolve\n    @return {String}      Absolute path to file\n   */\n  resolve(file) {\n    return resolve(file, {\n      basedir: this.root,\n    });\n  }\n\n  /**\n    Resolves the absolute path to a file synchronously\n\n    @private\n    @method resolveSync\n    @param  {String} file File to resolve\n    @return {String}      Absolute path to file\n   */\n  resolveSync(file) {\n    return resolve.sync(file, {\n      basedir: this.root,\n    });\n  }\n\n  /**\n    Calls `require` on a given module.\n\n    @private\n    @method require\n    @param  {String} file File path or module name\n    @return {Object}      Imported module\n   */\n  require(file) {\n    if (/^\\.\\//.test(file)) { // Starts with ./\n      return require(path.join(this.root, file));\n    } else if (file.slice(0, this.root.length) === this.root) { // Starts with this.root\n      return require(file);\n    } else {\n      return require(path.join(this.nodeModulesPath, file));\n    }\n  }\n\n  /**\n    Returns the dependencies from a package.json\n\n    @private\n    @method dependencies\n    @param  {Object} [pkg=this.pkg] Package object\n    @param  {Boolean} [excludeDevDeps=false] Whether or not development dependencies should be excluded\n    @return {Object} Dependencies\n   */\n  dependencies(pkg, excludeDevDeps) {\n    pkg = pkg || this.pkg || {};\n\n    let devDependencies = pkg['devDependencies'];\n    if (excludeDevDeps) {\n      devDependencies = {};\n    }\n\n    return _.assign({}, devDependencies, pkg['dependencies']);\n  }\n\n  /**\n    Returns the bower dependencies for this project.\n\n    @private\n    @method bowerDependencies\n    @param  {String} bower Path to bower.json\n    @return {Object}       Bower dependencies\n   */\n  bowerDependencies(bower) {\n    if (!bower) {\n      let bowerPath = path.join(this.root, 'bower.json');\n      bower = (existsSync(bowerPath)) ? require(bowerPath) : {};\n    }\n    return _.assign({}, bower['devDependencies'], bower['dependencies']);\n  }\n\n  /**\n    Provides the list of paths to consult for addons that may be provided\n    internally to this project. Used for middleware addons with built-in support.\n\n    @private\n    @method supportedInternalAddonPaths\n  */\n  supportedInternalAddonPaths() {\n    if (!this.root) { return []; }\n\n    let internalMiddlewarePath = path.join(__dirname, '../tasks/server/middleware');\n    let legacyBlueprintsPath = require.resolve('ember-cli-legacy-blueprints');\n    let emberTryPath = require.resolve('ember-try');\n    return [\n      path.join(internalMiddlewarePath, 'testem-url-rewriter'),\n      path.join(internalMiddlewarePath, 'tests-server'),\n      path.join(internalMiddlewarePath, 'history-support'),\n      path.join(internalMiddlewarePath, 'broccoli-watcher'),\n      path.join(internalMiddlewarePath, 'broccoli-serve-files'),\n      path.join(internalMiddlewarePath, 'proxy-server'),\n      path.dirname(legacyBlueprintsPath),\n      path.dirname(emberTryPath),\n    ];\n  }\n\n  /**\n    Discovers all addons for this project and stores their names and\n    package.json contents in this.addonPackages as key-value pairs\n\n    @private\n    @method discoverAddons\n   */\n  discoverAddons() {\n    let addonsList = this.addonDiscovery.discoverProjectAddons(this);\n\n    this.addonPackages = this.addonDiscovery.addonPackages(addonsList);\n  }\n\n  /**\n    Loads and initializes all addons for this project.\n\n    @private\n    @method initializeAddons\n   */\n  initializeAddons() {\n    if (this._addonsInitialized) {\n      return;\n    }\n    this._addonsInitialized = true;\n\n    logger.info('initializeAddons for: %s', this.name());\n\n    this.discoverAddons();\n\n    this.addons = this.addonsFactory.initializeAddons(this.addonPackages);\n\n    this.addons.forEach(addon => {\n      logger.info('addon: %s', addon.name);\n    });\n  }\n\n  /**\n    Returns what commands are made available by addons by inspecting\n    `includedCommands` for every addon.\n\n    @private\n    @method addonCommands\n    @return {Object} Addon names and command maps as key-value pairs\n   */\n  addonCommands() {\n    const Command = require('../models/command');\n    let commands = {};\n    this.addons.forEach(addon => {\n      if (!addon.includedCommands) { return; }\n\n      let token = heimdall.start({\n        name: `lookup-commands: ${addon.name}`,\n        addonName: addon.name,\n        addonCommandInitialization: true,\n      });\n\n      let includedCommands = addon.includedCommands();\n      let addonCommands = {};\n\n      for (let key in includedCommands) {\n        if (typeof includedCommands[key] === 'function') {\n          addonCommands[key] = includedCommands[key];\n        } else {\n          addonCommands[key] = Command.extend(includedCommands[key]);\n        }\n      }\n      if (Object.keys(addonCommands).length) {\n        commands[addon.name] = addonCommands;\n      }\n\n      token.stop();\n    });\n    return commands;\n  }\n\n  /**\n    Execute a given callback for every addon command.\n    Example:\n\n    ```\n    project.eachAddonCommand(function(addonName, commands) {\n      console.log('Addon ' + addonName + ' exported the following commands:' + commands.keys().join(', '));\n    });\n    ```\n\n    @private\n    @method eachAddonCommand\n    @param  {Function} callback [description]\n   */\n  eachAddonCommand(callback) {\n    if (this.initializeAddons && this.addonCommands) {\n      this.initializeAddons();\n      let addonCommands = this.addonCommands();\n\n      _.forOwn(addonCommands, (commands, addonName) => callback(addonName, commands));\n    }\n  }\n\n  /**\n    Path to the blueprints for this project.\n\n    @private\n    @method localBlueprintLookupPath\n    @return {String} Path to blueprints\n   */\n  localBlueprintLookupPath() {\n    return path.join(this.root, 'blueprints');\n  }\n\n  /**\n    Returns a list of paths (including addon paths) where blueprints will be looked up.\n\n    @private\n    @method blueprintLookupPaths\n    @return {Array} List of paths\n   */\n  blueprintLookupPaths() {\n    if (this.isEmberCLIProject()) {\n      let lookupPaths = [this.localBlueprintLookupPath()];\n      let addonLookupPaths = this.addonBlueprintLookupPaths();\n\n      return lookupPaths.concat(addonLookupPaths);\n    } else {\n      return this.addonBlueprintLookupPaths();\n    }\n  }\n\n  /**\n    Returns a list of addon paths where blueprints will be looked up.\n\n    @private\n    @method addonBlueprintLookupPaths\n    @return {Array} List of paths\n   */\n  addonBlueprintLookupPaths() {\n    let addonPaths = this.addons.map(addon => {\n      if (addon.blueprintsPath) {\n        return addon.blueprintsPath();\n      }\n    }, this);\n\n    return addonPaths.filter(Boolean).reverse();\n  }\n\n  /**\n    Reloads package.json\n\n    @private\n    @method reloadPkg\n    @return {Object} Package content\n   */\n  reloadPkg() {\n    let pkgPath = path.join(this.root, 'package.json');\n\n    // We use readFileSync instead of require to avoid the require cache.\n    this.pkg = fs.readJsonSync(pkgPath);\n\n    return this.pkg;\n  }\n\n  /**\n    Re-initializes addons.\n\n    @private\n    @method reloadAddons\n   */\n  reloadAddons() {\n    this.reloadPkg();\n    this._addonsInitialized = false;\n    return this.initializeAddons();\n  }\n\n  /**\n    Find an addon by its name\n\n    @private\n    @method findAddonByName\n    @param  {String} name Addon name as specified in package.json\n    @return {Addon}       Addon instance\n   */\n  findAddonByName(name) {\n    this.initializeAddons();\n\n    return findAddonByName(this.addons, name);\n  }\n\n  /**\n    Generate test file contents.\n\n    This method is supposed to be overwritten by test framework addons\n    like `ember-cli-qunit` and `ember-cli-mocha`.\n\n    @public\n    @method generateTestFile\n    @param {String} moduleName Name of the test module (e.g. `JSHint`)\n    @param {Object[]} tests Array of tests with `name`, `passed` and `errorMessage` properties\n    @return {String} The test file content\n   */\n  generateTestFile() {\n    let message = 'Please install an Ember.js test framework addon or update your dependencies.';\n\n    if (this.ui) {\n      this.ui.writeDeprecateLine(message);\n    } else {\n      console.warn(message);\n    }\n\n    return '';\n  }\n\n  /**\n    Returns a new project based on the first package.json that is found\n    in `pathName`.\n\n    @deprecated\n    @private\n    @static\n    @method closest\n    @param  {String} pathName Path to your project\n    @return {Promise}         Promise which resolves to a {Project}\n   */\n  static closest(pathName, _ui, _cli) {\n    let ui = ensureUI(_ui);\n\n    ui.writeDeprecateLine('`Project.closest` is a private method that will be removed, please use `Project.closestSync` instead.');\n\n    return closestPackageJSON(pathName).then(result => {\n      logger.info('closest %s -> %s', pathName, result);\n      if (result.pkg && result.pkg.name === 'ember-cli') {\n        return Project.nullProject(_ui, _cli);\n      }\n\n      return new Project(result.directory, result.pkg, ui, _cli);\n    });\n  }\n\n  /**\n    Returns a new project based on the first package.json that is found\n    in `pathName`.\n\n    @private\n    @static\n    @method closestSync\n    @param  {String} pathName Path to your project\n    @param  {UI} _ui The UI instance to provide to the created Project.\n    @return {Project}         Project instance\n   */\n  static closestSync(pathName, _ui, _cli) {\n    logger.info('looking for package.json starting at %s', pathName);\n\n    let ui = ensureUI(_ui);\n\n    let directory = findupPath(pathName);\n    logger.info('found package.json at %s', directory);\n\n    let relative = path.relative(directory, pathName);\n    if (relative.indexOf('tmp') === 0) {\n      logger.info('ignoring parent project since we are in the tmp folder of the project');\n      return Project.nullProject(_ui, _cli);\n    }\n\n    let pkg = fs.readJsonSync(path.join(directory, 'package.json'));\n    logger.info('project name: %s', pkg && pkg.name);\n\n    if (!isEmberCliProject(pkg)) {\n      logger.info('ignoring parent project since it is not an ember-cli project');\n      return Project.nullProject(_ui, _cli);\n    }\n\n    return new Project(directory, pkg, ui, _cli);\n  }\n\n  /**\n    Returns a new project based on the first package.json that is found\n    in `pathName`, or the nullProject.\n\n    The nullProject signifies no-project, but abides by the null object pattern\n\n    @private\n    @static\n    @method projectOrnullProject\n    @param  {UI} _ui The UI instance to provide to the created Project.\n    @return {Project}         Project instance\n   */\n  static projectOrnullProject(_ui, _cli) {\n    try {\n      return Project.closestSync(process.cwd(), _ui, _cli);\n    } catch (reason) {\n      if (reason instanceof Project.NotFoundError) {\n        return Project.nullProject(_ui, _cli);\n      } else {\n        throw reason;\n      }\n    }\n  }\n\n  /**\n    Returns the project root based on the first package.json that is found\n\n    @static\n    @method getProjectRoot\n    @return {String} The project root directory\n   */\n  static getProjectRoot() {\n    let packagePath = findup.sync('package.json');\n    if (!packagePath) {\n      logger.info('getProjectRoot: not found. Will use cwd: %s', process.cwd());\n      return process.cwd();\n    }\n\n    let directory = path.dirname(packagePath);\n    const pkg = require(packagePath);\n\n    if (pkg && pkg.name === 'ember-cli') {\n      logger.info('getProjectRoot: named \\'ember-cli\\'. Will use cwd: %s', process.cwd());\n      return process.cwd();\n    }\n\n    logger.info('getProjectRoot %s -> %s', process.cwd(), directory);\n    return directory;\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundError';\n    this.stack = (new Error()).stack;\n  }\n}\n\nProject.NotFoundError = NotFoundError;\n\nfunction ensureInstrumentation(cli, ui) {\n  if (cli && cli.instrumentation) {\n    return cli.instrumentation;\n  }\n\n  // created without a `cli` object (possibly from deprecated `Brocfile.js`)\n  return new Instrumentation({\n    ui,\n    initInstrumentation: null,\n  });\n}\n\nfunction ensureUI(_ui) {\n  let ui = _ui;\n\n  if (!ui) {\n    // TODO: one UI (lib/cli/index.js also has one for now...)\n    const UI = require('console-ui');\n    ui = new UI({\n      inputStream: process.stdin,\n      outputStream: process.stdout,\n      ci: process.env.CI || (/^(dumb|emacs)$/).test(process.env.TERM),\n      writeLevel: (process.argv.indexOf('--silent') !== -1) ? 'ERROR' : undefined,\n    });\n  }\n\n  return ui;\n}\n\nfunction closestPackageJSON(pathName) {\n  return findup('package.json', { cwd: pathName }).then(packagePath => {\n    if (!packagePath) {\n      throw new NotFoundError(`No project found at or up from: \\`${pathName}\\``);\n    }\n\n    return {\n      directory: path.dirname(packagePath),\n      pkg: require(packagePath),\n    };\n  });\n}\n\nfunction findupPath(pathName) {\n  let pkgPath = findup.sync('package.json', { cwd: pathName });\n  if (!pkgPath) {\n    throw new NotFoundError(`No project found at or up from: \\`${pathName}\\``);\n  }\n\n  return path.dirname(pkgPath);\n}\n\nfunction isEmberCliProject(pkg) {\n  return pkg && (\n    (pkg.dependencies && Object.keys(pkg.dependencies).indexOf('ember-cli') !== -1) ||\n    (pkg.devDependencies && Object.keys(pkg.devDependencies).indexOf('ember-cli') !== -1)\n  );\n}\n\n// Export\nmodule.exports = Project;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/version-utils.js":"'use strict';\n\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst getRepoInfo = require('git-repo-info');\n\nmodule.exports = {\n  emberCLIVersion: function emberCLIVersion() {\n    let gitPath = path.join(__dirname, '..', '..', '.git');\n    let output = [require('../../package.json').version];\n\n    if (existsSync(gitPath)) {\n      let repoInfo = getRepoInfo(gitPath);\n\n      output.push(repoInfo.branch);\n      output.push(repoInfo.abbreviatedSha);\n    }\n\n    return output.join('-');\n  },\n\n  isDevelopment: function isDevelopment(version) {\n    // match postfix SHA in dev version\n    return !!version.match(/\\b[0-9a-f]{5,40}\\b/);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/find-addon-by-name.js":"'use strict';\n\nconst find = require('ember-cli-lodash-subset').find;\n\nmodule.exports = function findAddonByName(addons, name) {\n  function matchAddon(name, addon) {\n    return name === addon.name || (addon.pkg && name === addon.pkg.name);\n  }\n\n  return find(addons, addon => matchAddon(name, addon));\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/instrumentation.js":"'use strict';\n\nconst fs = require('fs-extra');\nconst chalk = require('chalk');\nconst experiments = require('../experiments/');\nconst heimdallGraph = require('heimdalljs-graph');\nconst utilsInstrumentation = require('../utilities/instrumentation');\n\nlet vizEnabled = utilsInstrumentation.vizEnabled;\nlet instrumentationEnabled = utilsInstrumentation.instrumentationEnabled;\n\nfunction _enableFSMonitorIfInstrumentationEnabled() {\n  let monitor;\n  if (instrumentationEnabled()) {\n    const FSMonitor = require('heimdalljs-fs-monitor');\n    monitor = new FSMonitor();\n    monitor.start();\n  }\n  return monitor;\n}\n\n_enableFSMonitorIfInstrumentationEnabled();\n\n\nclass Instrumentation {\n  /**\n     An instance of this class is used for invoking the instrumentation\n     hooks on addons.\n\n     The instrumentation types currently supported are:\n\n     * init\n     * build\n     * command\n     * shutdown\n\n     @class Instrumentation\n     @private\n  */\n  constructor(options) {\n    this.isVizEnabled = vizEnabled;\n    this.isEnabled = instrumentationEnabled;\n\n    this.ui = options.ui;\n\n    // project constructor will set up bidirectional link\n    this.project = null;\n\n    this.instrumentations = {\n      init: options.initInstrumentation,\n      build: {\n        token: null,\n        node: null,\n        count: 0,\n      },\n      command: {\n        token: null,\n        node: null,\n      },\n      shutdown: {\n        token: null,\n        node: null,\n      },\n    };\n\n    this._heimdall = null;\n\n    if (!options.initInstrumentation && this.isEnabled()) {\n      this.instrumentations.init = {\n        token: null,\n        node: null,\n      };\n      this.start('init');\n\n      this.ui.writeLine(chalk.yellow(\n        'No init instrumentation passed to CLI.  Please update your global ember or ' +\n        'invoke ember via the local executable within node_modules.  Init ' +\n        'instrumentation will still be recorded, but some bootstraping will be ' +\n        'omitted.'\n      ));\n    }\n  }\n\n  _buildSummary(tree, result, resultAnnotation) {\n    let buildSteps = 0;\n    let totalTime = 0;\n\n    let node;\n    let statName;\n    let statValue;\n    let nodeItr;\n    let statsItr;\n    let nextNode;\n    let nextStat;\n\n    for (nodeItr = tree.dfsIterator(); ;) {\n      nextNode = nodeItr.next();\n      if (nextNode.done) { break; }\n\n      node = nextNode.value;\n      if (node.label.broccoliNode && !node.label.broccoliCachedNode) {\n        ++buildSteps;\n      }\n\n      for (statsItr = node.statsIterator(); ;) {\n        nextStat = statsItr.next();\n        if (nextStat.done) { break; }\n\n        statName = nextStat.value[0];\n        statValue = nextStat.value[1];\n\n        if (statName === 'time.self') {\n          totalTime += statValue;\n        }\n      }\n    }\n\n    let summary = {\n      build: {\n        type: resultAnnotation.type,\n        count: this.instrumentations.build.count,\n        outputChangedFiles: null,\n      },\n      platform: {\n        name: process.platform,\n      },\n      output: null,\n      totalTime,\n      buildSteps,\n    };\n\n    if (result) {\n      summary.build.outputChangedFiles = result.outputChanges;\n      summary.output = result.directory;\n    }\n\n    if (resultAnnotation.type === 'rebuild') {\n      summary.build.primaryFile = resultAnnotation.primaryFile;\n      summary.build.changedFileCount = resultAnnotation.changedFiles.length;\n      summary.build.changedFiles = resultAnnotation.changedFiles.slice(0, 10);\n    }\n\n    return summary;\n  }\n\n  _initSummary(tree) {\n    return {\n      totalTime: totalTime(tree),\n      platform: {\n        name: process.platform,\n      },\n    };\n  }\n\n  _commandSummary(tree, commandName, commandArgs) {\n    return {\n      name: commandName,\n      args: commandArgs,\n      totalTime: totalTime(tree),\n      platform: {\n        name: process.platform,\n      },\n    };\n  }\n\n  _shutdownSummary(tree) {\n    return {\n      totalTime: totalTime(tree),\n      platform: {\n        name: process.platform,\n      },\n    };\n  }\n\n  _instrumentationFor(name) {\n    let instr = this.instrumentations[name];\n    if (!instr) {\n      throw new Error(`No such instrumentation \"${name}\"`);\n    }\n    return instr;\n  }\n\n  _instrumentationTreeFor(name) {\n    return heimdallGraph.loadFromNode(this.instrumentations[name].node);\n  }\n\n  _invokeAddonHook(name, instrumentationInfo) {\n    if (!experiments.INSTRUMENTATION) { return; }\n\n    if (this.project && this.project.addons.length) {\n      this.project.addons.forEach(addon => {\n        if (experiments.BUILD_INSTRUMENTATION && addon[experiments.BUILD_INSTRUMENTATION]) {\n          throw new TypeError(\n            `${addon.name} defines experiments.BUILD_INSTRUMENTATION. Update to use experiments.INSTRUMENTATION`\n          );\n        }\n\n        let hook = addon[experiments.INSTRUMENTATION];\n        if (typeof hook === 'function') {\n          hook.call(addon, name, instrumentationInfo);\n        }\n      });\n    }\n  }\n\n  _writeInstrumentation(name, instrumentationInfo) {\n    if (!vizEnabled()) { return; }\n\n    let filename = `instrumentation.${name}`;\n    if (name === 'build') {\n      filename += `.${this.instrumentations.build.count}`;\n    }\n    filename = `${filename}.json`;\n    fs.writeJsonSync(filename, {\n      summary: instrumentationInfo.summary,\n      // we want to change this to tree, to be consistent with the hook, but first\n      // we must update broccoli-viz\n      // see see https://github.com/ember-cli/broccoli-viz/issues/35\n      nodes: instrumentationInfo.tree.toJSON().nodes,\n    });\n  }\n\n  start(name) {\n    if (!instrumentationEnabled()) { return; }\n\n    let instr = this._instrumentationFor(name);\n    this._heimdall = this._heimdall || require('heimdalljs');\n\n    if (instr.node) {\n      // don't leak nodes during build.  We have already reported on this in the\n      // previous stopAndReport so no data is lost\n      instr.node.remove();\n    }\n\n    let token = this._heimdall.start({ name, emberCLI: true });\n    instr.token = token;\n    instr.node = this._heimdall.current;\n  }\n\n  stopAndReport(name) {\n    if (!instrumentationEnabled()) { return; }\n\n    let instr = this._instrumentationFor(name);\n    if (!instr.token) {\n      throw new Error(`Cannot stop instrumentation \"${name}\".  It has not started.`);\n    }\n    instr.token.stop();\n\n    let instrSummaryName = `_${name}Summary`;\n    if (!this[instrSummaryName]) {\n      throw new Error(`No summary found for \"${name}\"`);\n    }\n\n    let tree = this._instrumentationTreeFor(name);\n    let args = Array.prototype.slice.call(arguments, 1);\n    args.unshift(tree);\n\n    let instrInfo = {\n      summary: this[instrSummaryName].apply(this, args),\n      tree,\n    };\n\n    this._invokeAddonHook(name, instrInfo);\n    this._writeInstrumentation(name, instrInfo);\n\n    if (name === 'build') {\n      instr.count++;\n    }\n  }\n}\n\nfunction totalTime(tree) {\n  let totalTime = 0;\n  let nodeItr;\n  let node;\n  let statName;\n  let statValue;\n  let statsItr;\n  let nextNode;\n  let nextStat;\n\n  for (nodeItr = tree.dfsIterator(); ;) {\n    nextNode = nodeItr.next();\n    if (nextNode.done) { break; }\n\n    node = nextNode.value;\n\n    for (statsItr = node.statsIterator(); ;) {\n      nextStat = statsItr.next();\n      if (nextStat.done) { break; }\n\n      statName = nextStat.value[0];\n      statValue = nextStat.value[1];\n\n      if (statName === 'time.self') {\n        totalTime += statValue;\n      }\n    }\n  }\n\n  return totalTime;\n}\n\n// exported for testing\nInstrumentation._enableFSMonitorIfInstrumentationEnabled = _enableFSMonitorIfInstrumentationEnabled;\nInstrumentation._vizEnabled = vizEnabled();\nInstrumentation._instrumentationEnabled = instrumentationEnabled();\n\nmodule.exports = Instrumentation;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/experiments/index.js":"'use strict';\n\nlet experiments = { };\n\nObject.freeze(experiments);\n\nmodule.exports = experiments;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/merge-trees.js":"'use strict';\nconst upstreamMergeTrees = require('broccoli-merge-trees');\nconst heimdall = require('heimdalljs');\nconst heimdallLogger = require('heimdalljs-logger');\nlet logger = heimdallLogger('ember-cli:merge-trees');\nlet EMPTY_MERGE_TREE;\n\nfunction overrideEmptyTree(tree) {\n  EMPTY_MERGE_TREE = tree;\n}\n\nfunction getEmptyTree() {\n  if (EMPTY_MERGE_TREE) {\n    return EMPTY_MERGE_TREE;\n  }\n\n  EMPTY_MERGE_TREE = upstreamMergeTrees([], {\n    annotation: 'EMPTY_MERGE_TREE',\n    description: 'EMPTY_MERGE_TREE',\n  });\n\n  let originalCleanup = EMPTY_MERGE_TREE.cleanup;\n  EMPTY_MERGE_TREE.cleanup = function() {\n    // this tree is being cleaned up, we must\n    // ensure that our shared EMPTY_MERGE_TREE is\n    // reset (otherwise it will not have a valid\n    // `outputPath`)\n    EMPTY_MERGE_TREE = null;\n    return originalCleanup.apply(this, arguments);\n  };\n\n  return EMPTY_MERGE_TREE;\n}\n\nmodule.exports = function mergeTrees(_inputTrees, options) {\n  options = options || {};\n\n  let node = heimdall.start({\n    name: `EmberCliMergeTrees(${options.annotation})`,\n    emberCliMergeTrees: true,\n  }, function MergeTreesSchema() {\n    this.emptyTrees = 0;\n    this.duplicateTrees = 0;\n    this.returns = {\n      empty: 0,\n      identity: 0,\n      merge: 0,\n    };\n  });\n\n  let inputTrees = _inputTrees.filter(function _removeEmptyTrees(tree) {\n    if (tree && tree !== getEmptyTree()) {\n      return true;\n    } else {\n      node.stats.emptyTrees++;\n      logger.debug('Removing empty tree');\n      return false;\n    }\n  }).reduce(function _dedupeTrees(result, tree) {\n    // Check for a previous duplicate and remove it so the last one \"wins\"\n    let indexOfTree = result.indexOf(tree);\n    if (indexOfTree !== -1) {\n      node.stats.duplicateTrees++;\n      logger.debug(`Removing duplicate tree: ${tree.annotation}`);\n      result.splice(indexOfTree, 1);\n    }\n\n    result.push(tree);\n    return result;\n  }, []);\n\n  switch (inputTrees.length) {\n    case 0:\n      node.stats.returns.empty++;\n      logger.info('Returning empty tree');\n      node.stop();\n      return getEmptyTree();\n    case 1:\n      node.stats.returns.identity++;\n      logger.info('Returning single input tree');\n      node.stop();\n      return inputTrees[0];\n    default: {\n      options.description = options.annotation;\n      let tree = upstreamMergeTrees(inputTrees, options);\n\n      tree.description = options && options.description;\n\n      node.stats.returns.merge++;\n      logger.info('Returning upstream merged trees');\n      node.stop();\n      return tree;\n    }\n  }\n};\n\nmodule.exports._overrideEmptyTree = overrideEmptyTree;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/addon-process-tree.js":"'use strict';\n\nmodule.exports = function addonProcessTree(projectOrAddon, hook, processType, tree) {\n  return projectOrAddon.addons.reduce((workingTree, addon) => {\n    if (addon[hook]) {\n      return addon[hook](processType, workingTree);\n    }\n\n    return workingTree;\n  }, tree);\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/broccoli/testem.js":"/*\n * This is dummy file that exists for the sole purpose\n * of allowing tests to run directly in the browser as\n * well as by Testem.\n *\n * Testem is configured to run tests directly against\n * the test build of index.html, which requires a\n * snippet to load the testem.js file:\n *   <script src=\"/testem.js\"></script>\n * This has to go before the qunit framework and app\n * tests are loaded.\n *\n * Testem internally supplies this file. However, if you\n * run the tests directly in the browser (localhost:8000/tests),\n * this file does not exist.\n *\n * Hence the purpose of this fake file. This file is served\n * directly from the express server to satisify the script load.\n */\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/cli/cli.js":"'use strict';\n\nconst RSVP = require('rsvp');\n\nconst lookupCommand = require('./lookup-command');\nconst getOptionArgs = require('../utilities/get-option-args');\nlet logger = require('heimdalljs-logger')('ember-cli:cli');\nlet loggerTesting = require('heimdalljs-logger')('ember-cli:testing');\nconst Instrumentation = require('../models/instrumentation');\nconst exit = require('capture-exit');\nconst heimdall = require('heimdalljs');\n\nconst Promise = RSVP.Promise;\n\nclass CLI {\n  /**\n   * @private\n   * @class CLI\n   * @constructor\n   * @param options\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @property name\n     */\n    this.name = options.name;\n\n    /**\n     * @private\n     * @property ui\n     * @type UI\n     */\n    this.ui = options.ui;\n\n    /**\n     * @private\n     * @property analytics\n     */\n    this.analytics = options.analytics;\n\n    /**\n     * @private\n     * @property testing\n     * @type Boolean\n     */\n    this.testing = options.testing;\n\n    /**\n     * @private\n     * @property disableDependencyChecker\n     * @type Boolean\n     */\n    this.disableDependencyChecker = options.disableDependencyChecker;\n\n    /**\n     * @private\n     * @property root\n     */\n    this.root = options.root;\n\n    /**\n     * @private\n     * @property npmPackage\n     */\n    this.npmPackage = options.npmPackage;\n\n    /**\n     * @private\n     * @property instrumentation\n     */\n    this.instrumentation = options.instrumentation || new Instrumentation({\n      ui: options.ui,\n      initInstrumentation: options.initInstrumentation,\n    });\n\n    logger.info('testing %o', !!this.testing);\n  }\n\n  /**\n   * @private\n   * @method run\n   * @param environment\n   * @return {Promise}\n   */\n  run(environment) {\n    let shutdownOnExit = null;\n\n    return RSVP.hash(environment).then(environment => {\n      let args = environment.cliArgs.slice();\n      let commandName = args.shift();\n      let commandArgs = args;\n      let helpOptions;\n\n      let commandLookupCreationtoken = heimdall.start('lookup-command');\n\n      let CurrentCommand = lookupCommand(environment.commands, commandName, commandArgs, {\n        project: environment.project,\n        ui: this.ui,\n      });\n\n      let command = new CurrentCommand({\n        ui: this.ui,\n        analytics: this.analytics,\n        commands: environment.commands,\n        tasks: environment.tasks,\n        project: environment.project,\n        settings: environment.settings,\n        testing: this.testing,\n        cli: this,\n      });\n\n      commandLookupCreationtoken.stop();\n\n      getOptionArgs('--verbose', commandArgs).forEach(arg => {\n        process.env[`EMBER_VERBOSE_${arg.toUpperCase()}`] = 'true';\n      });\n\n      let platformCheckerToken = heimdall.start('platform-checker');\n\n      const PlatformChecker = require('../utilities/platform-checker');\n      let platform = new PlatformChecker(process.version);\n      let recommendation = ' We recommend that you use the most-recent \"Active LTS\" version of Node.js.';\n\n      if (!this.testing) {\n        if (platform.isDeprecated) {\n          this.ui.writeDeprecateLine(`Node ${process.version} is no longer supported by Ember CLI.${recommendation}`);\n        }\n\n        if (!platform.isTested) {\n          this.ui.writeWarnLine(`Node ${process.version} is not tested against Ember CLI on your platform.${recommendation}`);\n        }\n      }\n\n      platformCheckerToken.stop();\n\n      logger.info('command: %s', commandName);\n\n      if (!this.testing) {\n        process.chdir(environment.project.root);\n        let skipInstallationCheck = commandArgs.indexOf('--skip-installation-check') !== -1;\n        if (environment.project.isEmberCLIProject() && !skipInstallationCheck) {\n          const InstallationChecker = require('../models/installation-checker');\n          new InstallationChecker({ project: environment.project }).checkInstallations();\n        }\n      }\n\n      let instrumentation = this.instrumentation;\n      let initCompleted = false;\n\n      return Promise.resolve().then(() => {\n        instrumentation.stopAndReport('init');\n        initCompleted = true;\n        instrumentation.start('command');\n\n        loggerTesting.info('cli: command.beforeRun');\n\n        return command.beforeRun(commandArgs);\n\n      }).then(() => {\n        loggerTesting.info('cli: command.validateAndRun');\n\n        return command.validateAndRun(commandArgs);\n      }).finally(() => {\n        if (initCompleted) {\n          instrumentation.stopAndReport('command', commandName, commandArgs);\n        }\n        instrumentation.start('shutdown');\n\n        shutdownOnExit = function() {\n          instrumentation.stopAndReport('shutdown');\n        };\n\n        // schedule this with `capture-exit` to ensure that\n        // the shutdown instrumentation hook is invoked properly even if\n        // we exit before hitting the `finally` below\n        exit.onExit(shutdownOnExit);\n      }).then(result => {\n        // if the help option was passed, call the help command\n        if (result === 'callHelp') {\n          helpOptions = {\n            environment,\n            commandName,\n            commandArgs,\n          };\n\n          return this.callHelp(helpOptions);\n        }\n\n        return result;\n\n      }).then(exitCode => {\n        loggerTesting.info(`cli: command run complete. exitCode: ${exitCode}`);\n        // TODO: fix this\n        // Possibly this issue: https://github.com/joyent/node/issues/8329\n        // Wait to resolve promise when running on windows.\n        // This ensures that stdout is flushed so acceptance tests get full output\n\n        return new Promise(resolve => {\n          if (process.platform === 'win32') {\n            setTimeout(resolve, 250, exitCode);\n          } else {\n            resolve(exitCode);\n          }\n        });\n      });\n    })\n      .finally(() => {\n        if (shutdownOnExit) {\n          // invoke instrumentation shutdown and\n          // remove from `capture-exit` callbacks\n          shutdownOnExit();\n          exit.offExit(shutdownOnExit);\n        }\n      })\n      .catch(this.logError.bind(this));\n  }\n\n  /**\n   * @private\n   * @method callHelp\n   * @param options\n   * @return {Promise}\n   */\n  callHelp(options) {\n    let environment = options.environment;\n    let commandName = options.commandName;\n    let commandArgs = options.commandArgs;\n    let helpIndex = commandArgs.indexOf('--help');\n    let hIndex = commandArgs.indexOf('-h');\n\n    let HelpCommand = lookupCommand(environment.commands, 'help', commandArgs, {\n      project: environment.project,\n      ui: this.ui,\n    });\n\n    let help = new HelpCommand({\n      ui: this.ui,\n      analytics: this.analytics,\n      commands: environment.commands,\n      tasks: environment.tasks,\n      project: environment.project,\n      settings: environment.settings,\n      testing: this.testing,\n    });\n\n    if (helpIndex > -1) {\n      commandArgs.splice(helpIndex, 1);\n    }\n\n    if (hIndex > -1) {\n      commandArgs.splice(hIndex, 1);\n    }\n\n    commandArgs.unshift(commandName);\n\n    return help.validateAndRun(commandArgs);\n  }\n\n  /**\n   * @private\n   * @method logError\n   * @param error\n   * @return {number}\n   */\n  logError(error) {\n    if (this.testing && error) {\n      console.error(error.message);\n      if (error.stack) {\n        console.error(error.stack);\n      }\n      throw error;\n    }\n    this.ui.errorLog.push(error);\n    this.ui.writeError(error);\n    return 1;\n  }\n}\n\nmodule.exports = CLI;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/cli/lookup-command.js":"'use strict';\n\nconst UnknownCommand = require('../commands/unknown');\n\nmodule.exports = function(commands, commandName, commandArgs, optionHash) {\n  let options = optionHash || {};\n  let project = options.project;\n  let ui = options.ui;\n\n  function aliasMatches(alias) {\n    return alias === commandName;\n  }\n\n  function findCommand(commands, commandName) {\n    for (let key in commands) {\n      let command = commands[key];\n\n      let name = command.prototype.name;\n      let aliases = command.prototype.aliases || [];\n\n      if (name === commandName || aliases.some(aliasMatches)) {\n        return command;\n      }\n    }\n  }\n\n  // Attempt to find command in ember-cli core commands\n  let command = findCommand(commands, commandName);\n\n  let addonCommand;\n  // Attempt to find command within addons\n  if (project && project.eachAddonCommand) {\n    project.eachAddonCommand((addonName, commands) => {\n      addonCommand = findCommand(commands, commandName);\n      return !addonCommand;\n    });\n  }\n\n  if (command && addonCommand) {\n    if (addonCommand.overrideCore) {\n      ui.writeWarnLine(`An ember-addon has attempted to override the core command \"${command.prototype.name}\". ` +\n        `The addon command will be used as the overridding was explicit.`);\n\n      return addonCommand;\n    }\n\n    ui.writeWarnLine(`An ember-addon has attempted to override the core command \"${command.prototype.name}\". ` +\n      `The core command will be used.`);\n    return command;\n  }\n\n  if (command) {\n    return command;\n  }\n\n  if (addonCommand) {\n    return addonCommand;\n  }\n\n  // if we didn't find anything, return an \"UnknownCommand\"\n  return class extends UnknownCommand {\n    constructor(options) {\n      super(options);\n      this.name = commandName;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/unknown.js":"'use strict';\n\nconst Command = require('../models/command');\nconst SilentError = require('silent-error');\nconst chalk = require('chalk');\n\nmodule.exports = Command.extend({\n  skipHelp: true,\n  unknown: true,\n\n  printBasicHelp() {\n    return chalk.red(`No help entry for '${this.name}'`);\n  },\n\n  validateAndRun() {\n    throw new SilentError(`The specified command ${this.name} is invalid. For available options, see \\`ember help\\`.`);\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/command.js":"'use strict';\n\nconst nopt = require('nopt');\nconst chalk = require('chalk');\nconst path = require('path');\nconst isGitRepo = require('is-git-url');\nconst camelize = require('ember-cli-string-utils').camelize;\nconst getCallerFile = require('get-caller-file');\nconst printableProperties = require('../utilities/printable-properties').command;\nconst printCommand = require('../utilities/print-command');\nconst Promise = require('rsvp').Promise;\nconst _ = require('ember-cli-lodash-subset');\nconst EOL = require('os').EOL;\nconst CoreObject = require('core-object');\nlet logger = require('heimdalljs-logger')('ember-cli:command');\nconst WatchDetector = require('../models/watch-detector');\nconst SilentError = require('silent-error');\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\n\nlet cache = {};\n\nlet allowedWorkOptions = {\n  insideProject: true,\n  outsideProject: true,\n  everywhere: true,\n};\n\npath.name = 'Path';\n// extend nopt to recognize 'gitUrl' as a type\nnopt.typeDefs.gitUrl = {\n  type: 'gitUrl',\n  validate(data, k, val) {\n    if (isGitRepo(val)) {\n      data[k] = val;\n      return true;\n    } else {\n      return false;\n    }\n  },\n};\n\n/**\n * The base class for all CLI commands.\n *\n * @module ember-cli\n * @class Command\n * @constructor\n * @extends CoreObject\n */\nlet Command = CoreObject.extend({\n  /**\n   * The description of what this command does.\n   *\n   * @final\n   * @property description\n   * @type String\n   */\n  description: null,\n\n  /**\n   * Does this command work everywhere or just inside or outside of projects.\n   *\n   * Possible values:\n   *\n   * - `insideProject`\n   * - `outsideProject`\n   * - `everywhere`\n   *\n   * @final\n   * @property works\n   * @type String\n   * @default `insideProject`\n   */\n  works: 'insideProject',\n\n  init() {\n    this._super.apply(this, arguments);\n\n    /**\n     * @final\n     * @property isWithinProject\n     * @type Boolean\n     */\n    this.isWithinProject = this.project.isEmberCLIProject();\n\n    /**\n     * The name of the command.\n     *\n     * @final\n     * @property name\n     * @type String\n     * @example `new` or `generate`\n     */\n    this.name = this.name || path.basename(getCallerFile(), '.js');\n\n    logger.info('initialize: name: %s, name: %s', this.name);\n\n    /**\n     * An array of aliases for the command\n     *\n     * @final\n     * @property aliases\n     * @type Array\n     * @example `['g']` for the `generate` command\n     */\n    this.aliases = this.aliases || [];\n\n    // Works Property\n    if (!allowedWorkOptions[this.works]) {\n      throw new Error(`The \"${this.name}\" command's works field has to be either \"everywhere\", \"insideProject\" or \"outsideProject\".`);\n    }\n\n    /**\n     * An array of available options for the command\n     *\n     * @final\n     * @property availableOptions\n     * @type Array\n     * @example\n     * ```js\n     * availableOptions: [\n     *   { name: 'dry-run',    type: Boolean, default: false, aliases: ['d'] },\n     *   { name: 'verbose',    type: Boolean, default: false, aliases: ['v'] },\n     *   { name: 'blueprint',  type: String,  default: 'app', aliases: ['b'] },\n     *   { name: 'skip-npm',   type: Boolean, default: false, aliases: ['sn'] },\n     *   { name: 'skip-bower', type: Boolean, default: false, aliases: ['sb'] },\n     *   { name: 'skip-git',   type: Boolean, default: false, aliases: ['sg'] },\n     *   { name: 'directory',  type: String ,                 aliases: ['dir'] }\n     * ],\n     * ```\n     */\n    this.availableOptions = this.availableOptions || [];\n\n    /**\n     * An array of anonymous options for the command\n     *\n     * @final\n     * @property anonymousOptions\n     * @type Array\n     * @example\n     * ```js\n     * anonymousOptions: [\n     *   '<blueprint>'\n     * ],\n     * ```\n     */\n    this.anonymousOptions = this.anonymousOptions || [];\n\n    this.registerOptions();\n  },\n\n  /**\n    Registers options with command. This method provides the ability to extend or override command options.\n    Expects an object containing anonymousOptions or availableOptions, which it will then merge with\n    existing availableOptions before building the optionsAliases which are used to define shorthands.\n\n    @method registerOptions\n    @param {Object} options\n  */\n  registerOptions(options) {\n    let extendedAvailableOptions = (options && options.availableOptions) || [];\n    let extendedAnonymousOptions = (options && options.anonymousOptions) || [];\n\n    this.anonymousOptions = _.union(this.anonymousOptions.slice(0), extendedAnonymousOptions);\n\n    // merge any availableOptions\n    this.availableOptions = _.union(this.availableOptions.slice(0), extendedAvailableOptions);\n\n    let optionKeys = _.uniq(_.map(this.availableOptions, 'name'));\n\n    optionKeys.map(this.mergeDuplicateOption.bind(this));\n\n    this.optionsAliases = this.optionsAliases || {};\n\n    this.availableOptions.map(this.validateOption.bind(this));\n  },\n\n  /**\n    Hook for extending a command before it is run in the cli.run command.\n    Most common use case would be to extend availableOptions.\n    @method beforeRun\n    @return {Promise|null}\n  */\n  beforeRun() {\n\n  },\n\n  /**\n    @method validateAndRun\n    @return {Promise}\n  */\n  validateAndRun(args) {\n    return new Promise(resolve => {\n      let commandOptions = this.parseArgs(args);\n      // if the help option was passed, resolve with 'callHelp' to call help command\n      if (commandOptions && (commandOptions.options.help || commandOptions.options.h)) {\n        logger.info(`${this.name} called with help option`);\n        return resolve('callHelp');\n      }\n\n      this.analytics.track({\n        name: 'ember ',\n        message: this.name,\n      });\n\n      if (commandOptions === null) {\n        return resolve();\n      }\n\n      if (this.works === 'outsideProject' && this.isWithinProject) {\n        throw new SilentError(`You cannot use the ${chalk.green(this.name)} command inside an ember-cli project.`);\n      }\n\n      if (this.works === 'insideProject') {\n        if (!this.project.hasDependencies()) {\n          throw new SilentError('node_modules appears empty, you may need to run `npm install`');\n        }\n      }\n\n      let detector = new WatchDetector({\n        ui: this.ui,\n        childProcess: { execSync },\n        fs,\n        watchmanSupportsPlatform: (/^win/).test(process.platform),\n        cache,\n        root: this.project.root,\n      });\n\n      let options = commandOptions.options;\n\n      if (this.hasOption('watcher')) {\n        // do stuff to try and provide a good experience when it comes to file watching\n        let watchPreference = detector.findBestWatcherOption(options);\n        this.project._watchmanInfo = watchPreference.watchmanInfo;\n        options.watcher = watchPreference.watcher;\n      }\n      resolve(this.run(options, commandOptions.args));\n    });\n  },\n\n  /**\n    Reports if the given command has a command line option by a given name\n\n    @method hasOption\n    @param {String} name\n    @return {Boolean}\n  */\n  hasOption(name) {\n    for (let i = 0; i < this.availableOptions.length; i++) {\n      if (this.availableOptions[i].name === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n    Merges any options with duplicate keys in the availableOptions array.\n    Used primarily by registerOptions.\n    @method mergeDuplicateOption\n    @param {String} key\n    @return {Object}\n  */\n  mergeDuplicateOption(key) {\n    let duplicateOptions, mergedOption, mergedAliases;\n    // get duplicates to merge\n    duplicateOptions = _.filter(this.availableOptions, { 'name': key });\n\n    if (duplicateOptions.length > 1) {\n      // TODO: warn on duplicates and overwriting\n      mergedAliases = [];\n\n      _.map(duplicateOptions, 'aliases').map(alias => {\n        alias.map(a => {\n          mergedAliases.push(a);\n        });\n      });\n\n      // merge duplicate options\n      mergedOption = _.assign.apply(null, duplicateOptions);\n\n      // replace aliases with unique aliases\n      mergedOption.aliases = _.uniqBy(mergedAliases, alias => {\n        if (typeof alias === 'object') {\n          return alias[Object.keys(alias)[0]];\n        }\n        return alias;\n      });\n\n      // remove duplicates from options\n      this.availableOptions = _.reject(this.availableOptions, { 'name': key });\n      this.availableOptions.push(mergedOption);\n    }\n    return this.availableOptions;\n  },\n\n  /**\n    Normalizes option, filling in implicit values\n    @method normalizeOption\n    @param {Object} option\n    @return {Object}\n  */\n  normalizeOption(option) {\n    option.key = camelize(option.name);\n    option.required = option.required || false;\n    return option;\n  },\n\n  /**\n    Assigns option\n    @method assignOption\n    @param {Object} option\n    @param {Object} parsedOptions\n    @param {Object} commandOptions\n    @return {Boolean}\n  */\n  assignOption(option, parsedOptions, commandOptions) {\n    let isValid = isValidParsedOption(option, parsedOptions[option.name]);\n    if (isValid) {\n      if (parsedOptions[option.name] === undefined) {\n        if (option.default !== undefined) {\n          commandOptions[option.key] = option.default;\n        }\n\n        if (this.settings[option.name] !== undefined) {\n          commandOptions[option.key] = this.settings[option.name];\n        } else if (this.settings[option.key] !== undefined) {\n          commandOptions[option.key] = this.settings[option.key];\n        }\n      } else {\n        commandOptions[option.key] = parsedOptions[option.name];\n        delete parsedOptions[option.name];\n      }\n    } else {\n      this.ui.writeLine(`The specified command ${chalk.green(this.name)} requires the option ${chalk.green(option.name)}.`);\n    }\n    return isValid;\n  },\n\n  /**\n    Validates option\n    @method validateOption\n    @param {Object} option\n    @return {Boolean}\n  */\n  validateOption(option) {\n    let parsedAliases;\n\n    if (!option.name || !option.type) {\n      throw new Error(`The command \"${this.name}\" has an option without the required type and name fields.`);\n    }\n\n    if (option.name !== option.name.toLowerCase()) {\n      throw new Error(`The \"${option.name}\" option's name of the \"${this.name}\" command contains a capital letter.`);\n    }\n\n    this.normalizeOption(option);\n\n    if (option.aliases) {\n      parsedAliases = option.aliases.map(this.parseAlias.bind(this, option));\n      return parsedAliases.map(this.assignAlias.bind(this, option)).indexOf(false) === -1;\n    }\n    return false;\n  },\n\n  /**\n    Parses alias for an option and adds it to optionsAliases\n    @method parseAlias\n    @param {Object} option\n    @param {Object|String} alias\n    @return {Object}\n  */\n  parseAlias(option, alias) {\n    let aliasType = typeof alias;\n    let key, value, aliasValue;\n\n    if (isValidAlias(alias, option.type)) {\n      if (aliasType === 'string') {\n        key = alias;\n        value = [`--${option.name}`];\n      } else if (aliasType === 'object') {\n        key = Object.keys(alias)[0];\n        value = [`--${option.name}`, alias[key]];\n      }\n    } else {\n      if (Array.isArray(alias)) {\n        aliasType = 'array';\n        aliasValue = alias.join(',');\n      } else {\n        aliasValue = alias;\n        try {\n          aliasValue = JSON.parse(alias);\n        } catch (e) {\n          let logger = require('heimdalljs-logger')('ember-cli/models/command');\n          logger.error(e);\n        }\n      }\n      throw new Error(`The \"${aliasValue}\" [type:${aliasType}] alias is not an acceptable value. ` +\n        `It must be a string or single key object with a string value (for example, \"value\" or { \"key\" : \"value\" }).`);\n    }\n\n    return {\n      key,\n      value,\n      original: alias,\n    };\n  },\n\n  /**\n   * @method assignAlias\n   * @param option\n   * @param alias\n   * @return {Boolean}\n   */\n  assignAlias(option, alias) {\n    let isValid = this.validateAlias(option, alias);\n\n    if (isValid) {\n      this.optionsAliases[alias.key] = alias.value;\n    }\n    return isValid;\n  },\n\n  /**\n    Validates alias value\n    @method validateAlias\n    @param {Object} alias\n    @return {Boolean}\n  */\n  validateAlias(option, alias) {\n    let key = alias.key;\n    let value = alias.value;\n\n    if (!this.optionsAliases[key]) {\n      return true;\n    } else {\n      if (value[0] !== this.optionsAliases[key][0]) {\n        throw new SilentError(`The \"${key}\" alias is already in use by the \"${this.optionsAliases[key][0]}\" option ` +\n          `and cannot be used by the \"${value[0]}\" option. Please use a different alias.`);\n\n      } else if (value[1] !== this.optionsAliases[key][1]) {\n        this.ui.writeLine(chalk.yellow(`The \"${key}\" alias cannot be overridden. Please use a different alias.`));\n        // delete offending alias from options\n        let index = this.availableOptions.indexOf(option);\n        let aliasIndex = this.availableOptions[index].aliases.indexOf(alias.original);\n        if (this.availableOptions[index].aliases[aliasIndex]) {\n          delete this.availableOptions[index].aliases[aliasIndex];\n        }\n      }\n      return false;\n    }\n  },\n\n  /**\n    Parses command arguments and processes\n    @method parseArgs\n    @param {Object} commandArgs\n    @return {Object|null}\n  */\n  parseArgs(commandArgs) {\n    let knownOpts = {}; // Parse options\n    let commandOptions = {};\n    let parsedOptions;\n\n    let assembleAndValidateOption = function(option) {\n      return this.assignOption(option, parsedOptions, commandOptions);\n    };\n\n    let validateParsed = function(key) {\n      // ignore 'argv', 'h', and 'help'\n      if (!commandOptions.hasOwnProperty(key) && key !== 'argv' && key !== 'h' && key !== 'help') {\n        this.ui.writeLine(chalk.yellow(`The option '--${key}' is not registered with the ${this.name} command. ` +\n          `Run \\`ember ${this.name} --help\\` for a list of supported options.`));\n      }\n      if (typeof parsedOptions[key] !== 'object') {\n        commandOptions[camelize(key)] = parsedOptions[key];\n      }\n    };\n\n    this.availableOptions.forEach(option => {\n      if (typeof option.type !== 'string') {\n        knownOpts[option.name] = option.type;\n      } else if (option.type === 'Path') {\n        knownOpts[option.name] = path;\n      } else {\n        knownOpts[option.name] = String;\n      }\n    });\n\n    parsedOptions = nopt(knownOpts, this.optionsAliases, commandArgs, 0);\n\n    if (!this.availableOptions.every(assembleAndValidateOption.bind(this))) {\n      return null;\n    }\n\n    _.keys(parsedOptions).map(validateParsed.bind(this));\n\n    return {\n      options: _.defaults(commandOptions, this.settings),\n      args: parsedOptions.argv.remain,\n    };\n  },\n\n  /**\n   * @method run\n   * @param commandArgs\n   */\n  run(commandArgs) {\n    throw new Error(`command must implement run${commandArgs.toString()}`);\n  },\n\n  _printCommand: printCommand,\n\n  /**\n    Prints basic help for the command.\n\n    Basic help looks like this:\n\n        ember generate <blueprint> <options...>\n          Generates new code from blueprints\n          aliases: g\n          --dry-run (Default: false)\n          --verbose (Default: false)\n\n    The default implementation is designed to cover all bases\n    but may be overriden if necessary.\n\n    @method printBasicHelp\n  */\n  printBasicHelp() {\n    // ember command-name\n    let output;\n    if (this.isRoot) {\n      output = `Usage: ${this.name}`;\n    } else {\n      output = `ember ${this.name}`;\n    }\n\n    output += this._printCommand();\n    output += EOL;\n\n    return output;\n  },\n\n  /**\n    Prints detailed help for the command.\n\n    The default implementation is no-op and should be overridden\n    for each command where further help text is required.\n\n    @method printDetailedHelp\n  */\n  printDetailedHelp() {},\n\n  /**\n   * @method getJson\n   * @param {Object} options\n   * @return {Object}\n   */\n  getJson(options) {\n    let json = {};\n\n    printableProperties.forEachWithProperty(function(key) {\n      json[key] = this[key];\n    }, this);\n\n    if (this.addAdditionalJsonForHelp) {\n      this.addAdditionalJsonForHelp(json, options);\n    }\n\n    return json;\n  },\n});\n\n/*\n  Validates options parsed by nopt\n*/\nfunction isValidParsedOption(option, parsedOption) {\n  // option.name didn't parse\n  if (parsedOption === undefined) {\n    // no default\n    if (option.default === undefined) {\n      if (option.required) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/*\n  Validates alias. Must be a string or single key object\n*/\nfunction isValidAlias(alias, expectedType) {\n  let type = typeof alias;\n  let value, valueType;\n  if (type === 'string') {\n    return true;\n  } else if (type === 'object') {\n\n    // no arrays, no multi-key objects\n    if (!Array.isArray(alias) && Object.keys(alias).length === 1) {\n      value = alias[Object.keys(alias)[0]];\n      valueType = typeof value;\n      if (!Array.isArray(expectedType)) {\n        if (valueType === expectedType.name.toLowerCase()) {\n          return true;\n        }\n\n      } else if (expectedType.indexOf(value) > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/printable-properties.js":"'use strict';\n\nlet commandProperties = [\n  'name',\n  'description',\n  'aliases',\n  'works',\n  'availableOptions',\n  'anonymousOptions',\n];\nlet blueprintProperties = [\n  'name',\n  'description',\n  'availableOptions',\n  'anonymousOptions',\n  'overridden',\n];\n\nfunction forEachWithProperty(properties, forEach, context) {\n  return properties.filter(function(key) {\n    return this[key] !== undefined;\n  }, context).forEach(forEach, context);\n}\n\nmodule.exports = {\n  command: {\n    forEachWithProperty(forEach, context) {\n      return forEachWithProperty(commandProperties, forEach, context);\n    },\n  },\n  blueprint: {\n    forEachWithProperty(forEach, context) {\n      return forEachWithProperty(blueprintProperties, forEach, context);\n    },\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/print-command.js":"'use strict';\n\nconst chalk = require('chalk');\nconst EOL = require('os').EOL;\n\nmodule.exports = function(initialMargin, shouldDescriptionBeGrey) {\n  initialMargin = initialMargin || '';\n\n  let output = '';\n\n  let options = this.anonymousOptions;\n\n  // <anonymous-option-1> ...\n  if (options.length) {\n    output += ` ${chalk.yellow(options.map(option => {\n      // blueprints we insert brackets, commands already have them\n      if (option.indexOf('<') === 0) {\n        return option;\n      } else {\n        return `<${option}>`;\n      }\n    }).join(' '))}`;\n  }\n\n  options = this.availableOptions;\n\n  // <options...>\n  if (options.length) {\n    output += ` ${chalk.cyan('<options...>')}`;\n  }\n\n  // Description\n  let description = this.description;\n  if (description) {\n    if (shouldDescriptionBeGrey) {\n      description = chalk.grey(description);\n    }\n    output += `${EOL + initialMargin}  ${description}`;\n  }\n\n  // aliases: a b c\n  if (this.aliases && this.aliases.length) {\n    output += `${EOL + initialMargin}  ${chalk.grey(`aliases: ${this.aliases.filter(a => a).join(', ')}`)}`;\n  }\n\n  // --available-option (Required) (Default: value)\n  // ...\n  options.forEach(option => {\n    output += `${EOL + initialMargin}  ${chalk.cyan(`--${option.name}`)}`;\n\n    if (option.values) {\n      output += chalk.cyan(`=${option.values.join('|')}`);\n    }\n\n    if (option.type) {\n      let types = Array.isArray(option.type) ?\n        option.type.map(formatType).join(', ') :\n        formatType(option.type);\n\n      output += ` ${chalk.cyan(`(${types})`)}`;\n    }\n\n    if (option.required) {\n      output += ` ${chalk.cyan('(Required)')}`;\n    }\n\n    if (option.default !== undefined) {\n      output += ` ${chalk.cyan(`(Default: ${option.default})`)}`;\n    }\n\n    if (option.description) {\n      output += ` ${option.description}`;\n    }\n\n    if (option.aliases && option.aliases.length) {\n      output += `${EOL + initialMargin}    ${chalk.grey(`aliases: ${option.aliases.map(a => {\n        if (typeof a === 'string') {\n          return (a.length > 4 ? '--' : '-') + a + (option.type === Boolean ? '' : ' <value>');\n        } else {\n          let key = Object.keys(a)[0];\n          return `${(key.length > 4 ? '--' : '-') + key} (--${option.name}=${a[key]})`;\n        }\n      }).join(', ')}`)}`;\n    }\n  });\n\n  return output;\n};\n\nfunction formatType(type) {\n  return typeof type === 'string' ? type : type.name;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/watch-detector.js":"'use strict';\n\nconst quickTemp = require('quick-temp');\nconst Promise = require('rsvp').Promise;\nlet WATCHMAN_INFO = 'Visit https://ember-cli.com/user-guide/#watchman for more info.';\nconst semver = require('semver');\nconst SilentError = require('silent-error');\n\nlet POLLING = 'polling';\nlet WATCHMAN = 'watchman';\nlet NODE = 'node';\nlet EVENTS = 'events';\nlet POSSIBLE_WATCHERS = [\n  POLLING,\n  WATCHMAN,\n  NODE,\n  EVENTS,\n];\n\nlet debug = require('heimdalljs-logger')('ember-cli:watcher');\n\nclass WatchPreference {\n  constructor(watcher) {\n    this.watcher = watcher || null;\n    this._watchmanInfo = {\n      enabled: false,\n      version: null,\n      canNestRoots: false,\n    };\n  }\n\n  watchmanWorks(details) {\n    this._watchmanInfo.enabled = true;\n    this._watchmanInfo.version = details.version;\n    this._watchmanInfo.canNestRoots = semver.satisfies(details.version, '>= 3.7.0');\n  }\n\n  get watchmanInfo() {\n    return this._watchmanInfo;\n  }\n}\n\n/*\n * @public\n *\n * A testable class that encapsulates which watch technique to use.\n */\nclass WatchDetector {\n  constructor(options) {\n    this.childProcess = options.childProcess;\n    this.watchmanSupportsPlatform = options.watchmanSupportsPlatform;\n    this.fs = options.fs;\n    this.root = options.root;\n\n    this.ui = options.ui;\n    this.tmp = undefined;\n\n    // This exists, because during tests repeadelty testing the same directories\n    this._doesNodeWorkCache = options.cache || {};\n  }\n\n  /*\n   * @private\n   *\n   * implements input options parsing and fallback.\n   *\n   * @method extractPreferenceFromOptions\n   * @returns {WatchDetector)\n  */\n  extractPreferenceFromOptions(options) {\n    if (options.watcher === POLLING) {\n      debug.info('skip detecting watchman, \"polling\" was selected.');\n      return new WatchPreference(POLLING);\n    } else if (options.watcher === NODE) {\n      debug.info('skip detecting watchman, \"node\" was selected.');\n      return new WatchPreference(NODE);\n    } else {\n      debug.info('no watcher preference set, lets attempt watchman');\n      return new WatchPreference(WATCHMAN);\n    }\n  }\n\n  /*\n   * @public\n   *\n   * Detect if `fs.watch` provided by node is capable of observing a directory\n   * within `process.cwd()`. Although `fs.watch` is provided as a part of the\n   * node stdlib, their exists platforms it ships to that do not implement the\n   * required sub-system. For example, there exists `posix` targets, without both\n   * inotify and FSEvents\n   *\n   * @method testIfNodeWatcherAppearsToWork\n   * @returns {Boolean) outcome\n  */\n  testIfNodeWatcherAppearsToWork() {\n    let root = this.root;\n    if (root in this._doesNodeWorkCache) {\n      return this._doesNodeWorkCache[root];\n    }\n\n    this._doesNodeWorkCache[root] = false;\n    try {\n      // builds a tmp directory at process.cwd() + '/tmp/' + 'something-unique';\n      let tmpDir = quickTemp.makeOrRemake(this, 'tmp');\n\n      let watcher = this.fs.watch(tmpDir, { persistent: false, recursive: false });\n      watcher.close();\n    } catch (e) {\n      debug.info('testing if node watcher failed with: %o', e);\n      return false;\n    } finally {\n      try {\n        quickTemp.remove(this, 'tmp');\n        // cleanup dir\n      } catch (e) {\n        // not much we can do, lets debug log.\n        debug.info('cleaning up dir failed with: %o', e);\n      }\n    }\n\n    // it seems we where able to at least watch and unwatch, this should catch\n    // systems that have a very broken NodeWatcher.\n    //\n    // NOTE: we could also add a more advance chance, that triggers a change\n    // and expects to be informed of the change. This can be added in a future\n    // iteration.\n    //\n\n    this._doesNodeWorkCache[root] = true;\n    return true;\n  }\n\n  /*\n   * @public\n   *\n   * Selecting the best watcher is complicated, this method (given a preference)\n   * will test and provide the best possible watcher available to the current\n   * system and project.\n   *\n   *\n   *  @method findBestWatcherOption\n   *  @input {Object} options\n   *  @returns {Object} watch preference\n  */\n  findBestWatcherOption(options) {\n    let preference = this.extractPreferenceFromOptions(options);\n    let original = options.watcher;\n\n    if (original && POSSIBLE_WATCHERS.indexOf(original) === -1) {\n      return Promise.reject(new SilentError(`Unknown Watcher: \\`${original}\\` supported watchers: [${POSSIBLE_WATCHERS.join(', ')}]`));\n    }\n\n    if (preference.watcher === WATCHMAN) {\n      preference = this.checkWatchman();\n    }\n\n    let bestOption = preference;\n    let actual;\n\n    if (bestOption.watcher === NODE) {\n      // although up to this point, we may believe Node is the best watcher\n      // this may not be true because:\n      // * not all platforms that run node, support node.watch\n      // * not all file systems support node watch\n      //\n      let appearsToWork = this.testIfNodeWatcherAppearsToWork();\n      actual = new WatchPreference(appearsToWork ? NODE : POLLING);\n    } else {\n      actual = bestOption;\n    }\n    debug.info('foundBestWatcherOption, preference was: %o, actual: %o', options, actual);\n    if (actual /* if no preference was initial set, don't bother informing the user */ &&\n      original /* if no original was set, the fallback is expected */ &&\n      actual.watcher !== original &&\n\n      // events represents either watcherman or node, but no preference\n      !(original === EVENTS && (actual.watcher === WATCHMAN || actual.watcher === NODE))) {\n      // if there was an initial preference, but we had to fall back inform the user.\n      this.ui.writeLine(`was unable to use: \"${original}\", fell back to: \"${actual.watcher}\"`);\n    }\n    return actual;\n  }\n\n  /*\n   * @public\n   *\n   * Although watchman may be selected, it may not work due to:\n   *\n   *  * invalid version\n   *  * it may be broken in detectable ways\n   *  * watchman executable may be something unexpected\n   *  * ???\n   *\n   *  @method checkWatchman\n   *  @returns {Object} watch preference + _watchmanInfo\n  */\n  checkWatchman() {\n    let result = new WatchPreference(null);\n\n    debug.info('execSync(\"watchman version\")');\n    try {\n      let output = this.childProcess.execSync('watchman version', { stdio: [] });\n      debug.info('watchman version STDOUT: %s', output);\n      let version;\n      try {\n        version = JSON.parse(output).version;\n      } catch (e) {\n        this.ui.writeLine('Looks like you have a different program called watchman.');\n        this.ui.writeLine(WATCHMAN_INFO);\n\n        result.watcher = NODE;\n        return result;\n      }\n\n      debug.info('detected watchman: %s', version);\n\n      if (semver.satisfies(version, '>= 3.0.0')) {\n        debug.info('watchman %s does satisfy: %s', version, '>= 3.0.0');\n\n        result.watcher = WATCHMAN;\n\n        result.watchmanWorks({\n          version,\n          canNestRoots: semver.satisfies(version, '>= 3.7.0'),\n        });\n      } else {\n        debug.info('watchman %s does NOT satisfy: %s', version, '>= 3.0.0');\n\n        this.ui.writeLine(`Invalid watchman found, version: [${version}] did not satisfy [>= 3.0.0].`);\n        this.ui.writeLine(WATCHMAN_INFO);\n\n        result.watcher = NODE;\n      }\n\n      return result;\n    } catch (reason) {\n      debug.info('detecting watchman failed %o', reason);\n\n      if (this.watchmanSupportsPlatform) {\n        // don't bother telling windows users watchman detection failed, that is\n        // until watchman is legit on windows.\n      } else {\n        this.ui.writeLine('Could not start watchman');\n        this.ui.writeLine(WATCHMAN_INFO);\n      }\n\n      result.watcher = NODE;\n      return result;\n    }\n  }\n}\n\nmodule.exports = WatchDetector;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/get-option-args.js":"'use strict';\n\nmodule.exports = function(option, commandArgs) {\n  let results = [], value, i;\n  let optionIndex = commandArgs.indexOf(option);\n  if (optionIndex === -1) { return results; }\n\n  for (i = optionIndex + 1; i < commandArgs.length; i++) {\n    value = commandArgs[i];\n    if (/^\\-+/.test(value)) { break; }\n    results.push(value);\n  }\n\n  return results;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/addon.js":"'use strict';\n\nconst NewCommand = require('./new');\n\nmodule.exports = NewCommand.extend({\n  name: 'addon',\n  description: 'Generates a new folder structure for building an addon, complete with test harness.',\n\n  availableOptions: [\n    { name: 'dry-run',    type: Boolean, default: false,   aliases: ['d'] },\n    { name: 'verbose',    type: Boolean, default: false,   aliases: ['v'] },\n    { name: 'blueprint',  type: String,  default: 'addon', aliases: ['b'] },\n    { name: 'skip-npm',   type: Boolean, default: false,   aliases: ['sn'] },\n    { name: 'skip-bower', type: Boolean, default: false,   aliases: ['sb'] },\n    { name: 'skip-git',   type: Boolean, default: false,   aliases: ['sg'] },\n    { name: 'directory',  type: String,                    aliases: ['dir'] },\n  ],\n\n  anonymousOptions: [\n    '<addon-name>',\n  ],\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/new.js":"'use strict';\n\nconst fs = require('fs-extra');\nconst chalk = require('chalk');\nconst Command = require('../models/command');\nconst RSVP = require('rsvp');\nconst Project = require('../models/project');\nconst SilentError = require('silent-error');\nconst validProjectName = require('../utilities/valid-project-name');\nconst normalizeBlueprint = require('../utilities/normalize-blueprint-option');\nconst mergeBlueprintOptions = require('../utilities/merge-blueprint-options');\n\nconst rmdir = RSVP.denodeify(fs.remove);\nconst Promise = RSVP.Promise;\n\nmodule.exports = Command.extend({\n  name: 'new',\n  description: `Creates a new directory and runs ${chalk.green('ember init')} in it.`,\n  works: 'outsideProject',\n\n  availableOptions: [\n    { name: 'dry-run',    type: Boolean, default: false, aliases: ['d'] },\n    { name: 'verbose',    type: Boolean, default: false, aliases: ['v'] },\n    { name: 'blueprint',  type: String,  default: 'app', aliases: ['b'] },\n    { name: 'skip-npm',   type: Boolean, default: false, aliases: ['sn'] },\n    { name: 'skip-bower', type: Boolean, default: false, aliases: ['sb'] },\n    { name: 'skip-git',   type: Boolean, default: false, aliases: ['sg'] },\n    { name: 'directory',  type: String,                  aliases: ['dir'] },\n  ],\n\n  anonymousOptions: [\n    '<app-name>',\n  ],\n\n  beforeRun: mergeBlueprintOptions,\n\n  run(commandOptions, rawArgs) {\n    let packageName = rawArgs[0],\n        message;\n\n    commandOptions.name = rawArgs.shift();\n\n    if (!packageName) {\n      message = chalk.yellow(`The \\`ember ${this.name}\\` command requires a name to be specified. For more details, use \\`ember help\\`.`);\n\n      return Promise.reject(new SilentError(message));\n    }\n\n    if (commandOptions.dryRun) {\n      commandOptions.skipGit = true;\n    }\n\n    if (packageName === '.') {\n      let blueprintName = commandOptions.blueprint === 'app' ? 'application' : commandOptions.blueprint;\n      message = `Trying to generate an ${blueprintName} structure in this directory? Use \\`ember init\\` instead.`;\n\n      return Promise.reject(new SilentError(message));\n    }\n\n    if (!validProjectName(packageName)) {\n      message = `We currently do not support a name of \\`${packageName}\\`.`;\n\n      return Promise.reject(new SilentError(message));\n    }\n\n    commandOptions.blueprint = normalizeBlueprint(commandOptions.blueprint);\n\n    if (!commandOptions.directory) {\n      commandOptions.directory = packageName;\n    }\n\n    let createAndStepIntoDirectory = new this.tasks.CreateAndStepIntoDirectory({\n      ui: this.ui,\n      analytics: this.analytics,\n    });\n    let InitCommand = this.commands.Init;\n\n    let initCommand = new InitCommand({\n      ui: this.ui,\n      analytics: this.analytics,\n      tasks: this.tasks,\n      project: Project.nullProject(this.ui, this.cli),\n    });\n\n    return createAndStepIntoDirectory\n      .run({\n        directoryName: commandOptions.directory,\n        dryRun: commandOptions.dryRun,\n      })\n      .then(opts => {\n        initCommand.project.root = process.cwd();\n\n        return initCommand\n          .run(commandOptions, rawArgs)\n          .catch(err => {\n            let dirName = commandOptions.directory;\n            process.chdir(opts.initialDirectory);\n            return rmdir(dirName).then(() => {\n              console.log(chalk.red(`Error creating new application. Removing generated directory \\`./${dirName}\\``));\n              throw err;\n            });\n          });\n      });\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/valid-project-name.js":"'use strict';\n\nmodule.exports = function(name) {\n  name = name.toLowerCase();\n\n  if (['test', 'ember', 'ember-cli', 'vendor', 'app'].indexOf(name) > -1) { return false; }\n  if (name.indexOf('.') > -1) { return false; }\n  if (!isNaN(parseInt(name.charAt(0), 10))) { return false; }\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/normalize-blueprint-option.js":"'use strict';\n\nconst path = require('path');\n\nmodule.exports = function normalizeBlueprintOption(blueprint) {\n  return blueprint[0] === '.' ? path.resolve(process.cwd(), blueprint) : blueprint;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/merge-blueprint-options.js":"'use strict';\n\nconst SilentError = require('silent-error');\nconst Blueprint = require('../models/blueprint');\n\n/*\n * Helper for commands that use a blueprint to merge the blueprint's options\n * into the command's options so they can be passed in. Needs to be invoked\n * with `this` pointing to the command object, e.g.\n *\n * var mergeBlueprintOptions = require('../utilities/merge-blueprint-options');\n *\n * Command.extend({\n *   beforeRun: mergeBlueprintOptions\n * })\n */\nmodule.exports = function(rawArgs) {\n  if (rawArgs.length === 0) {\n    return;\n  }\n  // merge in blueprint availableOptions\n  let blueprint;\n  try {\n    blueprint = Blueprint.lookup(rawArgs[0], {\n      paths: this.project.blueprintLookupPaths(),\n    });\n    this.registerOptions(blueprint);\n  } catch (e) {\n    SilentError.debugOrThrow(`ember-cli/commands/${this.name}`, e);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/blueprint.js":"'use strict';\n\n/**\n@module ember-cli\n*/\nconst FileInfo = require('./file-info');\nconst RSVP = require('rsvp');\nconst chalk = require('chalk');\nconst MarkdownColor = require('../utilities/markdown-color');\nconst printableProperties = require('../utilities/printable-properties').blueprint;\nconst sequence = require('../utilities/sequence');\nconst printCommand = require('../utilities/print-command');\nconst insertIntoFile = require('../utilities/insert-into-file');\nconst cleanRemove = require('../utilities/clean-remove');\nconst fs = require('fs-extra');\nconst existsSync = require('exists-sync');\nconst inflector = require('inflection');\nconst minimatch = require('minimatch');\nconst path = require('path');\nconst stringUtils = require('ember-cli-string-utils');\nconst _ = require('ember-cli-lodash-subset');\nconst walkSync = require('walk-sync');\nconst SilentError = require('silent-error');\nconst CoreObject = require('core-object');\nconst EOL = require('os').EOL;\nconst bowEpParser = require('bower-endpoint-parser');\nlet logger = require('heimdalljs-logger')('ember-cli:blueprint');\nconst normalizeEntityName = require('ember-cli-normalize-entity-name');\n\nconst Promise = RSVP.Promise;\nconst stat = RSVP.denodeify(fs.stat);\nconst writeFile = RSVP.denodeify(fs.outputFile);\n\n/**\n  A blueprint is a bundle of template files with optional install\n  logic.\n\n  Blueprints follow a simple structure. Let's take the built-in\n  `controller` blueprint as an example:\n\n  ```\n  blueprints/controller\n  ├── files\n  │   ├── app\n  │   │   └── __path__\n  │   │       └── __name__.js\n  └── index.js\n\n  blueprints/controller-test\n  ├── files\n  │   └── tests\n  │       └── unit\n  │           └── controllers\n  │               └── __test__.js\n  └── index.js\n  ```\n\n  ## Files\n\n  `files` contains templates for the all the files to be\n  installed into the target directory.\n\n  The `__name__` token is subtituted with the dasherized\n  entity name at install time. For example, when the user\n  invokes `ember generate controller foo` then `__name__` becomes\n  `foo`. When the `--pod` flag is used, for example `ember\n  generate controller foo --pod` then `__name__` becomes\n  `controller`.\n\n  The `__path__` token is substituted with the blueprint\n  name at install time. For example, when the user invokes\n  `ember generate controller foo` then `__path__` becomes\n  `controller`. When the `--pod` flag is used, for example\n  `ember generate controller foo --pod` then `__path__`\n  becomes `foo` (or `<podModulePrefix>/foo` if the\n  podModulePrefix is defined). This token is primarily for\n  pod support, and is only necessary if the blueprint can be\n  used in pod structure. If the blueprint does not require pod\n  support, simply use the blueprint name instead of the\n  `__path__` token.\n\n  The `__test__` token is substituted with the dasherized\n  entity name and appended with `-test` at install time.\n  This token is primarily for pod support and only necessary\n  if the blueprint requires support for a pod structure. If\n  the blueprint does not require pod support, simply use the\n  `__name__` token instead.\n\n  ## Template Variables (AKA Locals)\n\n  Variables can be inserted into templates with\n  `<%= someVariableName %>`.\n\n  For example, the built-in `util` blueprint\n  `files/app/utils/__name__.js` looks like this:\n\n  ```js\n  export default function <%= camelizedModuleName %>() {\n    return true;\n  }\n  ```\n\n  `<%= camelizedModuleName %>` is replaced with the real\n  value at install time.\n\n  The following template variables are provided by default:\n\n  - `dasherizedPackageName`\n  - `classifiedPackageName`\n  - `dasherizedModuleName`\n  - `classifiedModuleName`\n  - `camelizedModuleName`\n\n  `packageName` is the project name as found in the project's\n  `package.json`.\n\n  `moduleName` is the name of the entity being generated.\n\n  The mechanism for providing custom template variables is\n  described below.\n\n  ## Index.js\n\n  Custom installation and uninstallation behaviour can be added\n  by overriding the hooks documented below. `index.js` should\n  export a plain object, which will extend the prototype of the\n  `Blueprint` class. If needed, the original `Blueprint` prototype\n  can be accessed through the `_super` property.\n\n  ```js\n  module.exports = {\n    locals: function(options) {\n      // Return custom template variables here.\n      return {};\n    },\n\n    normalizeEntityName: function(entityName) {\n      // Normalize and validate entity name here.\n      return entityName;\n    },\n\n    fileMapTokens: function(options) {\n      // Return custom tokens to be replaced in your files\n      return {\n        __token__: function(options){\n          // logic to determine value goes here\n          return 'value';\n        }\n      }\n    },\n\n    filesPath: function(options) {\n      return path.join(this.path, 'files');\n    },\n\n    beforeInstall: function(options) {},\n    afterInstall: function(options) {},\n    beforeUninstall: function(options) {},\n    afterUninstall: function(options) {}\n\n  };\n  ```\n\n  ## Blueprint Hooks\n\n  ### beforeInstall & beforeUninstall\n\n  Called before any of the template files are processed and receives\n  the the `options` and `locals` hashes as parameters. Typically used for\n  validating any additional command line options or for any asynchronous\n  setup that is needed.   As an example, the `controller` blueprint validates\n  its `--type` option in this hook.  If you need to run any asynchronous code,\n  wrap it in a promise and return that promise from these hooks.  This will\n  ensure that your code is executed correctly.\n\n  ### afterInstall & afterUninstall\n\n  The `afterInstall` and `afterUninstall` hooks receives the same\n  arguments as `locals`. Use it to perform any custom work after the\n  files are processed. For example, the built-in `route` blueprint\n  uses these hooks to add and remove relevant route declarations in\n  `app/router.js`.\n\n  ### Overriding Install\n\n  If you don't want your blueprint to install the contents of\n  `files` you can override the `install` method. It receives the\n  same `options` object described above and must return a promise.\n  See the built-in `resource` blueprint for an example of this.\n\n  @class Blueprint\n  @constructor\n  @extends CoreObject\n  @param {String} [blueprintPath]\n*/\nlet Blueprint = CoreObject.extend({\n  availableOptions: [],\n  anonymousOptions: ['name'],\n\n  init(blueprintPath) {\n    this._super();\n\n    this.path = blueprintPath;\n    this.name = path.basename(blueprintPath);\n  },\n\n  /**\n    Hook to specify the path to the blueprint's files. By default this is\n    `path.join(this.path, 'files)`.\n\n    This can be used to customize which set of files to install based on options\n    or environmental variables. It defaults to the `files` directory within the\n    blueprint's folder.\n\n    @public\n    @method filesPath\n    @param {Object} options\n    @return {String} Path to the blueprints files directory.\n  */\n  filesPath(/* options */) {\n    return path.join(this.path, 'files');\n  },\n\n  /**\n    Used to retrieve files for blueprint.\n\n    @method files\n    @return {Array} Contents of the blueprint's files directory\n  */\n  files() {\n    if (this._files) { return this._files; }\n\n    let filesPath = this.filesPath(this.options);\n    if (existsSync(filesPath)) {\n      this._files = walkSync(filesPath);\n    } else {\n      this._files = [];\n    }\n\n    return this._files;\n  },\n\n  /**\n    @method srcPath\n    @param {String} file\n    @return {String} Resolved path to the file\n  */\n  srcPath(file) {\n    return path.resolve(this.filesPath(this.options), file);\n  },\n\n  /**\n    Hook for normalizing entity name\n\n    Use the `normalizeEntityName` hook to add custom normalization and\n    validation of the provided entity name. The default hook does not\n    make any changes to the entity name, but makes sure an entity name\n    is present and that it doesn't have a trailing slash.\n\n    This hook receives the entity name as its first argument. The string\n    returned by this hook will be used as the new entity name.\n\n    @public\n    @method normalizeEntityName\n    @param {String} entityName\n    @return {null}\n  */\n  normalizeEntityName(entityName) {\n    return normalizeEntityName(entityName);\n  },\n\n  /**\n    Write a status and message to the UI\n    @private\n    @method _writeStatusToUI\n    @param {Function} chalkColor\n    @param {String} keyword\n    @param {String} message\n  */\n  _writeStatusToUI(chalkColor, keyword, message) {\n    if (this.ui) {\n      this.ui.writeLine(`  ${chalkColor(keyword)} ${message}`);\n    }\n  },\n\n  /**\n    @private\n    @method _writeFile\n    @param {Object} info\n    @return {Promise}\n  */\n  _writeFile(info) {\n    if (!this.dryRun) {\n      return writeFile(info.outputPath, info.render());\n    }\n  },\n\n  /**\n    Actions lookup\n    @private\n    @property _actions\n    @type Object\n  */\n  _actions: {\n    write(info) {\n      this._writeStatusToUI(chalk.green, 'create', info.displayPath);\n      return this._writeFile(info);\n    },\n    skip(info) {\n      let label = 'skip';\n\n      if (info.resolution === 'identical') {\n        label = 'identical';\n      }\n\n      this._writeStatusToUI(chalk.yellow, label, info.displayPath);\n    },\n\n    overwrite(info) {\n      this._writeStatusToUI(chalk.yellow, 'overwrite', info.displayPath);\n      return this._writeFile(info);\n    },\n\n    edit(info) {\n      this._writeStatusToUI(chalk.green, 'edited', info.displayPath);\n    },\n\n    remove(info) {\n      this._writeStatusToUI(chalk.red, 'remove', info.displayPath);\n      if (!this.dryRun) {\n        return cleanRemove(info);\n      }\n    },\n  },\n\n  /**\n    Calls an action.\n    @private\n    @method _commit\n    @param {Object} result\n    @return {Promise}\n    @throws {Error} Action doesn't exist.\n  */\n  _commit(result) {\n    let action = this._actions[result.action];\n\n    if (action) {\n      return action.call(this, result);\n    } else {\n      throw new Error(`Tried to call action \\\"${result.action}\\\" but it does not exist`);\n    }\n  },\n\n  /**\n    Prints warning for pod unsupported.\n    @private\n    @method _checkForPod\n  */\n  _checkForPod(verbose) {\n    if (!this.hasPathToken && this.pod && verbose) {\n      this.ui.writeLine(chalk.yellow('You specified the pod flag, but this' +\n        ' blueprint does not support pod structure. It will be generated with' +\n        ' the default structure.'));\n    }\n  },\n\n  /**\n    @private\n    @method _normalizeEntityName\n    @param {Object} entity\n  */\n  _normalizeEntityName(entity) {\n    if (entity) {\n      entity.name = this.normalizeEntityName(entity.name);\n    }\n  },\n\n  /**\n    @private\n    @method _checkInRepoAddonExists\n    @param {String} inRepoAddon\n  */\n  _checkInRepoAddonExists(inRepoAddon) {\n    if (inRepoAddon) {\n      if (!inRepoAddonExists(inRepoAddon, this.project.root)) {\n        throw new SilentError(`You specified the in-repo-addon flag, but the ` +\n          `in-repo-addon '${inRepoAddon}' does not exist. Please check the name and try again.`);\n      }\n    }\n  },\n\n  /**\n    @private\n    @method _process\n    @param {Object} options\n    @param {Function} beforeHook\n    @param {Function} process\n    @param {Function} afterHook\n  */\n  _process(options, beforeHook, process, afterHook) {\n    let self = this;\n    let intoDir = options.target;\n\n    return this._locals(options)\n      .then(locals => Promise.resolve()\n        .then(beforeHook.bind(self, options, locals))\n        .then(process.bind(self, intoDir, locals))\n        .then(promises => RSVP.map(promises, self._commit.bind(self)))\n        .then(afterHook.bind(self, options)));\n  },\n\n  /**\n    @method install\n    @param {Object} options\n    @return {Promise}\n  */\n  install(options) {\n    let ui = this.ui = options.ui;\n    let dryRun = this.dryRun = options.dryRun;\n    this.project = options.project;\n    this.pod = options.pod;\n    this.options = options;\n    this.hasPathToken = hasPathToken(this.files());\n\n    podDeprecations(this.project.config(), ui);\n\n    ui.writeLine(`installing ${this.name}`);\n\n    if (dryRun) {\n      ui.writeLine(chalk.yellow('You specified the dry-run flag, so no' +\n        ' changes will be written.'));\n    }\n\n    this._normalizeEntityName(options.entity);\n    this._checkForPod(options.verbose);\n    this._checkInRepoAddonExists(options.inRepoAddon);\n\n    logger.info('START: processing blueprint: `%s`', this.name);\n    let start = new Date();\n    return this._process(options, this.beforeInstall, this.processFiles, this.afterInstall)\n      .finally(() => logger.info('END: processing blueprint: `%s` in (%dms)', this.name, new Date() - start));\n  },\n\n  /**\n    @method uninstall\n    @param {Object} options\n    @return {Promise}\n  */\n  uninstall(options) {\n    let ui = this.ui = options.ui;\n    let dryRun = this.dryRun = options.dryRun;\n    this.project = options.project;\n    this.pod = options.pod;\n    this.options = options;\n    this.hasPathToken = hasPathToken(this.files());\n\n    podDeprecations(this.project.config(), ui);\n\n    ui.writeLine(`uninstalling ${this.name}`);\n\n    if (dryRun) {\n      ui.writeLine(chalk.yellow('You specified the dry-run flag, so no' +\n        ' files will be deleted.'));\n    }\n\n    this._normalizeEntityName(options.entity);\n    this._checkForPod(options.verbose);\n\n    return this._process(\n      options,\n      this.beforeUninstall,\n      this.processFilesForUninstall,\n      this.afterUninstall);\n  },\n\n  /**\n    Hook for running operations before install.\n    @method beforeInstall\n    @return {Promise|null}\n  */\n  beforeInstall() {},\n\n  /**\n    Hook for running operations after install.\n    @method afterInstall\n    @return {Promise|null}\n  */\n  afterInstall() {},\n\n  /**\n    Hook for running operations before uninstall.\n    @method beforeUninstall\n    @return {Promise|null}\n  */\n  beforeUninstall() {},\n\n  /**\n    Hook for running operations after uninstall.\n    @method afterUninstall\n    @return {Promise|null}\n  */\n  afterUninstall() {},\n\n  /**\n    Hook for adding custom template variables.\n\n    When the following is called on the command line:\n\n    ```sh\n    ember generate controller foo --type=array --dry-run\n    ```\n\n    The object passed to `locals` looks like this:\n\n    ```js\n    {\n      entity: {\n        name: 'foo',\n        options: {\n          type: 'array'\n        }\n      },\n      dryRun: true\n    }\n    ```\n\n    This hook must return an object or a Promise which resolves to an object.\n    The resolved object will be merged with the aforementioned default locals.\n\n    @public\n    @method locals\n    @param {Object} options General and entity-specific options\n    @return {Object|Promise|null}\n  */\n  locals(/* options */) {},\n\n  /**\n    Hook to add additional or override existing fileMap tokens.\n\n    Use `fileMapTokens` to add custom fileMap tokens for use\n    in the `mapFile` method. The hook must return an object in the\n    following pattern:\n\n    ```js\n    {\n      __token__: function(options){\n        // logic to determine value goes here\n        return 'value';\n      }\n    }\n    ```\n\n    It will be merged with the default `fileMapTokens`, and can be used\n    to override any of the default tokens.\n\n    Tokens are used in the files folder (see `files`), and get replaced with\n    values when the `mapFile` method is called.\n\n    @public\n    @method fileMapTokens\n    @return {Object|null}\n  */\n  fileMapTokens() {},\n\n  /**\n    @private\n    @method _fileMapTokens\n    @param {Object} options\n    @return {Object}\n  */\n  _fileMapTokens(options) {\n    let standardTokens = {\n      __name__(options) {\n        if (options.pod && options.hasPathToken) {\n          return options.blueprintName;\n        }\n        return options.dasherizedModuleName;\n      },\n      __path__(options) {\n        let blueprintName = options.blueprintName;\n\n        if (blueprintName.match(/-test/)) {\n          blueprintName = options.blueprintName.slice(0, options.blueprintName.indexOf('-test'));\n        }\n        if (options.pod && options.hasPathToken) {\n          return path.join(options.podPath, options.dasherizedModuleName);\n        }\n        return inflector.pluralize(blueprintName);\n      },\n      __root__(options) {\n        if (options.inRepoAddon) {\n          return path.join('lib', options.inRepoAddon, 'addon');\n        }\n        if (options.inDummy) {\n          return path.join('tests', 'dummy', 'app');\n        }\n        if (options.inAddon) {\n          return 'addon';\n        }\n        return 'app';\n      },\n      __test__(options) {\n        if (options.pod && options.hasPathToken) {\n          return options.blueprintName;\n        }\n        return `${options.dasherizedModuleName}-test`;\n      },\n    };\n\n    let customTokens = this.fileMapTokens(options) || options.fileMapTokens || {};\n    return _.merge(standardTokens, customTokens);\n  },\n\n  /**\n    Used to generate fileMap tokens for mapFile.\n\n    @method generateFileMap\n    @param {Object} fileMapVariables\n    @return {Object}\n  */\n  generateFileMap(fileMapVariables) {\n    let tokens = this._fileMapTokens(fileMapVariables);\n    let fileMapValues = _.values(tokens);\n    let tokenValues = fileMapValues.map(token => token(fileMapVariables));\n    let tokenKeys = _.keys(tokens);\n    return _.zipObject(tokenKeys, tokenValues);\n  },\n\n  /**\n    @method buildFileInfo\n    @param {Function} destPath\n    @param {Object} templateVariables\n    @param {String} file\n    @return {FileInfo}\n  */\n  buildFileInfo(intoDir, templateVariables, file) {\n    let mappedPath = this.mapFile(file, templateVariables);\n\n    return new FileInfo({\n      action: 'write',\n      outputBasePath: path.normalize(intoDir),\n      outputPath: path.join(intoDir, mappedPath),\n      displayPath: path.normalize(mappedPath),\n      inputPath: this.srcPath(file),\n      templateVariables,\n      ui: this.ui,\n    });\n  },\n\n  /**\n    @method isUpdate\n    @return {Boolean}\n  */\n  isUpdate() {\n    if (this.project && this.project.isEmberCLIProject) {\n      return this.project.isEmberCLIProject();\n    }\n  },\n\n  /**\n    @private\n    @method _getFileInfos\n    @param {Array} files\n    @param {String} intoDir\n    @param {Object} templateVariables\n    @return {Array} file infos\n  */\n  _getFileInfos(files, intoDir, templateVariables) {\n    return files.map(this.buildFileInfo.bind(this, intoDir, templateVariables));\n  },\n\n  /**\n    Add update files to ignored files\n    @private\n    @method _ignoreUpdateFiles\n  */\n  _ignoreUpdateFiles() {\n    if (this.isUpdate()) {\n      Blueprint.ignoredFiles = Blueprint.ignoredFiles.concat(Blueprint.ignoredUpdateFiles);\n    }\n  },\n\n  /**\n    @private\n    @method _getFilesForInstall\n    @param {Array} targetFiles\n    @return {Array} files\n  */\n  _getFilesForInstall(targetFiles) {\n    let files = this.files();\n\n    // if we've defined targetFiles, get file info on ones that match\n    return (targetFiles && targetFiles.length > 0 && _.intersection(files, targetFiles)) || files;\n  },\n\n  /**\n    @private\n    @method _checkForNoMatch\n    @param {Array} fileInfos\n    @param {String} rawArgs\n  */\n  _checkForNoMatch(fileInfos, rawArgs) {\n    if (fileInfos.filter(isFilePath).length < 1 && rawArgs) {\n      this.ui.writeLine(chalk.yellow(`The globPattern \"${rawArgs}\" ` +\n        `did not match any files, so no file updates will be made.`));\n    }\n  },\n\n  /**\n    @method processFiles\n    @param {String} intoDir\n    @param {Object} templateVariables\n  */\n  processFiles(intoDir, templateVariables) {\n    let files = this._getFilesForInstall(templateVariables.targetFiles);\n    let fileInfos = this._getFileInfos(files, intoDir, templateVariables);\n    this._checkForNoMatch(fileInfos, templateVariables.rawArgs);\n\n    this._ignoreUpdateFiles();\n\n    return RSVP.filter(fileInfos, isValidFile)\n      .then(promises => RSVP.map(promises, prepareConfirm))\n      .then(finishProcessingForInstall);\n  },\n\n  /**\n    @method processFilesForUninstall\n    @param {String} intoDir\n    @param {Object} templateVariables\n  */\n  processFilesForUninstall(intoDir, templateVariables) {\n    let fileInfos = this._getFileInfos(this.files(), intoDir, templateVariables);\n\n    this._ignoreUpdateFiles();\n\n    return RSVP.filter(fileInfos, isValidFile).\n      then(finishProcessingForUninstall);\n  },\n\n\n  /**\n    @method mapFile\n    @param {String} file\n    @param locals\n    @return {String}\n  */\n  mapFile(file, locals) {\n    let pattern, i;\n    let fileMap = locals.fileMap || { __name__: locals.dasherizedModuleName };\n    file = Blueprint.renamedFiles[file] || file;\n    for (i in fileMap) {\n      pattern = new RegExp(i, 'g');\n      file = file.replace(pattern, fileMap[i]);\n    }\n    return file;\n  },\n\n  /**\n    Looks for a __root__ token in the files folder. Must be present for\n    the blueprint to support addon tokens. The `server`, `blueprints`, and `test`\n\n    @private\n    @method supportsAddon\n    @return {Boolean}\n  */\n  supportsAddon() {\n    return !!this.files().join().match(/__root__/);\n  },\n\n  /**\n    @private\n    @method _generateFileMapVariables\n    @param {String} moduleName\n    @param locals\n    @param {Object} options\n    @return {Object}\n  */\n  _generateFileMapVariables(moduleName, locals, options) {\n    let originBlueprintName = options.originBlueprintName || this.name;\n    let podModulePrefix = this.project.config().podModulePrefix || '';\n    let podPath = podModulePrefix.substr(podModulePrefix.lastIndexOf('/') + 1);\n    let inAddon = this.project.isEmberCLIAddon() || !!options.inRepoAddon;\n    let inDummy = this.project.isEmberCLIAddon() ? options.dummy : false;\n\n    return {\n      pod: this.pod,\n      podPath,\n      hasPathToken: this.hasPathToken,\n      inAddon,\n      inRepoAddon: options.inRepoAddon,\n      inDummy,\n      blueprintName: this.name,\n      originBlueprintName,\n      dasherizedModuleName: stringUtils.dasherize(moduleName),\n      locals,\n    };\n  },\n\n  /**\n    @private\n    @method _locals\n    @param {Object} options\n    @return {Object}\n  */\n  _locals(options) {\n    let packageName = options.project.name();\n    let moduleName = (options.entity && options.entity.name) || packageName;\n    let sanitizedModuleName = moduleName.replace(/\\//g, '-');\n\n    return new Promise(resolve => {\n      resolve(this.locals(options));\n    }).then(customLocals => {\n      let fileMapVariables = this._generateFileMapVariables(moduleName, customLocals, options);\n      let fileMap = this.generateFileMap(fileMapVariables);\n      let standardLocals = {\n        dasherizedPackageName: stringUtils.dasherize(packageName),\n        classifiedPackageName: stringUtils.classify(packageName),\n        dasherizedModuleName: stringUtils.dasherize(moduleName),\n        classifiedModuleName: stringUtils.classify(sanitizedModuleName),\n        camelizedModuleName: stringUtils.camelize(sanitizedModuleName),\n        decamelizedModuleName: stringUtils.decamelize(sanitizedModuleName),\n        fileMap,\n        hasPathToken: this.hasPathToken,\n        targetFiles: options.targetFiles,\n        rawArgs: options.rawArgs,\n      };\n\n      return _.merge({}, standardLocals, customLocals);\n    });\n  },\n\n  /**\n    Used to add a package to the project's `package.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    @method addPackageToProject\n    @param {String} packageName\n    @param {String} target\n    @return {Promise}\n  */\n  addPackageToProject(packageName, target) {\n    let packageObject = { name: packageName };\n\n    if (target) {\n      packageObject.target = target;\n    }\n\n    return this.addPackagesToProject([packageObject]);\n  },\n\n  /**\n    Used to add multiple packages to the project's `package.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    Expects each array item to be an object with a `name`.  Each object\n    may optionally have a `target` to specify a specific version.\n\n    @method addPackagesToProject\n    @param {Array} packages\n    @return {Promise}\n  */\n  addPackagesToProject(packages) {\n    let task = this.taskFor('npm-install');\n    let installText = (packages.length > 1) ? 'install packages' : 'install package';\n    let packageNames = [];\n    let packageArray = [];\n\n    for (let i = 0; i < packages.length; i++) {\n      packageNames.push(packages[i].name);\n\n      let packageNameAndVersion = packages[i].name;\n\n      if (packages[i].target) {\n        packageNameAndVersion += `@${packages[i].target}`;\n      }\n\n      packageArray.push(packageNameAndVersion);\n    }\n\n    this._writeStatusToUI(chalk.green, installText, packageNames.join(', '));\n\n    return task.run({\n      'save-dev': true,\n      verbose: false,\n      packages: packageArray,\n    });\n  },\n\n  /**\n    Used to remove a package from the project's `package.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that any package conflicts can be resolved before the\n    addon is used.\n\n    @method removePackageFromProject\n    @param {String} packageName\n    @return {Promise}\n  */\n  removePackageFromProject(packageName) {\n    let packageObject = { name: packageName };\n\n    return this.removePackagesFromProject([packageObject]);\n  },\n\n  /**\n    Used to remove multiple packages from the project's `package.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that any package conflicts can be resolved before the\n    addon is used.\n\n    Expects each array item to be an object with a `name` property.\n\n    @method removePackagesFromProject\n    @param {Array} packages\n    @return {Promise}\n  */\n  removePackagesFromProject(packages) {\n    let task = this.taskFor('npm-uninstall');\n    let installText = (packages.length > 1) ? 'uninstall packages' : 'uninstall package';\n    let packageNames = [];\n    let packageArray = [];\n\n    for (let i = 0; i < packages.length; i++) {\n      packageNames.push(packages[i].name);\n\n      let packageNameAndVersion = packages[i].name;\n\n      packageArray.push(packageNameAndVersion);\n    }\n\n    this._writeStatusToUI(chalk.green, installText, packageNames.join(', '));\n\n    return task.run({\n      'save-dev': true,\n      verbose: false,\n      packages: packageArray,\n    });\n  },\n\n  /**\n    Used to add a package to the projects `bower.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    `localPackageName` and `target` may be thought of as equivalent\n    to the key-value pairs in the `dependency` or `devDepencency`\n    objects contained within a bower.json file.\n    @method addBowerPackageToProject\n    @param {String} localPackageName\n    @param {String} target\n    @param {Object} installOptions\n    @return {Promise}\n\n    @example\n    ```js\n    addBowerPackageToProject('jquery', '~1.11.1');\n    addBowerPackageToProject('old_jquery', 'jquery#~1.9.1');\n    addBowerPackageToProject('bootstrap-3', 'https://twitter.github.io/bootstrap/assets/bootstrap');\n    ```\n  */\n  addBowerPackageToProject(localPackageName, target, installOptions) {\n    let lpn = localPackageName;\n    let tar = target;\n    if (localPackageName.indexOf('#') >= 0) {\n      if (arguments.length === 1) {\n        let parts = localPackageName.split('#');\n        lpn = parts[0];\n        tar = parts[1];\n        this.ui.writeDeprecateLine(`passing ${localPackageName} directly to \\`addBowerPackageToProject\\` will soon be unsupported.\\n` +\n          `You may want to replace this with \\`addBowerPackageToProject('${lpn}', '${tar}')\\``);\n      } else {\n        this.ui.writeDeprecateLine(`passing ${localPackageName} directly to \\`addBowerPackageToProject\\` will soon be unsupported`);\n      }\n    }\n    let packageObject = bowEpParser.json2decomposed(lpn, tar);\n    return this.addBowerPackagesToProject([packageObject], installOptions);\n  },\n\n  /**\n    Used to add an array of packages to the projects `bower.json`.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    Expects each array item to be an object with a `name`.  Each object\n    may optionally have a `target` to specify a specific version, or a\n    `source` to specify a non-local name to be resolved.\n\n    @method addBowerPackagesToProject\n    @param {Array} packages\n    @param {Object} installOptions\n    @return {Promise}\n  */\n  addBowerPackagesToProject(packages, installOptions) {\n    let task = this.taskFor('bower-install');\n    let installText = (packages.length > 1) ? 'install bower packages' : 'install bower package';\n    let packageNames = [];\n    let packageNamesAndVersions = packages.map(pkg => {\n      pkg.source = pkg.source || pkg.name;\n      packageNames.push(pkg.name);\n      return pkg;\n    }).map(bowEpParser.compose);\n\n    this._writeStatusToUI(chalk.green, installText, packageNames.join(', '));\n\n    return task.run({\n      verbose: true,\n      packages: packageNamesAndVersions,\n      installOptions: installOptions || { save: true },\n    });\n  },\n\n  /**\n    Used to add an addon to the project's `package.json` and run it's\n    `defaultBlueprint` if it provides one.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    @method addAddonToProject\n    @param {Object} options\n    @return {Promise}\n  */\n  addAddonToProject(options) {\n    return this.addAddonsToProject({\n      packages: [options],\n      extraArgs: options.extraArgs || {},\n      blueprintOptions: options.blueprintOptions || {},\n    });\n  },\n\n  /**\n    Used to add multiple addons to the project's `package.json` and run their\n    `defaultBlueprint` if they provide one.\n\n    Generally, this would be done from the `afterInstall` hook, to\n    ensure that a package that is required by a given blueprint is\n    available.\n\n    @method addAddonsToProject\n    @param {Object} options\n    @return {Promise}\n  */\n  addAddonsToProject(options) {\n    let taskOptions = {\n      packages: [],\n      extraArgs: options.extraArgs || [],\n      blueprintOptions: options.blueprintOptions || {},\n    };\n\n    let packages = options.packages;\n    if (packages && packages.length) {\n      taskOptions.packages = packages.map(pkg => {\n        if (typeof pkg === 'string') {\n          return pkg;\n        }\n\n        if (!pkg.name) {\n          throw new SilentError('You must provide a package `name` to addAddonsToProject');\n        }\n\n        if (pkg.target) {\n          pkg.name += `@${pkg.target}`;\n        }\n\n        return pkg.name;\n      });\n    } else {\n      throw new SilentError('You must provide package to addAddonsToProject');\n    }\n\n    let installText = (packages.length > 1) ? 'install addons' : 'install addon';\n    this._writeStatusToUI(chalk.green, installText, taskOptions['packages'].join(', '));\n\n    return this.taskFor('addon-install').run(taskOptions);\n  },\n\n  /**\n    Used to retrieve a task with the given name. Passes the new task\n    the standard information available (like `ui`, `analytics`, `project`, etc).\n\n    @method taskFor\n    @param dasherizedName\n    @public\n  */\n  taskFor(dasherizedName) {\n    const Task = require(`../tasks/${dasherizedName}`);\n\n    return new Task({\n      ui: this.ui,\n      project: this.project,\n      analytics: this.analytics,\n    });\n  },\n\n  /**\n    Inserts the given content into a file. If the `contentsToInsert` string is already\n    present in the current contents, the file will not be changed unless `force` option\n    is passed.\n\n    If `options.before` is specified, `contentsToInsert` will be inserted before\n    the first instance of that string.  If `options.after` is specified, the\n    contents will be inserted after the first instance of that string.\n    If the string specified by options.before or options.after is not in the file,\n    no change will be made.\n\n    If neither `options.before` nor `options.after` are present, `contentsToInsert`\n    will be inserted at the end of the file.\n\n    Example:\n    ```\n    // app/router.js\n    Router.map(function() {\n    });\n    ```\n\n    ```\n    insertIntoFile('app/router.js', '  this.route(\"admin\");', {\n      after: 'Router.map(function() {' + EOL\n    }).then(function() {\n      // file has been inserted into!\n    });\n\n\n    ```\n\n    ```\n    // app/router.js\n    Router.map(function() {\n      this.route(\"admin\");\n    });\n    ```\n\n    @method insertIntoFile\n    @param {String} pathRelativeToProjectRoot\n    @param {String} contentsToInsert\n    @param {Object} providedOptions\n    @return {Promise}\n  */\n  insertIntoFile(pathRelativeToProjectRoot, contentsToInsert, providedOptions) {\n    let fullPath = path.join(this.project.root, pathRelativeToProjectRoot);\n    return insertIntoFile(fullPath, contentsToInsert, providedOptions);\n  },\n\n  _printCommand: printCommand,\n\n  printBasicHelp(verbose) {\n    let initialMargin = '      ';\n    let output = initialMargin;\n    if (this.overridden) {\n      output += chalk.grey(`(overridden) ${this.name}`);\n    } else {\n      output += this.name;\n\n      output += this._printCommand(initialMargin, true);\n\n      if (verbose) {\n        output += EOL + this.printDetailedHelp(this.availableOptions);\n      }\n    }\n\n    return output;\n  },\n\n  printDetailedHelp() {\n    let markdownColor = new MarkdownColor();\n    let filePath = getDetailedHelpPath(this.path);\n\n    if (existsSync(filePath)) {\n      return markdownColor.renderFile(filePath, { indent: '        ' });\n    }\n    return '';\n  },\n\n  getJson(verbose) {\n    let json = {};\n\n    printableProperties.forEachWithProperty(function(key) {\n      let value = this[key];\n      if (key === 'availableOptions') {\n        value = _.cloneDeep(value);\n        value.forEach(option => {\n          if (typeof option.type === 'function') {\n            option.type = option.type.name;\n          }\n        });\n      }\n      json[key] = value;\n    }, this);\n\n    if (verbose) {\n      let detailedHelp = this.printDetailedHelp(this.availableOptions);\n      if (detailedHelp) {\n        json.detailedHelp = detailedHelp;\n      }\n    }\n\n    return json;\n  },\n\n  /**\n    Used to retrieve a blueprint with the given name.\n\n    @method lookupBlueprint\n    @param {String} dasherizedName\n    @return {Blueprint}\n    @public\n  */\n  lookupBlueprint(dasherizedName) {\n    let projectPaths = this.project ? this.project.blueprintLookupPaths() : [];\n\n    return Blueprint.lookup(dasherizedName, {\n      paths: projectPaths,\n    });\n  },\n});\n\n/**\n  @static\n  @method lookup\n  @namespace Blueprint\n  @param {String} name\n  @param {Object} [options]\n  @param {Array} [options.paths] Extra paths to search for blueprints\n  @param {Boolean} [options.ignoreMissing] Throw a `SilentError` if a\n    matching Blueprint could not be found\n  @return {Blueprint}\n*/\nBlueprint.lookup = function(name, options) {\n  options = options || {};\n\n  let lookupPaths = generateLookupPaths(options.paths);\n\n  let lookupPath;\n  for (let i = 0; (lookupPath = lookupPaths[i]); i++) {\n    let blueprintPath = path.resolve(lookupPath, name);\n\n    if (existsSync(blueprintPath)) {\n      return Blueprint.load(blueprintPath);\n    }\n  }\n\n  if (!options.ignoreMissing) {\n    throw new SilentError(`Unknown blueprint: ${name}`);\n  }\n};\n\n/**\n  Loads a blueprint from given path.\n  @static\n  @method load\n  @namespace Blueprint\n  @param {String} blueprintPath\n  @return {Blueprint} blueprint instance\n*/\nBlueprint.load = function(blueprintPath) {\n  if (fs.lstatSync(blueprintPath).isDirectory()) {\n    let Constructor = Blueprint;\n\n    let constructorPath = path.resolve(blueprintPath, 'index.js');\n    if (existsSync(constructorPath)) {\n      const blueprintModule = require(constructorPath);\n\n      if (typeof blueprintModule === 'function') {\n        Constructor = blueprintModule;\n      } else {\n        Constructor = Blueprint.extend(blueprintModule);\n      }\n    }\n\n    return new Constructor(blueprintPath);\n  }\n};\n\n/**\n  @static\n  @method list\n  @namespace Blueprint\n  @param {Object} [options]\n  @param {Array} [options.paths] Extra paths to search for blueprints\n  @return {Array}\n*/\nBlueprint.list = function(options) {\n  options = options || {};\n\n  let lookupPaths = generateLookupPaths(options.paths);\n  let seen = [];\n\n  return lookupPaths.map(lookupPath => {\n    let source;\n    let packagePath = path.join(lookupPath, '../package.json');\n    if (existsSync(packagePath)) {\n      source = require(packagePath).name;\n    } else {\n      source = path.basename(path.join(lookupPath, '..'));\n    }\n\n    let blueprints = dir(lookupPath).map(blueprintPath => {\n      let blueprint = Blueprint.load(blueprintPath);\n      if (blueprint) {\n        let name = blueprint.name;\n        blueprint.overridden = _.includes(seen, name);\n        seen.push(name);\n\n        return blueprint;\n      }\n    });\n\n    return {\n      source,\n      blueprints: _.compact(blueprints),\n    };\n  });\n};\n\n/**\n  Files that are renamed when installed into the target directory.\n  This allows including files in the blueprint that would have an effect\n  on another process, such as a file named `.gitignore`.\n\n  The keys are the filenames used in the files folder.\n  The values are the filenames used in the target directory.\n\n  @static\n  @property renamedFiles\n*/\nBlueprint.renamedFiles = {\n  'gitignore': '.gitignore',\n};\n\n/**\n  @static\n  @property ignoredFiles\n*/\nBlueprint.ignoredFiles = [\n  '.DS_Store',\n];\n\n/**\n  @static\n  @property ignoredUpdateFiles\n*/\nBlueprint.ignoredUpdateFiles = [\n  '.gitkeep',\n  'app.css',\n  'LICENSE.md',\n];\n\n/**\n  @static\n  @property defaultLookupPaths\n*/\nBlueprint.defaultLookupPaths = function() {\n  return [\n    path.resolve(__dirname, '..', '..', 'blueprints'),\n  ];\n};\n\n/**\n  @private\n  @method prepareConfirm\n  @param {FileInfo} info\n  @return {Promise}\n*/\nfunction prepareConfirm(info) {\n  return info.checkForConflict().then(resolution => {\n    info.resolution = resolution;\n    return info;\n  });\n}\n\n/**\n  @private\n  @method markIdenticalToBeSkipped\n  @param {FileInfo} info\n*/\nfunction markIdenticalToBeSkipped(info) {\n  if (info.resolution === 'identical') {\n    info.action = 'skip';\n  }\n}\n\n/**\n  @private\n  @method markToBeRemoved\n  @param {FileInfo} info\n*/\nfunction markToBeRemoved(info) {\n  info.action = 'remove';\n}\n\n/**\n  @private\n  @method gatherConfirmationMessages\n  @param {Array} collection\n  @param {FileInfo} info\n  @return {Array}\n*/\nfunction gatherConfirmationMessages(collection, info) {\n  if (info.resolution === 'confirm') {\n    collection.push(info.confirmOverwriteTask());\n  }\n  return collection;\n}\n\n/**\n  @private\n  @method isFile\n  @param {FileInfo} info\n  @return {Promise}\n*/\nfunction isFile(info) {\n  return stat(info.inputPath).then(it => it.isFile());\n}\n\n/**\n  @private\n  @method isIgnored\n  @param {FileInfo} info\n  @return {Boolean}\n*/\nfunction isIgnored(info) {\n  let fn = info.inputPath;\n\n  return _.any(Blueprint.ignoredFiles, ignoredFile => minimatch(fn, ignoredFile, { matchBase: true }));\n}\n\n/**\n  Combines provided lookup paths with defaults and removes\n  duplicates.\n\n  @private\n  @method generateLookupPaths\n  @param {Array} lookupPaths\n  @return {Array}\n*/\nfunction generateLookupPaths(lookupPaths) {\n  lookupPaths = lookupPaths || [];\n  lookupPaths = lookupPaths.concat(Blueprint.defaultLookupPaths());\n  return _.uniq(lookupPaths);\n}\n\n/**\n  Looks for a __path__ token in the files folder. Must be present for\n  the blueprint to support pod tokens.\n\n  @private\n  @method hasPathToken\n  @param {files} files\n  @return {Boolean}\n*/\nfunction hasPathToken(files) {\n  return files.join().match(/__path__/);\n}\n\nfunction inRepoAddonExists(name, root) {\n  let addonPath = path.join(root, 'lib', name);\n  return existsSync(addonPath);\n}\n\nfunction podDeprecations(config, ui) {\n  /*\n  var podModulePrefix = config.podModulePrefix || '';\n  var podPath = podModulePrefix.substr(podModulePrefix.lastIndexOf('/') + 1);\n  // Disabled until we are ready to deprecate podModulePrefix\n  deprecateUI(ui)('`podModulePrefix` is deprecated and will be removed from future versions of ember-cli.'+\n    ' Please move existing pods from \\'app/' + podPath + '/\\' to \\'app/\\'.', config.podModulePrefix);\n  */\n  if (config.usePodsByDefault) {\n    ui.writeDeprecateLine('`usePodsByDefault` is no longer supported in \\'config/environment.js\\',' +\n      ' use `usePods` in \\'.ember-cli\\' instead.');\n  }\n}\n\n/**\n  @private\n  @method isValidFile\n  @param {Object} fileInfo\n  @return {Promise}\n*/\nfunction isValidFile(fileInfo) {\n  if (isIgnored(fileInfo)) {\n    return Promise.resolve(false);\n  } else {\n    return isFile(fileInfo);\n  }\n}\n\n/**\n  @private\n  @method isFilePath\n  @param {Object} fileInfo\n  @return {Promise}\n*/\nfunction isFilePath(fileInfo) {\n  return fs.statSync(fileInfo.inputPath).isFile();\n}\n\n/**\n @private\n @method dir\n @return {Array} list of files in the given directory or and empty array if no directory exists\n*/\nfunction dir(fullPath) {\n  if (existsSync(fullPath)) {\n    return fs.readdirSync(fullPath).map(fileName => path.join(fullPath, fileName));\n  } else {\n    return [];\n  }\n}\n\n/**\n  @private\n  @method getDetailedHelpPath\n  @param {String} thisPath\n  @return {String} help path\n*/\nfunction getDetailedHelpPath(thisPath) {\n  return path.join(thisPath, './HELP.md');\n}\n\nfunction finishProcessingForInstall(infos) {\n  infos.forEach(markIdenticalToBeSkipped);\n\n  let infosNeedingConfirmation = infos.reduce(gatherConfirmationMessages, []);\n\n  return sequence(infosNeedingConfirmation).then(() => infos);\n}\n\nfunction finishProcessingForUninstall(infos) {\n  infos.forEach(markToBeRemoved);\n  return infos;\n}\n\nmodule.exports = Blueprint;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/file-info.js":"'use strict';\n\nconst fs = require('fs');\nconst RSVP = require('rsvp');\nconst chalk = require('chalk');\nconst EditFileDiff = require('./edit-file-diff');\nconst EOL = require('os').EOL;\nconst isBinaryFile = require('isbinaryfile').sync;\nconst canEdit = require('../utilities/open-editor').canEdit;\nconst processTemplate = require('../utilities/process-template');\n\nconst Promise = RSVP.Promise;\nconst readFile = RSVP.denodeify(fs.readFile);\nconst lstat = RSVP.denodeify(fs.stat);\n\nfunction diffHighlight(line) {\n  if (line[0] === '+') {\n    return chalk.green(line);\n  } else if (line[0] === '-') {\n    return chalk.red(line);\n  } else if (line.match(/^@@/)) {\n    return chalk.cyan(line);\n  } else {\n    return line;\n  }\n}\n\nclass FileInfo {\n  constructor(options) {\n    this.action = options.action;\n    this.outputBasePath = options.outputBasePath;\n    this.outputPath = options.outputPath;\n    this.displayPath = options.displayPath;\n    this.inputPath = options.inputPath;\n    this.templateVariables = options.templateVariables;\n    this.ui = options.ui;\n  }\n\n  confirmOverwrite(path) {\n    let promptOptions = {\n      type: 'expand',\n      name: 'answer',\n      default: false,\n      message: `${chalk.red('Overwrite')} ${path}?`,\n      choices: [\n        { key: 'y', name: 'Yes, overwrite', value: 'overwrite' },\n        { key: 'n', name: 'No, skip', value: 'skip' },\n      ],\n    };\n\n    let outputPathIsFile = false;\n    try { outputPathIsFile = fs.statSync(this.outputPath).isFile(); } catch (err) { /* ignore */ }\n\n    let canDiff = (\n      !isBinaryFile(this.inputPath) && (\n        !outputPathIsFile ||\n        !isBinaryFile(this.outputPath)\n      )\n    );\n\n    if (canDiff) {\n      promptOptions.choices.push({ key: 'd', name: 'Diff', value: 'diff' });\n\n      if (canEdit()) {\n        promptOptions.choices.push({ key: 'e', name: 'Edit', value: 'edit' });\n      }\n    }\n\n    return this.ui.prompt(promptOptions)\n      .then(response => response.answer);\n  }\n\n  displayDiff() {\n    let info = this,\n        jsdiff = require('diff');\n    return RSVP.hash({\n      input: this.render(),\n      output: readFile(info.outputPath),\n    }).then(result => {\n      let diff = jsdiff.createPatch(\n        info.outputPath, result.output.toString(), result.input\n      );\n      let lines = diff.split('\\n');\n\n      for (let i = 0; i < lines.length; i++) {\n        info.ui.write(\n          diffHighlight(lines[i] + EOL)\n        );\n      }\n    });\n  }\n\n  render() {\n    let path = this.inputPath,\n        context = this.templateVariables;\n    if (!this.rendered) {\n      this.rendered = readFile(path)\n        .then(content => lstat(path)\n          .then(fileStat => {\n            if (isBinaryFile(content, fileStat.size)) {\n              return content;\n            } else {\n              try {\n                return processTemplate(content.toString(), context);\n              } catch (err) {\n                err.message += ` (Error in blueprint template: ${path})`;\n                throw err;\n              }\n            }\n          }));\n    }\n    return this.rendered;\n  }\n\n  checkForConflict() {\n    return new Promise((resolve, reject) => {\n      fs.exists(this.outputPath, (doesExist, error) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        let result;\n\n        if (doesExist) {\n          result = RSVP.hash({\n            input: this.render(),\n            output: readFile(this.outputPath),\n          }).then(result => {\n            let type;\n            if (result.input.toString() === result.output.toString()) {\n              type = 'identical';\n            } else {\n              type = 'confirm';\n            }\n            return type;\n          });\n        } else {\n          result = 'none';\n        }\n\n        resolve(result);\n      });\n    });\n  }\n\n  confirmOverwriteTask() {\n    let info = this;\n\n    return function() {\n      return new Promise((resolve, reject) => {\n        function doConfirm() {\n          info.confirmOverwrite(info.displayPath).then(action => {\n            if (action === 'diff') {\n              info.displayDiff().then(doConfirm, reject);\n            } else if (action === 'edit') {\n              let editFileDiff = new EditFileDiff({ info });\n              editFileDiff.edit().then(() => {\n                info.action = action;\n                resolve(info);\n              }).catch(() => {\n                doConfirm().finally(() => {\n                  resolve(info);\n                });\n              });\n            } else {\n              info.action = action;\n              resolve(info);\n            }\n          }, reject);\n        }\n\n        doConfirm();\n      });\n    }.bind(this);\n  }\n}\n\nmodule.exports = FileInfo;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/edit-file-diff.js":"'use strict';\n\nconst fs = require('fs');\nconst RSVP = require('rsvp');\nconst jsdiff = require('diff');\nconst quickTemp = require('quick-temp');\nconst path = require('path');\nconst SilentError = require('silent-error');\nconst openEditor = require('../utilities/open-editor');\n\nconst readFile = RSVP.denodeify(fs.readFile);\nconst writeFile = RSVP.denodeify(fs.writeFile);\n\nclass EditFileDiff {\n  constructor(options) {\n    this.info = options.info;\n\n    quickTemp.makeOrRemake(this, 'tmpDifferenceDir');\n  }\n\n  edit() {\n    return RSVP.hash({\n      input: this.info.render(),\n      output: readFile(this.info.outputPath),\n    })\n      .then(this.invokeEditor.bind(this))\n      .then(this.applyPatch.bind(this))\n      .finally(this.cleanUp.bind(this));\n  }\n\n  cleanUp() {\n    quickTemp.remove(this, 'tmpDifferenceDir');\n  }\n\n  applyPatch(resultHash) {\n    return RSVP.hash({\n      diffString: readFile(resultHash.diffPath),\n      currentString: readFile(resultHash.outputPath),\n    }).then(result => {\n      let appliedDiff = jsdiff.applyPatch(result.currentString.toString(), result.diffString.toString());\n\n      if (!appliedDiff) {\n        let message = 'Patch was not cleanly applied.';\n        this.info.ui.writeLine(`${message} Please choose another action.`);\n        throw new SilentError(message);\n      }\n\n      return writeFile(resultHash.outputPath, appliedDiff);\n    });\n  }\n\n  invokeEditor(result) {\n    let info = this.info;\n    let diff = jsdiff.createPatch(info.outputPath, result.output.toString(), result.input);\n    let diffPath = path.join(this.tmpDifferenceDir, 'currentDiff.diff');\n\n    return writeFile(diffPath, diff)\n      .then(() => openEditor(diffPath))\n      .then(() => ({ outputPath: info.outputPath, diffPath }));\n  }\n}\n\nmodule.exports = EditFileDiff;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/open-editor.js":"'use strict';\n\nconst Promise = require('rsvp').Promise;\nconst spawn = require('child_process').spawn;\n\nfunction openEditor(file) {\n  if (!openEditor.canEdit()) {\n    throw new Error('EDITOR environment variable is not set');\n  }\n\n  if (!file) {\n    throw new Error('No `file` option provided');\n  }\n\n  let editorArgs = openEditor._env().EDITOR.split(' ');\n  let editor = editorArgs.shift();\n  let editProcess = openEditor._spawn(editor, [file].concat(editorArgs), { stdio: 'inherit' });\n\n  return new Promise((resolve, reject) => {\n    editProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject();\n      }\n    });\n  });\n}\n\nopenEditor.canEdit = function() {\n  return openEditor._env().EDITOR !== undefined;\n};\n\nopenEditor._env = function() {\n  return process.env;\n};\n\nopenEditor._spawn = function() {\n  return spawn.apply(this, arguments);\n};\n\nmodule.exports = openEditor;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/process-template.js":"'use strict';\n\nmodule.exports = function processTemplate(content, context) {\n  let options = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g,\n  };\n  return require('lodash.template')(content, options)(context);\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/markdown-color.js":"'use strict';\n\nconst fs = require('fs');\n\nconst chalk = require('chalk');\nconst SilentError = require('silent-error');\nconst merge = require('ember-cli-lodash-subset').merge;\n\nlet colors = ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow', 'black', 'white', 'grey', 'gray'];\nlet backgroundColors = ['bgRed', 'bgGreen', 'bgBlue', 'bgCyan', 'bgMagenta', 'bgYellow', 'bgWhite', 'bgBlack'];\n\nmodule.exports = MarkdownColor;\n\n/*\n  Parses markdown and applies coloring to output by matching defined tokens and\n  applying styling. Default outputs chalk.js coloring for terminal output.\n  Options:\n    tokens: pass additional tokens in the following format:\n    {\n      name:{\n        token: '(Reserved)', // example of token\n        pattern: /(Reserved)/g, // regexp pattern\n        render: function(string) { return string + '!'} // function that takes and returns a string\n      }\n    }\n\n    markdownOptions: object containing options to pass (or override) to markdown-it-terminal upon\n      instantiation. See https://github.com/trabus/markdown-it-terminal/blob/master/index.js#L8\n\n    renderStyles: pass an object to render color styles, default is chalk.js\n\n  @class MarkdownColor\n  @constructor\n  @param {Object} [options]\n*/\nfunction MarkdownColor(options) {\n  let optionTokens = (options && options.tokens) || {};\n  let renderStyles = (options && options.renderStyles) || chalk;\n  let tokens = this.generateTokens(renderStyles);\n  let markdownOptions = (options && options.markdownOptions) || {};\n  const markdown = require('markdown-it');\n  const terminal = require('markdown-it-terminal');\n  this.options = options || {};\n  this.markdown = markdown().use(terminal, markdownOptions);\n  this.tokens = merge(tokens, optionTokens);\n\n  return this;\n}\n\n/*\n  Lookup markdown file and render contents\n  @method renderFile\n  @param {String} [filePath]\n  @param {Object} [options]\n*/\nMarkdownColor.prototype.renderFile = function(filePath, options) {\n  let file;\n  try {\n    file = fs.readFileSync(filePath, 'utf-8');\n  } catch (e) {\n    throw new SilentError(`The file '${filePath}' doesn't exist. Please check your filePath`);\n  }\n\n  return this.render(file, options);\n};\n\n/*\n  Parse markdown and output as string\n  @method render\n  @param {String} [string]\n  @param {Object} [options]\n  @return {String}\n*/\nMarkdownColor.prototype.render = function(string, options) {\n  let indent = (options && options.indent) || '';\n  let input = this.markdown.render(string);\n  let styles = Object.keys(this.tokens);\n  input = input.replace(/^/mg, indent);\n  styles.reverse().map(style => {\n    input = input.replace(this.tokens[style].pattern, this.tokens[style].render);\n  });\n  input = input.replace(/\\~\\^(.*)\\~\\^/g, escapeToken);\n  return input;\n};\n\n/*\n  Generate default style tokens\n  @method generateTokens\n  @return {Object}\n*/\nMarkdownColor.prototype.generateTokens = function(renderer) {\n  let defaultTokens = {\n    // ember-cli styles\n    option: {\n      name: 'option',\n      token: '--option',\n      pattern: /((--\\w*\\b)|(<options>))/g,\n      render: renderStylesFactory(renderer, 'cyan'),\n    },\n    default: {\n      name: 'default',\n      token: '(Default: default)',\n      pattern: /(\\(Default:\\s.*\\))/g,\n      render: renderStylesFactory(renderer, 'cyan'),\n    },\n    required: {\n      name: 'required',\n      token: '(Required)',\n      pattern: /(\\(Required\\))/g,\n      render: renderStylesFactory(renderer, 'cyan'),\n    },\n  };\n\n  let colorTokens = unshiftValue(colors.concat(backgroundColors).map(getToken), {}).reduce(setToken);\n  return merge(colorTokens, defaultTokens);\n};\n\n\n/*\n  Looks up multiple styles to apply to the rendered output\n  @method renderStylesFactory\n  @param {Object} [renderer] should match chalk.js format\n  @param {String, Array} [styleNames]\n  @return {Function} Function that will wrap the input string with styling\n*/\nMarkdownColor.prototype.renderStylesFactory = renderStylesFactory;\nfunction renderStylesFactory(renderer, styleNames) {\n  let styles;\n  if (Array.isArray(styleNames)) {\n    styles = styleNames.map(checkStyleName.bind(null, renderer));\n  } else {\n    styles = [checkStyleName(renderer, styleNames)];\n  }\n  return function(match, pattern) {\n    return styles.reverse().reduce((previous, current) => renderer[current](previous), pattern);\n  };\n}\n\n/*\n  Check to see if style exists on the renderer\n  @param {Object} [renderer] should match chalk.js format\n  @param {String} [name]\n*/\nfunction checkStyleName(renderer, name) {\n  if (Object.keys(renderer.styles).indexOf(name) > -1) {\n    return name;\n  } else {\n    throw new SilentError(`The style '${name}' is not supported by the markdown renderer.`);\n  }\n}\n\n/*\n  @param {String} [name]\n  @param {Object} [options]\n  @return {RegExp} Returns lookup pattern\n*/\nfunction getColorTokenRegex(name, options) {\n  options = options || {};\n  let start = options.start || '(?:<';\n  let end = options.end || '>)';\n  let close = options.close || '(?:<\\/';\n  let middle = options.middle || '(.*?)';\n  let tag = start + name + end;\n  let closeTag = close + name + end;\n  let pattern = tag + middle + closeTag;\n  return new RegExp(pattern, 'g');\n}\n\n/*\n  @param {String} [name]\n  @param {Object} [options]\n  @return {Object} Returns token object\n*/\nfunction getToken(name, options) {\n  let renderer = (options && options.renderer) || chalk;\n  return {\n    name,\n    token: `<${name}></${name}>`,\n    pattern: getColorTokenRegex(name),\n    render: renderStylesFactory(renderer, name),\n  };\n}\n\nfunction setToken(result, color) {\n  result[color.name] = color;\n  return result;\n}\n\nfunction escapeToken(match, pattern) {\n  let output = pattern.replace(/\\~/g, '');\n  return `<${output}>`;\n}\n\nfunction unshiftValue(array, value) {\n  array.unshift(value);\n  return array;\n}\n\n/*\nFormatting colors for ember-cli help\n\nwhite: ember serve\nyellow: <arg-option, >\ncyan: --port, --important-option\ncyan: (Default: something), (Default: 4200)\nwhite: Description 1, Description 2\ncyan: (Required)\n*/\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/sequence.js":"'use strict';\n\nconst Promise = require('rsvp').Promise;\n/*\n *\n * given an array of functions, that may or may not return promises sequence\n * will invoke them sequentially. If a promise is encountered sequence will\n * wait until it fulfills before moving to the next entry.\n *\n * ```js\n * var tasks = [\n *   function() { return Promise.resolve(1); },\n *   2,\n *   function() { return timeout(1000).then(function() { return 3; } },\n * ];\n *\n * sequence(tasks).then(function(results) {\n *   results === [\n *     1,\n *     2,\n *     3\n *   ]\n * });\n * ```\n *\n * @method sequence\n * @param tasks\n * @return Promise<Array>\n *\n */\nmodule.exports = function sequence(tasks) {\n  let length = tasks.length;\n  let current = Promise.resolve();\n  let results = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    current = results[i] = current.then(tasks[i]);\n  }\n\n  return Promise.all(results);\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/insert-into-file.js":"'use strict';\n\nconst fs = require('fs-extra');\nconst existsSync = require('exists-sync');\nconst EOL = require('os').EOL;\nconst RSVP = require('rsvp');\n\nconst Promise = RSVP.Promise;\nconst writeFile = RSVP.denodeify(fs.outputFile);\n\n/**\n  Inserts the given content into a file. If the `contentsToInsert` string is already\n  present in the current contents, the file will not be changed unless `force` option\n  is passed.\n\n  If `options.before` is specified, `contentsToInsert` will be inserted before\n  the first instance of that string.  If `options.after` is specified, the\n  contents will be inserted after the first instance of that string.\n  If the string specified by options.before or options.after is not in the file,\n  no change will be made.\n\n  If neither `options.before` nor `options.after` are present, `contentsToInsert`\n  will be inserted at the end of the file.\n\n  Example:\n\n  ```\n  // app/router.js\n  Router.map(function() {\n  });\n  ```\n\n  ```\n  insertIntoFile('app/router.js', '  this.route(\"admin\");', {\n    after: 'Router.map(function() {' + EOL\n  });\n  ```\n\n  ```\n  // app/router.js\n  Router.map(function() {\n    this.route(\"admin\");\n  });\n  ```\n\n  @method insertIntoFile\n  @param {String} pathRelativeToProjectRoot\n  @param {String} contentsToInsert\n  @param {Object} providedOptions\n  @return {Promise}\n*/\nfunction insertIntoFile(fullPath, contentsToInsert, providedOptions) {\n  let originalContents = '';\n\n  if (existsSync(fullPath)) {\n    originalContents = fs.readFileSync(fullPath, { encoding: 'utf8' });\n  }\n\n  let contentsToWrite = originalContents;\n\n  let options = providedOptions || {};\n  let alreadyPresent = originalContents.indexOf(contentsToInsert) > -1;\n  let insert = !alreadyPresent;\n  let insertBehavior = 'end';\n\n  if (options.before) { insertBehavior = 'before'; }\n  if (options.after) { insertBehavior = 'after'; }\n\n  if (options.force) { insert = true; }\n\n  if (insert) {\n    if (insertBehavior === 'end') {\n      contentsToWrite += contentsToInsert;\n    } else {\n      let contentMarker = options[insertBehavior];\n      let contentMarkerIndex = contentsToWrite.indexOf(contentMarker);\n\n      if (contentMarkerIndex !== -1) {\n        let insertIndex = contentMarkerIndex;\n        if (insertBehavior === 'after') { insertIndex += contentMarker.length; }\n\n        contentsToWrite = contentsToWrite.slice(0, insertIndex) +\n          contentsToInsert + EOL +\n          contentsToWrite.slice(insertIndex);\n      }\n    }\n  }\n\n  let returnValue = {\n    path: fullPath,\n    originalContents,\n    contents: contentsToWrite,\n    inserted: false,\n  };\n\n  if (contentsToWrite !== originalContents) {\n    returnValue.inserted = true;\n\n    return writeFile(fullPath, contentsToWrite)\n      .then(() => returnValue);\n\n  } else {\n    return Promise.resolve(returnValue);\n  }\n}\n\nmodule.exports = insertIntoFile;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/clean-remove.js":"'use strict';\n\nconst path = require('path');\nconst fs = require('fs-extra');\nconst RSVP = require('rsvp');\nconst walkUp = require('./walk-up-path');\n\nconst Promise = RSVP.Promise;\nconst stat = RSVP.denodeify(fs.stat);\nconst remove = RSVP.denodeify(fs.remove);\nconst readdir = RSVP.denodeify(fs.readdir);\n\nfunction cleanRemove(fileInfo) {\n  // see if file exists to avoid wasting time\n  return stat(fileInfo.outputPath)\n    .then(() => remove(fileInfo.outputPath))\n    .then(() => {\n      let paths = walkUp(fileInfo.displayPath)\n        .map(thePath => path.join(fileInfo.outputBasePath, thePath));\n\n      return paths.reduce((chainedPromise, thePath) => chainedPromise.then(wasShortCircuited => {\n        if (wasShortCircuited) {\n          // optimization that says since my child dir wasn't empty,\n          // I can't be empty, so keep skipping\n          return true;\n        }\n\n        // get list of files remaining in this dir\n        return readdir(thePath).then(paths => {\n          if (paths.length) {\n            // don't check parent dirs since this one isn't empty\n            return true;\n          }\n\n          return remove(thePath).then(() => false);\n        });\n      }), Promise.resolve());\n    })\n    .catch(err => {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n\n      // you tried to destroy a blueprint without first generating it\n      // instead of trying to read dirs that don't exist\n      // swallow error and carry on\n    });\n}\n\nmodule.exports = cleanRemove;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/walk-up-path.js":"'use strict';\n\nconst path = require('path');\n\nlet regex = /^[\\./]$/;\n\nfunction walkUp(thePath) {\n  let paths = [];\n\n  let currentPath = thePath;\n  while (true) { // eslint-disable-line no-constant-condition\n    currentPath = path.dirname(currentPath);\n    if (regex.test(currentPath)) {\n      break;\n    }\n    paths.push(currentPath);\n  }\n\n  return paths;\n}\n\nmodule.exports = walkUp;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli-normalize-entity-name/index.js":"'use strict';\n\nvar SilentError = require('silent-error');\n\nmodule.exports = function normalizeEntityName(entityName) {\n\n  if (!entityName) {\n    throw new SilentError('The `ember generate <entity-name>` command requires an ' +\n                          'entity name to be specified. ' +\n                          'For more details, use `ember help`.');\n  }\n\n  var trailingSlash = /(\\/$|\\\\$)/;\n  if(trailingSlash.test(entityName)) {\n    throw new SilentError('You specified \"' + entityName + '\", but you can\\'t use a ' +\n                          'trailing slash as an entity name with generators. Please ' +\n                          're-run the command with \"' + entityName.replace(trailingSlash, '') + '\".');\n  }\n\n  return entityName;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/destroy.js":"'use strict';\n\nconst Command = require('../models/command');\nconst Promise = require('rsvp').Promise;\nconst mergeBlueprintOptions = require('../utilities/merge-blueprint-options');\nconst merge = require('ember-cli-lodash-subset').merge;\nconst SilentError = require('silent-error');\n\nmodule.exports = Command.extend({\n  name: 'destroy',\n  description: 'Destroys code generated by `generate` command.',\n  aliases: ['d'],\n  works: 'insideProject',\n\n  availableOptions: [\n    { name: 'dry-run',       type: Boolean, default: false, aliases: ['d'] },\n    { name: 'verbose',       type: Boolean, default: false, aliases: ['v'] },\n    { name: 'pod',           type: Boolean, default: false, aliases: ['p'] },\n    { name: 'classic',       type: Boolean, default: false, aliases: ['c'] },\n    { name: 'dummy',         type: Boolean, default: false, aliases: ['dum', 'id'] },\n    { name: 'in-repo-addon', type: String,  default: null,  aliases: ['in-repo', 'ir'] },\n  ],\n\n  anonymousOptions: [\n    '<blueprint>',\n  ],\n\n  beforeRun: mergeBlueprintOptions,\n\n  run(commandOptions, rawArgs) {\n    let blueprintName = rawArgs[0];\n    let entityName = rawArgs[1];\n\n    if (!blueprintName) {\n      return Promise.reject(new SilentError('The `ember destroy` command requires a ' +\n                                            'blueprint name to be specified. ' +\n                                            'For more details, use `ember help`.'));\n    }\n\n    if (!entityName) {\n      return Promise.reject(new SilentError('The `ember destroy` command requires an ' +\n                                            'entity name to be specified. ' +\n                                            'For more details, use `ember help`.'));\n    }\n\n    let Task = this.tasks.DestroyFromBlueprint;\n    let task = new Task({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      settings: this.settings,\n    });\n\n    let taskArgs = {\n      args: rawArgs,\n    };\n\n    if (this.settings && this.settings.usePods && !commandOptions.classic) {\n      commandOptions.pod = !commandOptions.pod;\n    }\n\n    let taskOptions = merge(taskArgs, commandOptions || {});\n\n    if (this.project.initializeAddons) {\n      this.project.initializeAddons();\n    }\n\n    return task.run(taskOptions);\n  },\n\n  printDetailedHelp() {\n    let ui = this.ui;\n\n    ui.writeLine('');\n    ui.writeLine('  Run `ember help generate` to view a list of available blueprints.');\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/generate.js":"'use strict';\n\nconst chalk = require('chalk');\nconst Command = require('../models/command');\nconst Promise = require('rsvp').Promise;\nconst Blueprint = require('../models/blueprint');\nconst mergeBlueprintOptions = require('../utilities/merge-blueprint-options');\nconst _ = require('ember-cli-lodash-subset');\nconst EOL = require('os').EOL;\nconst SilentError = require('silent-error');\n\nmodule.exports = Command.extend({\n  name: 'generate',\n  description: 'Generates new code from blueprints.',\n  aliases: ['g'],\n  works: 'insideProject',\n\n  availableOptions: [\n    { name: 'dry-run',       type: Boolean, default: false, aliases: ['d'] },\n    { name: 'verbose',       type: Boolean, default: false, aliases: ['v'] },\n    { name: 'pod',           type: Boolean, default: false, aliases: ['p'] },\n    { name: 'classic',       type: Boolean, default: false, aliases: ['c'] },\n    { name: 'dummy',         type: Boolean, default: false, aliases: ['dum', 'id'] },\n    { name: 'in-repo-addon', type: String,  default: null,  aliases: ['in-repo', 'ir'] },\n  ],\n\n  anonymousOptions: [\n    '<blueprint>',\n  ],\n\n  beforeRun: mergeBlueprintOptions,\n\n  run(commandOptions, rawArgs) {\n    let blueprintName = rawArgs[0];\n\n    if (!blueprintName) {\n      return Promise.reject(new SilentError('The `ember generate` command requires a ' +\n                                            'blueprint name to be specified. ' +\n                                            'For more details, use `ember help`.'));\n    }\n    let Task = this.tasks.GenerateFromBlueprint;\n    let task = new Task({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      testing: this.testing,\n      settings: this.settings,\n    });\n\n    let taskArgs = {\n      args: rawArgs,\n    };\n\n    if (this.settings && this.settings.usePods && !commandOptions.classic) {\n      commandOptions.pod = !commandOptions.pod;\n    }\n\n    let taskOptions = _.merge(taskArgs, commandOptions || {});\n\n    if (this.project.initializeAddons) {\n      this.project.initializeAddons();\n    }\n\n    return task.run(taskOptions);\n  },\n\n  printDetailedHelp(options) {\n    this.ui.writeLine(this.getAllBlueprints(options));\n  },\n\n  addAdditionalJsonForHelp(json, options) {\n    json.availableBlueprints = this.getAllBlueprints(options);\n  },\n\n  getAllBlueprints(options) {\n    let lookupPaths = this.project.blueprintLookupPaths();\n    let blueprintList = Blueprint.list({ paths: lookupPaths });\n\n    let output = '';\n\n    let singleBlueprintName;\n    if (options.rawArgs) {\n      singleBlueprintName = options.rawArgs[0];\n    }\n\n    if (!singleBlueprintName && !options.json) {\n      output += `${EOL}  Available blueprints:${EOL}`;\n    }\n\n    let collectionsJson = [];\n\n    blueprintList.forEach(function(collection) {\n      let result = this.getPackageBlueprints(collection, options, singleBlueprintName);\n      if (options.json) {\n        let collectionJson = {};\n        collectionJson[collection.source] = result;\n        collectionsJson.push(collectionJson);\n      } else {\n        output += result;\n      }\n    }, this);\n\n    if (singleBlueprintName && !output && !options.json) {\n      output = chalk.yellow(`The '${singleBlueprintName}' blueprint does not exist in this project.`) + EOL;\n    }\n\n    if (options.json) {\n      return collectionsJson;\n    } else {\n      return output;\n    }\n  },\n\n  getPackageBlueprints(collection, options, singleBlueprintName) {\n    let verbose = options.verbose;\n    let blueprints = collection.blueprints;\n\n    if (!verbose) {\n      blueprints = _.reject(blueprints, 'overridden');\n    }\n\n    let output = '';\n\n    if (blueprints.length && !singleBlueprintName && !options.json) {\n      output += `    ${collection.source}:${EOL}`;\n    }\n\n    let blueprintsJson = [];\n\n    blueprints.forEach(function(blueprint) {\n      let singleMatch = singleBlueprintName === blueprint.name;\n      if (singleMatch) {\n        verbose = true;\n      }\n      if (!singleBlueprintName || singleMatch) {\n        // this may add default keys for printing\n        blueprint.availableOptions.forEach(this.normalizeOption);\n\n        if (options.json) {\n          blueprintsJson.push(blueprint.getJson(verbose));\n        } else {\n          output += blueprint.printBasicHelp(verbose) + EOL;\n        }\n      }\n    }, this);\n\n    if (options.json) {\n      return blueprintsJson;\n    } else {\n      return output;\n    }\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/help.js":"'use strict';\n\nconst Command = require('../models/command');\nconst lookupCommand = require('../cli/lookup-command');\nconst stringUtils = require('ember-cli-string-utils');\nconst assign = require('ember-cli-lodash-subset').assign;\nconst GenerateCommand = require('./generate');\nconst RootCommand = require('../utilities/root-command');\nconst JsonGenerator = require('../utilities/json-generator');\n\nmodule.exports = Command.extend({\n  name: 'help',\n  description: 'Outputs the usage instructions for all commands or the provided command',\n  aliases: [undefined, 'h', '--help', '-h'],\n  works: 'everywhere',\n\n  availableOptions: [\n    { name: 'verbose', type: Boolean, default: false, aliases: ['v'] },\n    { name: 'json',    type: Boolean, default: false },\n  ],\n\n  anonymousOptions: [\n    '<command-name (Default: all)>',\n  ],\n\n  run(commandOptions, rawArgs) {\n    if (commandOptions.json) {\n      this._printJsonHelp(commandOptions);\n    } else {\n      this._printHelp(commandOptions, rawArgs);\n    }\n  },\n\n  _printHelp(commandOptions, rawArgs) {\n    let rootCommand = new RootCommand({\n      ui: this.ui,\n      project: this.project,\n      commands: this.commands,\n      tasks: this.tasks,\n    });\n\n    if (rawArgs.length === 0) {\n      this.ui.writeLine(rootCommand.printBasicHelp(commandOptions));\n      // Display usage for all commands.\n      this.ui.writeLine('Available commands in ember-cli:');\n      this.ui.writeLine('');\n\n      Object.keys(this.commands).forEach(function(commandName) {\n        this._printHelpForCommand(commandName, false, commandOptions);\n      }, this);\n\n      if (this.project.eachAddonCommand) {\n        this.project.eachAddonCommand((addonName, commands) => {\n          this.commands = commands;\n\n          this.ui.writeLine('');\n          this.ui.writeLine(`Available commands from ${addonName}:`);\n\n          Object.keys(this.commands).forEach(function(commandName) {\n            this._printHelpForCommand(commandName, false, commandOptions);\n          }, this);\n        });\n      }\n    } else {\n      // If args were passed to the help command,\n      // attempt to look up the command for each of them.\n\n      this.ui.writeLine('Requested ember-cli commands:');\n      this.ui.writeLine('');\n\n      if (this.project.eachAddonCommand) {\n        this.project.eachAddonCommand((addonName, commands) => {\n          assign(this.commands, commands);\n        });\n      }\n\n      let multipleCommands = [GenerateCommand.prototype.name].concat(GenerateCommand.prototype.aliases);\n      if (multipleCommands.indexOf(rawArgs[0]) > -1) {\n        let command = rawArgs.shift();\n        if (rawArgs.length > 0) {\n          commandOptions.rawArgs = rawArgs;\n        }\n        rawArgs = [command];\n      }\n\n      // Iterate through each arg beyond the initial 'help' command,\n      // and try to display usage instructions.\n      rawArgs.forEach(function(commandName) {\n        this._printHelpForCommand(commandName, true, commandOptions);\n      }, this);\n    }\n  },\n\n  _printJsonHelp(commandOptions) {\n    let generator = new JsonGenerator({\n      ui: this.ui,\n      project: this.project,\n      commands: this.commands,\n      tasks: this.tasks,\n    });\n\n    let json = generator.generate(commandOptions);\n\n    let outputJsonString = JSON.stringify(json, null, 2);\n\n    this.ui.writeLine(outputJsonString);\n  },\n\n  _printHelpForCommand(commandName, detailed, options) {\n    let command = this._lookupCommand(commandName);\n\n    if (!command.skipHelp || detailed) {\n      this.ui.writeLine(command.printBasicHelp(options));\n    }\n\n    if (detailed) {\n      command.printDetailedHelp(options);\n    }\n  },\n\n  _lookupCommand(commandName) {\n    let Command = this.commands[stringUtils.classify(commandName)] ||\n                  lookupCommand(this.commands, commandName);\n\n    return new Command({\n      ui: this.ui,\n      project: this.project,\n      commands: this.commands,\n      tasks: this.tasks,\n    });\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/root-command.js":"'use strict';\n\nconst Command = require('../models/command');\n\nmodule.exports = Command.extend({\n  isRoot: true,\n  name: 'ember',\n\n  anonymousOptions: [\n    '<command (Default: help)>',\n  ],\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/json-generator.js":"'use strict';\n\nconst lookupCommand = require('../cli/lookup-command');\nconst stringUtils = require('ember-cli-string-utils');\nconst RootCommand = require('./root-command');\nconst versionUtils = require('./version-utils');\nlet emberCLIVersion = versionUtils.emberCLIVersion;\n\nclass JsonGenerator {\n  constructor(options) {\n    options = options || {};\n\n    this.ui = options.ui;\n    this.project = options.project;\n    this.commands = options.commands;\n    this.tasks = options.tasks;\n  }\n\n  generate(commandOptions) {\n    let rootCommand = new RootCommand({\n      ui: this.ui,\n      project: this.project,\n      commands: this.commands,\n      tasks: this.tasks,\n    });\n\n    let json = rootCommand.getJson(commandOptions);\n    json.version = emberCLIVersion();\n    json.commands = [];\n    json.addons = [];\n\n    Object.keys(this.commands).forEach(function(commandName) {\n      this._addCommandHelpToJson(commandName, commandOptions, json);\n    }, this);\n\n    if (this.project.eachAddonCommand) {\n      this.project.eachAddonCommand((addonName, commands) => {\n        this.commands = commands;\n\n        let addonJson = { name: addonName };\n        addonJson.commands = [];\n        json.addons.push(addonJson);\n\n        Object.keys(this.commands).forEach(function(commandName) {\n          this._addCommandHelpToJson(commandName, commandOptions, addonJson);\n        }, this);\n      });\n    }\n\n    return json;\n  }\n\n  _addCommandHelpToJson(commandName, options, json) {\n    let command = this._lookupCommand(commandName);\n    if (!command.skipHelp && !command.unknown) {\n      json.commands.push(command.getJson(options));\n    }\n  }\n\n  _lookupCommand(commandName) {\n    let Command = this.commands[stringUtils.classify(commandName)] ||\n      lookupCommand(this.commands, commandName);\n\n    return new Command({\n      ui: this.ui,\n      project: this.project,\n      commands: this.commands,\n      tasks: this.tasks,\n    });\n  }\n}\n\nmodule.exports = JsonGenerator;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/init.js":"'use strict';\n\nconst clone = require('ember-cli-lodash-subset').clone;\nconst merge = require('ember-cli-lodash-subset').merge;\nconst Command = require('../models/command');\nconst Promise = require('rsvp').Promise;\nconst SilentError = require('silent-error');\nconst validProjectName = require('../utilities/valid-project-name');\nconst normalizeBlueprint = require('../utilities/normalize-blueprint-option');\nconst mergeBlueprintOptions = require('../utilities/merge-blueprint-options');\nlet logger = require('heimdalljs-logger')('ember-cli:command:init');\n\nmodule.exports = Command.extend({\n  name: 'init',\n  description: 'Creates a new ember-cli project in the current folder.',\n  works: 'everywhere',\n\n  availableOptions: [\n    { name: 'dry-run',    type: Boolean, default: false, aliases: ['d'] },\n    { name: 'verbose',    type: Boolean, default: false, aliases: ['v'] },\n    { name: 'blueprint',  type: String,                  aliases: ['b'] },\n    { name: 'skip-npm',   type: Boolean, default: false, aliases: ['sn'] },\n    { name: 'skip-bower', type: Boolean, default: false, aliases: ['sb'] },\n    { name: 'name',       type: String,  default: '',    aliases: ['n'] },\n  ],\n\n  anonymousOptions: [\n    '<glob-pattern>',\n  ],\n\n  _defaultBlueprint() {\n    if (this.project.isEmberCLIAddon()) {\n      return 'addon';\n    } else {\n      return 'app';\n    }\n  },\n\n  beforeRun: mergeBlueprintOptions,\n\n  run(commandOptions, rawArgs) {\n    if (commandOptions.dryRun) {\n      commandOptions.skipNpm = true;\n      commandOptions.skipBower = true;\n    }\n\n    let installBlueprint = new this.tasks.InstallBlueprint({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n    });\n\n    let gitInit, npmInstall, bowerInstall;\n\n    // needs an explicit check in case it's just 'undefined'\n    // due to passing of options from 'new' and 'addon'\n    if (commandOptions.skipGit === false) {\n      gitInit = new this.tasks.GitInit({\n        ui: this.ui,\n        project: this.project,\n      });\n    }\n\n    if (!commandOptions.skipNpm) {\n      npmInstall = new this.tasks.NpmInstall({\n        ui: this.ui,\n        analytics: this.analytics,\n        project: this.project,\n      });\n    }\n\n    if (!commandOptions.skipBower) {\n      bowerInstall = new this.tasks.BowerInstall({\n        ui: this.ui,\n        analytics: this.analytics,\n        project: this.project,\n      });\n    }\n\n    let project = this.project;\n    let packageName = (commandOptions.name !== '.' && commandOptions.name) || project.name();\n\n    if (!packageName) {\n      let message = `The \\`ember ${this.name}\\` command requires a ` +\n        `package.json in current folder with name attribute or a specified name via arguments. ` +\n        `For more details, use \\`ember help\\`.`;\n\n      return Promise.reject(new SilentError(message));\n    }\n\n    let blueprintOpts = clone(commandOptions);\n    merge(blueprintOpts, {\n      rawName: packageName,\n      targetFiles: rawArgs || '',\n      rawArgs: rawArgs.toString(),\n      blueprint: normalizeBlueprint(blueprintOpts.blueprint || this._defaultBlueprint()),\n    });\n\n    if (!validProjectName(packageName)) {\n      return Promise.reject(new SilentError(`We currently do not support a name of \\`${packageName}\\`.`));\n    }\n\n    logger.info('before:installblueprint');\n    return installBlueprint.run(blueprintOpts)\n      .then(() => {\n        logger.info('after:installblueprint');\n        if (!commandOptions.skipNpm) {\n          return npmInstall.run({\n            verbose: commandOptions.verbose,\n            optional: false,\n          }).then(() => {\n            project.setupNodeModulesPath();\n          });\n        }\n      })\n      .then(() => {\n        if (!commandOptions.skipBower) {\n          return bowerInstall.run({\n            verbose: commandOptions.verbose,\n          });\n        }\n      })\n      .then(() => {\n        if (commandOptions.skipGit === false) {\n          return gitInit.run(commandOptions, rawArgs);\n        }\n      });\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/install-addon.js":"'use strict';\n\nconst InstallCommand = require('./install');\n\nmodule.exports = InstallCommand.extend({\n  name: 'install:addon',\n  description: 'This command has been deprecated. Please use `ember install` instead.',\n  aliases: [],\n  skipHelp: true,\n\n  run() {\n    let warning = 'This command has been deprecated. Please use `ember ';\n    warning += 'install <addonName>` instead.';\n    this.ui.writeDeprecateLine(warning);\n    return this._super.run.apply(this, arguments);\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/install.js":"'use strict';\n\nconst Command = require('../models/command');\nconst SilentError = require('silent-error');\nconst Promise = require('rsvp').Promise;\n\nmodule.exports = Command.extend({\n  name: 'install',\n  description: 'Installs an ember-cli addon from npm.',\n  aliases: ['i'],\n  works: 'insideProject',\n\n  availableOptions: [\n    { name: 'save', type: Boolean, default: false, aliases: ['S'] },\n    { name: 'save-dev', type: Boolean, default: true, aliases: ['D'] },\n    { name: 'save-exact', type: Boolean, default: false, aliases: ['E', 'exact'] },\n  ],\n\n  anonymousOptions: [\n    '<addon-name>',\n  ],\n\n  run(commandOptions, addonNames) {\n    if (!addonNames.length) {\n      let msg = 'The `install` command must take an argument with the name';\n      msg += ' of an ember-cli addon. For installing all npm and bower ';\n      msg += 'dependencies you can run `npm install && bower install`.';\n      return Promise.reject(new SilentError(msg));\n    }\n\n    let AddonInstallTask = this.tasks.AddonInstall;\n    let addonInstall = new AddonInstallTask({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      NpmInstallTask: this.tasks.NpmInstall,\n      BlueprintTask: this.tasks.GenerateFromBlueprint,\n    });\n\n    return addonInstall.run({\n      'packages': addonNames,\n      blueprintOptions: commandOptions,\n    });\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/install-bower.js":"'use strict';\n\nconst Command = require('../models/command');\nconst SilentError = require('silent-error');\nconst Promise = require('rsvp').Promise;\n\nmodule.exports = Command.extend({\n  name: 'install:bower',\n  description: 'Bower package install are now managed by the user.',\n  works: 'insideProject',\n  skipHelp: true,\n\n  anonymousOptions: [\n    '<package-names...>',\n  ],\n\n  run() {\n    let err = 'This command has been removed. Please use `bower install ';\n    err += '<packageName> --save-dev --save-exact` instead.';\n    return Promise.reject(new SilentError(err));\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/install-npm.js":"'use strict';\n\nconst Command = require('../models/command');\nconst SilentError = require('silent-error');\nconst Promise = require('rsvp').Promise;\n\nmodule.exports = Command.extend({\n  name: 'install:npm',\n  description: 'Npm package installs are now managed by the user.',\n  works: 'insideProject',\n  skipHelp: true,\n\n  anonymousOptions: [\n    '<package-names...>',\n  ],\n\n  run() {\n    let err = 'This command has been removed. Please use `npm install ';\n    err += '<packageName> --save-dev --save-exact` instead.';\n    return Promise.reject(new SilentError(err));\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/serve.js":"'use strict';\n\nconst assign = require('ember-cli-lodash-subset').assign;\nconst Command = require('../models/command');\nconst RSVP = require('rsvp');\nconst SilentError = require('silent-error');\nconst PortFinder = require('portfinder');\nconst Win = require('../utilities/windows-admin');\nconst EOL = require('os').EOL;\n\nconst Promise = RSVP.Promise;\n\nPortFinder.basePort = 49153;\n\nlet getPort = RSVP.denodeify(PortFinder.getPort);\nlet defaultPort = process.env.PORT || 4200;\n\nmodule.exports = Command.extend({\n  name: 'serve',\n  description: 'Builds and serves your app, rebuilding on file changes.',\n  aliases: ['server', 's'],\n\n  availableOptions: [\n    { name: 'port',                 type: Number,  default: defaultPort,   aliases: ['p'],                                                     description: `To use a port different than ${defaultPort}. Pass 0 to automatically pick an available port.` },\n    { name: 'host',                 type: String,                          aliases: ['H'],                                                     description: 'Listens on all interfaces by default' },\n    { name: 'proxy',                type: String,                          aliases: ['pr', 'pxy'] },\n    { name: 'secure-proxy',         type: Boolean, default: true,          aliases: ['spr'],                                                   description: 'Set to false to proxy self-signed SSL certificates' },\n    { name: 'transparent-proxy',    type: Boolean, default: true,          aliases: ['transp'],                                                description: 'Set to false to omit x-forwarded-* headers when proxying' },\n    { name: 'watcher',              type: String,  default: 'events',      aliases: ['w'] },\n    { name: 'live-reload',          type: Boolean, default: true,          aliases: ['lr'] },\n    { name: 'live-reload-host',     type: String,                          aliases: ['lrh'],                                                   description: 'Defaults to host' },\n    { name: 'live-reload-base-url', type: String,                          aliases: ['lrbu'],                                                  description: 'Defaults to baseURL' },\n    { name: 'live-reload-port',     type: Number,                          aliases: ['lrp'],                                                   description: '(Defaults to port number within [49152...65535])' },\n    { name: 'environment',          type: String,  default: 'development', aliases: ['e', { 'dev': 'development' }, { 'prod': 'production' }], description: 'Possible values are \"development\", \"production\", and \"test\".' },\n    { name: 'output-path',          type: 'Path',  default: 'dist/',       aliases: ['op', 'out'] },\n    { name: 'ssl',                  type: Boolean, default: false },\n    { name: 'ssl-key',              type: String,  default: 'ssl/server.key' },\n    { name: 'ssl-cert',             type: String,  default: 'ssl/server.crt' },\n  ],\n\n  run(commandOptions) {\n    commandOptions.liveReloadHost = commandOptions.liveReloadHost || commandOptions.host;\n\n    return this._checkExpressPort(commandOptions)\n      .then(this._autoFindLiveReloadPort.bind(this))\n      .then(commandOptions => {\n        let config = this.project.config(commandOptions.environment);\n\n        this.ui.writeDeprecateLine(\n          'Using the `baseURL` setting is deprecated, use `rootURL` instead.',\n          !(!('rootURL' in config) && config.baseURL));\n\n        this.ui.writeWarnLine(\n          'The `baseURL` and `rootURL` settings should not be used at the same time.',\n          !(('rootURL' in config) && config.baseURL));\n\n        commandOptions = assign({}, commandOptions, {\n          rootURL: config.rootURL,\n          baseURL: config.baseURL || '/',\n        });\n\n        if (commandOptions.proxy) {\n          if (!commandOptions.proxy.match(/^(http:|https:)/)) {\n            let message = `You need to include a protocol with the proxy URL.${EOL}Try --proxy http://${commandOptions.proxy}`;\n\n            return Promise.reject(new SilentError(message));\n          }\n        }\n\n        let ServeTask = this.tasks.Serve;\n        let serve = new ServeTask({\n          ui: this.ui,\n          analytics: this.analytics,\n          project: this.project,\n        });\n\n        return Win.checkIfSymlinksNeedToBeEnabled(this.ui)\n          .then(() => serve.run(commandOptions));\n      });\n  },\n\n  _checkExpressPort(commandOptions) {\n    return getPort({ port: commandOptions.port, host: commandOptions.host }).then(foundPort => {\n\n      if (commandOptions.port !== foundPort && commandOptions.port !== 0) {\n        let message = `Port ${commandOptions.port} is already in use.`;\n        return Promise.reject(new SilentError(message));\n      }\n\n      // otherwise, our found port is good\n      commandOptions.port = foundPort;\n      return commandOptions;\n    });\n  },\n\n  _autoFindLiveReloadPort(commandOptions) {\n    return getPort({ port: commandOptions.liveReloadPort, host: commandOptions.liveReloadHost }).then(foundPort => {\n\n      // if live reload port matches express port, try one higher\n      if (foundPort === commandOptions.port) {\n        commandOptions.liveReloadPort = foundPort + 1;\n        return this._autoFindLiveReloadPort(commandOptions);\n      }\n\n      // port was already open\n      if (foundPort === commandOptions.liveReloadPort) {\n        return commandOptions;\n      }\n\n      // use found port as live reload port\n      commandOptions.liveReloadPort = foundPort;\n      return commandOptions;\n    });\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/windows-admin.js":"'use strict';\n\nconst Promise = require('rsvp').Promise;\nconst chalk = require('chalk');\n\nclass WindowsSymlinkChecker {\n  /**\n   *\n   * On windows users will have a much better experience if symlinks are enabled\n   * an usable. This object when queried informs windows users, if they can\n   * improve there build performance, and how.\n   *\n   *  > Windows vista: nothing we can really do, so we fall back to junctions for folders + copying of files\n   *  <= Windows vista: symlinks are available but using them is somewhat tricky\n   *    * if the users is an admin, the process needed to have been started with elevated privs\n   *    * if the user is not an admin, a specific setting needs to be enabled\n   *  <= Windows 10 Insiders build 14972\n   *    * if developer mode is enabled, symlinks \"just work\"\n   *    * https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10\n   *\n   * ```js\n   * let checker = WindowsSymlinkChecker;\n   * let {\n   *   windows,\n   *   elevated\n   * } = await = checker.checkIfSymlinksNeedToBeEnabled(); // aslso emits helpful warnings\n   * ```\n   *\n   * @public\n   * @class WindowsSymlinkChecker\n   */\n  constructor(ui, isWindows, canSymlink, exec) {\n    this.ui = ui;\n    this.isWindows = isWindows;\n    this.canSymlink = canSymlink;\n    this.exec = exec;\n  }\n\n  /**\n   *\n   * if not windows, will fulfill with:\n   *  `{ windows: false, elevated: null)`\n   *\n   * if windows, and elevated will fulfill with:\n   *  `{ windows: false, elevated: true)`\n   *\n   * if windows, and is NOT elevated will fulfill with:\n   *  `{ windows: false, elevated: false)`\n   *\n   *  will include heplful warning, so that users know (if possible) how to\n   *  achieve better windows build performance\n   *\n   * @public\n   * @method checkIfSymlinksNeedToBeEnabled\n   * @return {Promise<Object>} Object describing whether we're on windows and if admin rights exist\n   */\n  static checkIfSymlinksNeedToBeEnabled(ui) {\n    return this._setup(ui).checkIfSymlinksNeedToBeEnabled();\n  }\n\n  /**\n   * sets up a WindowsSymlinkChecker\n   *\n   * providing it with defaults for:\n   *\n   * * if we are on windows\n   * * if we can symlink\n   * * a reference to exec\n   *\n   * @private\n   * @method _setup\n   * @param UI {UI}\n   * @return {WindowsSymlinkChecker}\n   */\n  static _setup(ui) {\n    const exec = require('child_process').exec;\n    const symlinkOrCopy = require('symlink-or-copy');\n\n    return new WindowsSymlinkChecker(ui, (/^win/).test(process.platform), symlinkOrCopy.canSymlink, exec);\n  }\n\n\n  /**\n   * @public\n   * @method checkIfSymlinksNeedToBeEnabled\n   * @return {Promise<Object>} Object describing whether we're on windows and if admin rights exist\n   */\n  checkIfSymlinksNeedToBeEnabled() {\n    return new Promise(resolve => {\n      if (!this.isWindows) {\n        resolve({\n          windows: false,\n          elevated: null,\n        });\n      } else if (this.canSymlink) {\n        resolve({\n          windows: true,\n          elevated: null,\n        });\n      } else {\n        resolve(this._checkForElevatedRights(this.ui));\n      }\n    });\n  }\n\n  /**\n   *\n   * Uses the eon-old command NET SESSION to determine whether or not the\n   * current user has elevated rights (think sudo, but Windows).\n   *\n   * @private\n   * @method _checkForElevatedRights\n   * @param  {Object} ui - ui object used to call writeLine();\n   * @return {Object} Object describing whether we're on windows and if admin rights exist\n   */\n  _checkForElevatedRights() {\n    let ui = this.ui;\n    let exec = this.exec;\n\n    return new Promise(resolve => {\n      exec('NET SESSION', (error, stdout, stderr) => {\n        let elevated = (!stderr || stderr.length === 0);\n\n        if (!elevated) {\n          ui.writeLine(chalk.yellow('\\nRunning without permission to symlink will degrade build peformance.'));\n          ui.writeLine('See http://ember-cli.com/user-guide/#windows for details.\\n');\n        }\n\n        resolve({\n          windows: true,\n          elevated,\n        });\n      });\n    });\n  }\n}\n\nmodule.exports = WindowsSymlinkChecker;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/uninstall-npm.js":"'use strict';\n\nconst Command = require('../models/command');\nconst SilentError = require('silent-error');\nconst Promise = require('rsvp').Promise;\n\nmodule.exports = Command.extend({\n  name: 'uninstall:npm',\n  description: 'Npm package uninstall are now managed by the user.',\n  works: 'insideProject',\n  skipHelp: true,\n\n  anonymousOptions: [\n    '<package-names...>',\n  ],\n\n  run() {\n    let err = 'This command has been removed. Please use `npm uninstall ';\n    err += '<packageName> --save-dev` instead.';\n    return Promise.reject(new SilentError(err));\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/commands/version.js":"'use strict';\n\nconst Command = require('../models/command');\nconst emberCLIVersion = require('../utilities/version-utils').emberCLIVersion;\n\nmodule.exports = Command.extend({\n  name: 'version',\n  description: 'outputs ember-cli version',\n  aliases: ['v', '--version', '-v'],\n  works: 'everywhere',\n\n  availableOptions: [\n    { name: 'verbose', type: Boolean, default: false },\n  ],\n\n  run(options) {\n    this.printVersion('ember-cli', emberCLIVersion());\n\n    let versions = process.versions;\n    versions['os'] = `${process.platform} ${process.arch}`;\n\n    let alwaysPrint = ['node', 'os'];\n\n    for (let module in versions) {\n      if (options.verbose || alwaysPrint.indexOf(module) > -1) {\n        this.printVersion(module, versions[module]);\n      }\n    }\n  },\n\n  printVersion(module, version) {\n    this.ui.writeLine(`${module}: ${version}`);\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/errors/silent.js":"'use strict';\n\nconst SilentError = require('silent-error');\nconst deprecate = require('../utilities/deprecate');\n\nObject.defineProperty(module, 'exports', {\n  get() {\n    // Get the call stack so we can let the user know what module is using the deprecated function.\n    let stack = new Error().stack;\n    stack = stack.split('\\n')[5];\n    stack = stack.replace('    at ', '  ');\n\n    deprecate(`\\`ember-cli/lib/errors/silent.js\\` is deprecated, use \\`silent-error\\` instead. Required here: \\n${stack.toString()}`, true);\n    return SilentError;\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/deprecate.js":"'use strict';\n\nconst chalk = require('chalk');\n\nmodule.exports = function(message, test) {\n  if (test) {\n    console.log(chalk.yellow(`DEPRECATION: ${message}`));\n  }\n};\n\nmodule.exports.deprecateUI = function(ui) {\n  return function(message, test) {\n    ui.writeDeprecateLine('The deprecateUI utility has been deprecated in favor of ui.writeDeprecateLine');\n\n    test = !test;\n\n    ui.writeDeprecateLine(message, test);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/ext/promise.js":"'use strict';\n\nconst RSVP = require('rsvp');\nlet Promise = RSVP.Promise;\n\nconst deprecate = require('../utilities/deprecate');\n\nfunction PromiseExt(resolver, label) {\n  this._superConstructor(resolver, label);\n}\n\n// Utility functions on the native CTOR need some massaging\nPromiseExt.hash = function() {\n  return this.resolve(RSVP.hash.apply(null, arguments));\n};\n\nPromiseExt.denodeify = function() {\n  let fn = RSVP.denodeify.apply(null, arguments);\n  let Constructor = this;\n  let newFn = function() {\n    return Constructor.resolve(fn.apply(null, arguments));\n  };\n  newFn.__proto__ = arguments[0];\n  return newFn;\n};\n\nPromiseExt.filter = function() {\n  return this.resolve(RSVP.filter.apply(null, arguments));\n};\n\nPromiseExt.map = function() {\n  return this.resolve(RSVP.map.apply(null, arguments));\n};\n\nPromiseExt.prototype = Object.create(Promise.prototype);\nPromiseExt.prototype.constructor = PromiseExt;\nPromiseExt.prototype._superConstructor = Promise;\nPromiseExt.__proto__ = Promise;\n\nPromiseExt.prototype.returns = function(value) {\n  return this.then(() => value);\n};\n\nPromiseExt.prototype.invoke = function(method) {\n  let args = Array.prototype.slice(arguments, 1);\n\n  return this.then(value => value[method].apply(value, args), undefined, `invoke: ${method} with: ${args}`);\n};\n\nfunction constructorMethod(promise, methodName, fn) {\n  let Constructor = promise.constructor;\n\n  return promise.then(values => Constructor[methodName](values, fn));\n}\n\nPromiseExt.prototype.map = function(mapFn) {\n  return constructorMethod(this, 'map', mapFn);\n};\n\nPromiseExt.prototype.filter = function(filterFn) {\n  return constructorMethod(this, 'filter', filterFn);\n};\n\nObject.defineProperty(module, 'exports', {\n  get() {\n    // Get the call stack so we can let the user know what module is using the deprecated function.\n    let stack = new Error().stack;\n    stack = stack.split('\\n')[5];\n    stack = stack.replace('    at ', '  ');\n\n    deprecate(`\\`ember-cli/ext/promise\\` is deprecated, use \\`rsvp\\` instead. Required here: \\n${stack.toString()}`, true);\n    return PromiseExt;\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/addon-discovery.js":"'use strict';\n\n/**\n@module ember-cli\n*/\n\nconst assign = require('ember-cli-lodash-subset').assign;\nlet logger = require('heimdalljs-logger')('ember-cli:addon-discovery');\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst resolve = require('resolve');\nconst findup = require('find-up');\nconst heimdall = require('heimdalljs');\n\n/**\n  AddonDiscovery is responsible for collecting information about all of the\n  addons that will be used with a project.\n\n  @class AddonDiscovery\n  @extends CoreObject\n  @constructor\n*/\nclass AddonDiscovery {\n  constructor(ui) {\n    this.ui = ui;\n  }\n\n  /**\n    This is one of the primary APIs for this class and is called by the project.\n    It returns a tree of plain objects that each contain information about a\n    discovered addon. Each node has `name`, `path`, `pkg` and\n    `childAddons` properties. The latter is an array containing any addons\n    discovered from applying the discovery process to that addon.\n\n    @private\n    @method discoverProjectAddons\n   */\n  discoverProjectAddons(project) {\n    let token = heimdall.start({\n      name: `${project.name()}: addon-discovery`,\n      addonDiscoveryNode: true,\n    });\n    let projectAsAddon = this.discoverFromProjectItself(project);\n    let internalAddons = this.discoverFromInternalProjectAddons(project);\n    let cliAddons = this.discoverFromCli(project.cli);\n    let dependencyAddons;\n\n    if (project.hasDependencies()) {\n      dependencyAddons = this.discoverFromDependencies(project.root, project.nodeModulesPath, project.pkg, false);\n    } else {\n      dependencyAddons = [];\n    }\n\n    let inRepoAddons = this.discoverInRepoAddons(project.root, project.pkg);\n    let addons = projectAsAddon.concat(cliAddons, internalAddons, dependencyAddons, inRepoAddons);\n\n    token.stop();\n    return addons;\n  }\n\n  /**\n    This is one of the primary APIs for this class and is called by addons.\n    It returns a tree of plain objects that each contain information about a\n    discovered addon. Each node has `name`, `path`, `pkg` and\n    `childAddons` properties. The latter is an array containing any addons\n    discovered from applying the discovery process to that addon.\n\n    @private\n    @method discoverProjectAddons\n  */\n  discoverChildAddons(addon) {\n    let token = heimdall.start({\n      name: `${addon.name}: addon-discovery`,\n      addonDiscoveryNode: true,\n    });\n    logger.info('discoverChildAddons: %s(%s)', addon.name, addon.root);\n    let dependencyAddons = this.discoverFromDependencies(addon.root, addon.nodeModulesPath, addon.pkg, true);\n    let inRepoAddons = this.discoverInRepoAddons(addon.root, addon.pkg);\n    let addons = dependencyAddons.concat(inRepoAddons);\n\n    addons = addons.filter(childAddon => !addon.shouldIncludeChildAddon || addon.shouldIncludeChildAddon(childAddon));\n\n    token.stop();\n    return addons;\n  }\n\n  /**\n    Returns an array containing zero or one nodes, depending on whether or not\n    the passed project is an addon.\n\n    @private\n    @method discoverFromProjectItself\n   */\n  discoverFromProjectItself(project) {\n    if (project.isEmberCLIAddon()) {\n      let addonPkg = this.discoverAtPath(project.root);\n      if (addonPkg) {\n        return [addonPkg];\n      }\n    }\n    return [];\n  }\n\n  /**\n    Returns a tree based on the addons referenced in the provided `pkg` through\n    the package.json `dependencies` and optionally `devDependencies` collections,\n    as well as those discovered addons' child addons.\n\n    @private\n    @method discoverFromDependencies\n   */\n  discoverFromDependencies(root, nodeModulesPath, pkg, excludeDevDeps) {\n    let discovery = this;\n    let addons = Object.keys(this.dependencies(pkg, excludeDevDeps)).map(function(name) {\n      if (name !== 'ember-cli') {\n        let addonPath = this.resolvePackage(root, name);\n\n        if (addonPath) {\n          return discovery.discoverAtPath(addonPath);\n        }\n\n        // this supports packages that do not have a valid entry point\n        // script (aka `main` entry in `package.json` or `index.js`)\n        addonPath = path.join(nodeModulesPath, name);\n        let addon = discovery.discoverAtPath(addonPath);\n        if (addon) {\n          const chalk = require('chalk');\n\n          discovery.ui.writeLine(chalk.yellow(`The package \\`${name}\\` is not a properly formatted package, we have used a fallback lookup to resolve it at \\`${addonPath}\\`. This is generally caused by an addon not having a \\`main\\` entry point (or \\`index.js\\`).`), 'WARNING');\n\n          return addon;\n        }\n      }\n    }, this).filter(Boolean);\n    return addons;\n  }\n\n  resolvePackage(root, packageName) {\n    try {\n\n      let entryModulePath = resolve.sync(packageName, { basedir: root });\n\n      let pkgPath = findup.sync('package.json', { cwd: entryModulePath });\n      if (pkgPath) {\n        return path.dirname(pkgPath);\n      }\n\n    } catch (e) {\n      let acceptableError = `Cannot find module '${packageName}' from '${root}'`;\n      // pending: https://github.com/substack/node-resolve/pull/80\n      let workAroundError = 'Cannot read property \\'isFile\\' of undefined';\n\n      if (e.message === workAroundError || e.message === acceptableError) {\n        return;\n      }\n      throw e;\n    }\n  }\n\n  /**\n    Returns a tree based on the in-repo addons referenced in the provided `pkg`\n    through paths listed in the `ember-addon` entry, as well as those discovered\n    addons' child addons.\n\n    @private\n    @method discoverInRepoAddons\n   */\n  discoverInRepoAddons(root, pkg) {\n    if (!pkg || !pkg['ember-addon'] || !pkg['ember-addon'].paths) {\n      return [];\n    }\n\n    return pkg['ember-addon'].paths\n      .map(addonPath => this.discoverAtPath(path.join(root, addonPath)))\n      .filter(Boolean);\n  }\n\n  /**\n    Returns a tree based on the internal addons that may be defined within the project.\n    It does this by consulting the projects `supportedInternalAddonPaths()` method, which\n    is primarily used for middleware addons.\n\n    @private\n    @method discoverFromInternalProjectAddons\n   */\n  discoverFromInternalProjectAddons(project) {\n    return project.supportedInternalAddonPaths()\n      .map(path => this.discoverAtPath(path))\n      .filter(Boolean);\n  }\n\n  discoverFromCli(cli) {\n    if (!cli) { return []; }\n\n    const cliPkg = require(path.resolve(cli.root, 'package.json'));\n    return this.discoverInRepoAddons(cli.root, cliPkg);\n  }\n\n  /**\n    Given a particular path, return undefined if the path is not an addon, or if it is,\n    a node with the info about the addon.\n\n    @private\n    @method discoverAtPath\n   */\n  discoverAtPath(addonPath) {\n    let pkgPath = path.join(addonPath, 'package.json');\n    logger.info('attemping to add: %s', addonPath);\n\n    if (existsSync(pkgPath)) {\n      const addonPkg = require(pkgPath);\n      let keywords = addonPkg.keywords || [];\n      logger.info(' - module found: %s', addonPkg.name);\n\n      addonPkg['ember-addon'] = addonPkg['ember-addon'] || {};\n\n      if (keywords.indexOf('ember-addon') > -1) {\n        logger.info(' - is addon, adding...');\n        let addonInfo = {\n          name: addonPkg.name,\n          path: addonPath,\n          pkg: addonPkg,\n        };\n        return addonInfo;\n      } else {\n        logger.info(' - no ember-addon keyword, not including.');\n      }\n    } else {\n      logger.info(` - no package.json (looked at ${pkgPath}).`);\n    }\n\n    return null;\n  }\n\n  /**\n    Returns the dependencies from a package.json\n    @private\n    @method dependencies\n    @param  {Object}  pkg            Package object. If false, the current package is used.\n    @param  {Boolean} excludeDevDeps Whether or not development dependencies should be excluded, defaults to false.\n    @return {Object}                 Dependencies\n   */\n  dependencies(pkg, excludeDevDeps) {\n    pkg = pkg || {};\n\n    let devDependencies = pkg['devDependencies'];\n    if (excludeDevDeps) {\n      devDependencies = {};\n    }\n\n    return assign({}, devDependencies, pkg['dependencies']);\n  }\n\n  addonPackages(addonsList) {\n    let addonPackages = {};\n\n    addonsList.forEach(addonPkg => {\n      addonPackages[addonPkg.name] = addonPkg;\n    });\n\n    return addonPackages;\n  }\n}\n\nmodule.exports = AddonDiscovery;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/addons-factory.js":"'use strict';\n\n/**\n@module ember-cli\n*/\n\nconst DAG = require('../utilities/DAG');\nlet logger = require('heimdalljs-logger')('ember-cli:addons-factory');\nconst heimdall = require('heimdalljs');\n\n/**\n  AddonsFactory is responsible for instantiating a collection of addons, in the right order.\n\n  @class AddonsFactory\n  @extends CoreObject\n  @constructor\n*/\nclass AddonsFactory {\n  constructor(addonParent, project) {\n    this.addonParent = addonParent;\n    this.project = project;\n  }\n\n  initializeAddons(addonPackages) {\n    let addonParent = this.addonParent;\n    let project = this.project;\n    let addonParentName = typeof addonParent.name === 'function' ? addonParent.name() : addonParent.name;\n\n    let initializeAddonsToken = heimdall.start(`${addonParentName}: initializeAddons`);\n    let graph = new DAG();\n    const Addon = require('../models/addon');\n    let addonInfo, emberAddonConfig;\n\n    logger.info('initializeAddons for: ', addonParentName);\n    logger.info('     addon names are:', Object.keys(addonPackages));\n\n    for (let name in addonPackages) {\n      addonInfo = addonPackages[name];\n      emberAddonConfig = addonInfo.pkg['ember-addon'];\n\n      graph.addEdges(name, addonInfo, emberAddonConfig.before, emberAddonConfig.after);\n    }\n\n    let addons = [];\n    graph.topsort(vertex => {\n      let addonInfo = vertex.value;\n      if (addonInfo) {\n        let initializeAddonToken = heimdall.start({\n          name: `initialize ${addonInfo.name}`,\n          addonName: addonInfo.name,\n          addonInitializationNode: true,\n        });\n        let start = Date.now();\n        let AddonConstructor = Addon.lookup(addonInfo);\n        let addon = new AddonConstructor(addonParent, project);\n        if (addon.initializeAddons) {\n          addon.initializeAddons();\n        } else {\n          addon.addons = [];\n        }\n        AddonConstructor._meta_.initializeIn = Date.now() - start;\n        addon.constructor = AddonConstructor;\n        initializeAddonToken.stop();\n        addons.push(addon);\n      }\n    });\n\n    logger.info(' addon info %o', addons.map(addon => ({\n      name: addon.name,\n      times: {\n        initialize: addon.constructor._meta_.initializeIn,\n        lookup: addon.constructor._meta_.lookupIn,\n      },\n    })));\n\n    initializeAddonsToken.stop();\n\n    return addons;\n  }\n}\n\nmodule.exports = AddonsFactory;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/DAG.js":"'use strict';\n\nfunction visit(vertex, fn, visited, path) {\n  let name = vertex.name,\n      vertices = vertex.incoming,\n      names = vertex.incomingNames,\n      len = names.length,\n      i;\n  if (!visited) {\n    visited = {};\n  }\n  if (!path) {\n    path = [];\n  }\n  if (visited.hasOwnProperty(name)) {\n    return;\n  }\n  path.push(name);\n  visited[name] = true;\n  for (i = 0; i < len; i++) {\n    visit(vertices[names[i]], fn, visited, path);\n  }\n  fn(vertex, path);\n  path.pop();\n}\n\nclass DAG {\n  /**\n   * Directed acyclic graph.\n   *\n   * see [Wikipedia](https://en.wikipedia.org/wiki/Directed_acyclic_graph).\n   *\n   * @class DAG\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Array of all known vertex names.\n     *\n     * @final\n     * @property names\n     * @type Array\n     */\n    this.names = [];\n\n    /**\n     * Hash of vertices keyed by name.\n     *\n     * @final\n     * @property vertices\n     * @type Object\n     */\n    this.vertices = {};\n  }\n\n  /**\n   * Adds a new vertex to the graph.\n   *\n   * @method add\n   * @param {String} name Name of the vertex\n   * @return {Object|undefined} The new vertex or the already existing vertex with the same name\n   */\n  add(name) {\n    if (!name) { return; }\n    if (this.vertices.hasOwnProperty(name)) {\n      return this.vertices[name];\n    }\n    let vertex = {\n      name,\n      incoming: {},\n      incomingNames: [],\n      hasOutgoing: false,\n      value: null,\n    };\n\n    this.vertices[name] = vertex;\n    this.names.push(name);\n    return vertex;\n  }\n\n  /**\n   * Assigns `value` to the vertex named `name`.\n   *\n   * Creates a new vertex if a vertex named `name` does not exist yet.\n   *\n   * @method map\n   * @param {String} name Name of the vertex\n   * @param {any} value Value of the vertex\n   */\n  map(name, value) {\n    this.add(name).value = value;\n  }\n\n  /**\n   * Adds an edge between two vertices.\n   *\n   * @method addEdge\n   * @param fromName Name of the `from` vertex\n   * @param toName Name of the `to` vertex\n   * @throws {Error} if a cycle is detected\n   */\n  addEdge(fromName, toName) {\n    if (!fromName || !toName || fromName === toName) {\n      return;\n    }\n    let from = this.add(fromName), to = this.add(toName);\n    if (to.incoming.hasOwnProperty(fromName)) {\n      return;\n    }\n    function checkCycle(vertex, path) {\n      if (vertex.name === toName) {\n        throw new Error(`cycle detected: ${toName} <- ${path.join(' <- ')}`);\n      }\n    }\n    visit(from, checkCycle);\n    from.hasOutgoing = true;\n    to.incoming[fromName] = from;\n    to.incomingNames.push(fromName);\n  }\n\n  /**\n   * Traverses the graph depth-first.\n   *\n   * Each vertex will only be visited once even if it has multiple parent vertices.\n   *\n   * @method topsort\n   * @param {Function} fn Function that is called with each vertex and the path to it\n   */\n  topsort(fn) {\n    let visited = {},\n        vertices = this.vertices,\n        names = this.names,\n        len = names.length,\n        i, vertex;\n    for (i = 0; i < len; i++) {\n      vertex = vertices[names[i]];\n      if (!vertex.hasOutgoing) {\n        visit(vertex, fn, visited);\n      }\n    }\n  }\n\n  /**\n   * Assigns `value` to the vertex named `name` and creates the edges defined by `before` and `after`.\n   *\n   * @method addEdges\n   * @param {String} name Name of the vertex\n   * @param {any} value Value of the vertex\n   * @param {String|Array} before Adds edges from `name` to each of `before`\n   * @param {String|Array} after Adds edges from each of `after` to `name`\n   */\n  addEdges(name, value, before, after) {\n    let i;\n    this.map(name, value);\n    if (before) {\n      if (typeof before === 'string') {\n        this.addEdge(name, before);\n      } else {\n        for (i = 0; i < before.length; i++) {\n          this.addEdge(name, before[i]);\n        }\n      }\n    }\n    if (after) {\n      if (typeof after === 'string') {\n        this.addEdge(after, name);\n      } else {\n        for (i = 0; i < after.length; i++) {\n          this.addEdge(after[i], name);\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = DAG;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/builder.js":"'use strict';\nconst exit = require('capture-exit');\nexit.captureExit();\n\nconst fs = require('fs-extra');\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst Promise = require('rsvp').Promise;\nconst CoreObject = require('core-object');\nconst SilentError = require('silent-error');\nconst chalk = require('chalk');\nconst attemptNeverIndex = require('../utilities/attempt-never-index');\nconst findBuildFile = require('../utilities/find-build-file');\nconst _resetTreeCache = require('./addon')._resetTreeCache;\n\nconst Sync = require('tree-sync');\nconst heimdall = require('heimdalljs');\n\n/**\n * Wrapper for the Broccoli [Builder](https://github.com/broccolijs/broccoli/blob/master/lib/builder.js) class.\n *\n * @private\n * @module ember-cli\n * @class Builder\n * @constructor\n * @extends Task\n */\nclass Builder extends CoreObject {\n\n  constructor(options) {\n    super(options);\n\n    this.setupBroccoliBuilder();\n    this.trapSignals();\n    this._instantiationStack = (new Error()).stack.replace(/[^\\n]*\\n/, '');\n  }\n\n  /**\n   * @private\n   * @method setupBroccoliBuilder\n   */\n  setupBroccoliBuilder() {\n    this.environment = this.environment || 'development';\n    process.env.EMBER_ENV = process.env.EMBER_ENV || this.environment;\n\n    const broccoli = require('broccoli-builder');\n    let hasBrocfile = existsSync(path.join('.', 'Brocfile.js'));\n    let buildFile = findBuildFile('ember-cli-build.js');\n\n    if (hasBrocfile) {\n      this.ui.writeDeprecateLine('Brocfile.js has been deprecated in favor of ember-cli-build.js. Please see the transition guide: https://github.com/ember-cli/ember-cli/blob/master/TRANSITION.md#user-content-brocfile-transition.');\n      this.tree = require('broccoli-brocfile-loader')();\n    } else if (buildFile) {\n      this.tree = buildFile({ project: this.project });\n    } else {\n      throw new Error('No ember-cli-build.js found. Please see the transition guide: https://github.com/ember-cli/ember-cli/blob/master/TRANSITION.md#user-content-brocfile-transition.');\n    }\n\n    this.builder = new broccoli.Builder(this.tree);\n  }\n\n  /**\n   * @private\n   * @method trapSignals\n   */\n  trapSignals() {\n    this._boundOnSIGINT = this.onSIGINT.bind(this);\n    this._boundOnSIGTERM = this.onSIGTERM.bind(this);\n    this._boundOnMessage = this.onMessage.bind(this);\n    this._boundCleanup = this.cleanup.bind(this);\n\n    process.on('SIGINT', this._boundOnSIGINT);\n    process.on('SIGTERM', this._boundOnSIGTERM);\n    process.on('message', this._boundOnMessage);\n    exit.onExit(this._boundCleanup);\n\n    if (/^win/.test(process.platform)) {\n      this.trapWindowsSignals();\n    }\n  }\n\n  _cleanupSignals() {\n    process.removeListener('SIGINT', this._boundOnSIGINT);\n    process.removeListener('SIGTERM', this._boundOnSIGTERM);\n    process.removeListener('message', this._boundOnMessage);\n    exit.offExit(this._boundCleanup);\n\n    if (/^win/.test(process.platform)) {\n      this._cleanupWindowsSignals();\n    }\n  }\n\n  /**\n   * @private\n   * @method trapWindowsSignals\n   */\n  trapWindowsSignals() {\n    // This is required to capture Ctrl + C on Windows\n    if (process.stdin && process.stdin.isTTY) {\n      process.stdin.setRawMode(true);\n      this._windowsCtrlCTrap = function(data) {\n        if (data.length === 1 && data[0] === 0x03) {\n          process.emit('SIGINT');\n        }\n      };\n      process.stdin.on('data', this._windowsCtrlCTrap);\n    }\n  }\n\n  _cleanupWindowsSignals() {\n    if (this._windowsCtrlCTrap && process.stdin.removeListener) {\n      process.stdin.removeListener('data', this._windowsCtrlCTrap);\n    }\n  }\n\n  /**\n    Determine whether the output path is safe to delete. If the outputPath\n    appears anywhere in the parents of the project root, the build would\n    delete the project directory. In this case return `false`, otherwise\n    return `true`.\n\n    @private\n    @method canDeleteOutputPath\n    @param {String} outputPath\n    @return {Boolean}\n  */\n  canDeleteOutputPath(outputPath) {\n    let rootPathParents = [this.project.root];\n    let dir = path.dirname(this.project.root);\n    rootPathParents.push(dir);\n    while (dir !== path.dirname(dir)) {\n      dir = path.dirname(dir);\n      rootPathParents.push(dir);\n    }\n    return rootPathParents.indexOf(outputPath) === -1;\n  }\n\n  /**\n   * @private\n   * @method copyToOutputPath\n   * @param {String} inputPath\n   */\n  copyToOutputPath(inputPath) {\n    let outputPath = this.outputPath;\n\n    fs.mkdirsSync(outputPath);\n\n    if (!this.canDeleteOutputPath(outputPath)) {\n      throw new SilentError(`Using a build destination path of \\`${outputPath}\\` is not supported.`);\n    }\n\n    let sync = this._sync;\n    if (sync === undefined) {\n      this._sync = sync = new Sync(inputPath, path.resolve(this.outputPath));\n    }\n\n    let changes = sync.sync();\n\n    return changes.map(op => op[1]);\n  }\n\n  /**\n   * @private\n   * @method processBuildResult\n   * @param results\n   * @return {Promise}\n   */\n  processBuildResult(results) {\n    let self = this;\n\n    return Promise.resolve()\n      .then(() => self.copyToOutputPath(results.directory))\n      .then(syncResult => {\n        results.outputChanges = syncResult;\n        return results;\n      });\n  }\n\n  /**\n   * @private\n   * @method processAddonBuildSteps\n   * @param buildStep\n   * @param results\n   * @return {Promise}\n   */\n  processAddonBuildSteps(buildStep, results) {\n    let addonPromises = [];\n    if (this.project && this.project.addons.length) {\n      addonPromises = this.project.addons.map(addon => {\n        if (addon[buildStep]) {\n          return addon[buildStep](results);\n        }\n      }).filter(Boolean);\n    }\n\n    return Promise.all(addonPromises).then(() => results);\n  }\n\n  /**\n   * @private\n   * @method build\n   * @return {Promise}\n   */\n  build(willReadStringDir, resultAnnotation) {\n    this.project._instrumentation.start('build');\n\n    let self = this;\n    attemptNeverIndex('tmp');\n\n    return this.processAddonBuildSteps('preBuild')\n      .then(() => self.builder.build(willReadStringDir))\n      .then(this.processAddonBuildSteps.bind(this, 'postBuild'))\n      .then(this.processBuildResult.bind(this))\n      .then(this.processAddonBuildSteps.bind(this, 'outputReady'))\n      .then(result => {\n        self.project._instrumentation.stopAndReport('build', result, resultAnnotation);\n        return result;\n      }, reason => {\n        self.project._instrumentation.stopAndReport('build', null, resultAnnotation);\n        throw reason;\n      })\n      .then(this.checkForPostBuildEnvironmentIssues.bind(this))\n      .catch(error => {\n        this.processAddonBuildSteps('buildError', error);\n        throw error;\n      });\n  }\n\n  /**\n   * Delegates to the `cleanup` method of the wrapped Broccoli builder.\n   *\n   * @private\n   * @method cleanup\n   * @return {Promise}\n   */\n  cleanup() {\n    let ui = this.project.ui;\n    ui.startProgress('cleaning up');\n    ui.writeLine('cleaning up...');\n\n    // ensure any addon treeFor caches are reset\n    _resetTreeCache();\n\n    this._cleanupSignals();\n\n    let node = heimdall.start({ name: 'Builder Cleanup' });\n\n    return this.builder.cleanup().finally(() => {\n      ui.stopProgress();\n      node.stop();\n    }).catch(err => {\n      ui.writeLine(chalk.red('Cleanup error.'));\n      ui.writeError(err);\n    });\n  }\n\n  /**\n   * Checks for issues in the environment that can't easily be detected until\n   * after a build and issues any necessary deprecation warnings.\n   *\n   * - check for old (pre 0.1.4) versions of heimdalljs\n   *\n   * @private\n   * @method checkForPostBuildEnvironmentIssues\n   */\n  checkForPostBuildEnvironmentIssues(value) {\n    // 0.1.3 and prior used a global heimdall instance to share sessions\n    // newer versions keep the session itself on process\n    this.project.ui.writeDeprecateLine('Heimdalljs < 0.1.4 found.  Please remove old versions of heimdalljs and reinstall (you can find them with `npm ls heimdalljs` as long as you have nothing `npm link`d).  Performance instrumentation data will be incomplete until then.', !process._heimdall);\n\n    return value;\n  }\n\n  /**\n   * Handles the `SIGINT` signal.\n   *\n   * Calls {{#crossLink \"Builder/cleanupAndExit:method\"}}{{/crossLink}} by default.\n   *\n   * @private\n   * @method onSIGINT\n   */\n  onSIGINT() {\n    process.exit(1);\n  }\n\n  /**\n   * Handles the `SIGTERM` signal.\n   *\n   * Calls {{#crossLink \"Builder/cleanupAndExit:method\"}}{{/crossLink}} by default.\n   *\n   * @private\n   * @method onSIGTERM\n   */\n  onSIGTERM() {\n    process.exit(1);\n  }\n\n  /**\n   * Handles the `message` event on the `process`.\n   *\n   * Calls `process.exit` if the `kill` property on the `message` is set.\n   *\n   * @private\n   * @method onMessage\n   */\n  onMessage(message) {\n    if (message.kill) {\n      process.exit(1);\n    }\n  }\n}\n\nmodule.exports = Builder;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/attempt-never-index.js":"'use strict';\n\nlet isDarwin = (/darwin/i).test(require('os').type());\nlet logger = require('heimdalljs-logger')('ember-cli:utilities/attempt-metadata-index-file');\n\n/*\n * Writes a `.metadata_never_index` file to the specified folder if running on OS X.\n *\n * This hints to spotlight that this folder should not be indexed.\n *\n * @param {String} dir path to the folder that should not be indexed\n */\nmodule.exports = function(dir) {\n  let path = `${dir}/.metadata_never_index`;\n\n  if (!isDarwin) {\n    logger.info('not darwin, skipping %s (which hints to spotlight to prevent indexing)', path);\n    return;\n  }\n\n  logger.info('creating: %s (to prevent spotlight indexing)', path);\n\n  const fs = require('fs-extra');\n\n  fs.mkdirsSync(dir);\n  fs.writeFileSync(path);\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/find-build-file.js":"'use strict';\n\nconst findUp = require('find-up');\nconst path = require('path');\n\nmodule.exports = function(file) {\n  let buildFilePath = findUp.sync(file);\n\n  // Note: In the future this should throw\n  if (!buildFilePath) {\n    return null;\n  }\n\n  process.chdir(path.dirname(buildFilePath));\n\n  let buildFile = null;\n  try {\n    buildFile = require(buildFilePath);\n  } catch (err) {\n    err.message = `Could not require '${file}': ${err.message}`;\n    throw err;\n  }\n\n  return buildFile;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/addon.js":"'use strict';\n\n/**\n@module ember-cli\n*/\n\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst assign = require('ember-cli-lodash-subset').assign;\nconst SilentError = require('silent-error');\nconst heimdallLogger = require('heimdalljs-logger');\nlet logger = heimdallLogger('ember-cli:addon');\nlet treeCacheLogger = heimdallLogger('ember-cli:addon:tree-cache');\nlet cacheKeyLogger = heimdallLogger('ember-cli:addon:cache-key-for-tree');\n\nconst nodeModulesPath = require('node-modules-path');\n\nconst p = require('ember-cli-preprocess-registry/preprocessors');\nlet preprocessJs = p.preprocessJs;\nlet preprocessCss = p.preprocessCss;\nlet preprocessTemplates = p.preprocessTemplates;\n\nconst AddonDiscovery = require('../models/addon-discovery');\nconst AddonsFactory = require('../models/addons-factory');\nconst CoreObject = require('core-object');\nconst Project = require('./project');\n\nconst mergeTrees = require('../broccoli/merge-trees');\nconst Funnel = require('broccoli-funnel');\nconst walkSync = require('walk-sync');\nconst ensurePosixPath = require('ensure-posix-path');\nconst defaultsDeep = require('ember-cli-lodash-subset').defaultsDeep;\nconst findAddonByName = require('../utilities/find-addon-by-name');\nconst experiments = require('../experiments');\nconst heimdall = require('heimdalljs');\nconst calculateCacheKeyForTree = require('calculate-cache-key-for-tree');\nconst addonProcessTree = require('../utilities/addon-process-tree');\n\nif (!heimdall.hasMonitor('addon-tree-cache')) {\n  heimdall.registerMonitor('addon-tree-cache', function AddonTreeCacheSchema() {\n    this.hits = 0;\n    this.misses = 0;\n    this.adds = 0;\n  });\n}\n\nif (!heimdall.hasMonitor('cache-key-for-tree')) {\n  heimdall.registerMonitor('cache-key-for-tree', function CacheKeyForTreeSchema() {\n    this.modifiedMethods = 0;\n    this.treeForMethodsOverride = 0;\n  });\n}\n\nlet DEFAULT_BABEL_CONFIG = {\n  modules: 'amdStrict',\n  moduleIds: true,\n  resolveModuleSource: require('amd-name-resolver').moduleResolve,\n};\n\nlet DEFAULT_TREE_FOR_METHODS = {\n  app: 'treeForApp',\n  addon: 'treeForAddon',\n  'addon-styles': 'treeForAddonStyles',\n  'addon-templates': 'treeForAddonTemplates',\n  'addon-test-support': 'treeForAddonTestSupport',\n  public: 'treeForPublic',\n  styles: 'treeForStyles',\n  templates: 'treeForTemplates',\n  'test-support': 'treeForTestSupport',\n  vendor: 'treeForVendor',\n};\n\nlet GLOBAL_TREE_FOR_METHOD_METHODS = ['treeFor', '_treeFor', 'treeGenerator'];\nlet DEFAULT_TREE_FOR_METHOD_METHODS = {\n  app: ['treeForApp'],\n  addon: [\n    'treeForAddon', 'treeForAddonStyles', 'treeForAddonTemplates',\n    'compileAddon', 'processedAddonJsFiles', 'compileTemplates',\n    '_addonTemplateFiles', 'compileStyles', 'preprocessJs',\n    'addonJsFiles',\n  ],\n  'addon-styles': ['treeForAddonStyles'],\n  'addon-templates': ['treeForAddonTemplates'],\n  'addon-test-support': ['treeForAddonTestSupport', 'preprocessJs'],\n  public: ['treeForPublic'],\n  styles: ['treeForStyles'],\n  templates: ['treeForTemplates'],\n  'test-support': ['treeForTestSupport'],\n  vendor: ['treeForVendor'],\n};\n\nlet ADDON_TREE_CACHE = {\n  __cache: Object.create(null),\n\n  getItem(key) {\n    let addonTreeCacheStats = heimdall.statsFor('addon-tree-cache');\n    let cachedValue = this.__cache[key];\n\n    if (cachedValue) {\n      addonTreeCacheStats.hits++;\n      treeCacheLogger.info(`Cache Hit: ${key}`);\n      return cachedValue;\n    } else {\n      addonTreeCacheStats.misses++;\n      treeCacheLogger.info(`Cache Miss: ${key}`);\n      return null;\n    }\n  },\n\n  setItem(key, value) {\n    let hasValue = !!value;\n    heimdall.statsFor('addon-tree-cache').adds++;\n    treeCacheLogger.info(`Cache Add: ${key} - ${hasValue}`);\n    this.__cache[key] = value;\n  },\n\n  clear() {\n    this.__cache = Object.create(null);\n  },\n};\n\nfunction _resetTreeCache() {\n  ADDON_TREE_CACHE.clear();\n}\n\nfunction warn(message) {\n  if (this.ui) {\n    this.ui.writeDeprecateLine(message);\n  } else {\n    const chalk = require('chalk');\n    console.log(chalk.yellow(`DEPRECATION: ${message}`));\n  }\n}\n\nfunction deprecatedAddonFilters(addon, name, insteadUse, fn) {\n  return function(tree, options) {\n    let message = `${name} is deprecated, please use ${insteadUse} directly instead  [addon: ${addon.name}]`;\n\n    warn(this, message);\n\n    return fn(tree, options);\n  };\n}\n\nfunction processModulesOnly(tree) {\n  let options = defaultsDeep({}, DEFAULT_BABEL_CONFIG);\n  options.whitelist = ['es6.modules'];\n\n  const Babel = require('broccoli-babel-transpiler');\n  return new Babel(tree, options);\n}\n\nfunction registryHasPreprocessor(registry, type) {\n  return registry.load(type).length > 0;\n}\n\n/**\n  Root class for an Addon. If your addon module exports an Object this\n  will be extended from this base class. If you export a constructor (function),\n  it will **not** extend from this class.\n\n  Hooks:\n\n  - {{#crossLink \"Addon/config:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/blueprintsPath:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/includedCommands:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/serverMiddleware:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/testemMiddleware:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/postBuild:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/preBuild:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/outputReady:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/buildError:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/included:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/shouldIncludeChildAddon:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/setupPreprocessorRegistry:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/preprocessTree:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/postprocessTree:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/lintTree:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/contentFor:method\"}}{{/crossLink}}\n  - {{#crossLink \"Addon/treeFor:method\"}}{{/crossLink}}\n\n  @class Addon\n  @extends CoreObject\n  @constructor\n  @param {Project|Addon} parent The project or addon that directly depends on this addon\n  @param {Project} project The current project (deprecated)\n*/\nlet addonProto = {\n\n  /**\n  Initializes the addon.  If you override this method make sure and call `this._super.init && this._super.init.apply(this, arguments);` or your addon will not work.\n\n  @public\n  @method init\n  @param {Project|Addon} parent The project or addon that directly depends on this addon\n  @param {Project} project The current project (deprecated)\n\n  @example\n  ```js\n  init(parent, project) {\n    this._super.init && this._super.init.apply(this, arguments);\n    this._someCustomSetup();\n  }\n  ```\n  */\n  init(parent, project) {\n    this._super();\n    this.parent = parent;\n    this.project = project;\n    this.ui = project && project.ui;\n    this.addonPackages = {};\n    this.addons = [];\n    this.addonDiscovery = new AddonDiscovery(this.ui);\n    this.addonsFactory = new AddonsFactory(this, this.project);\n    this.registry = p.defaultRegistry(this);\n    this._didRequiredBuildPackages = false;\n\n    if (!this.root) {\n      throw new Error('Addon classes must be instantiated with the `root` property');\n    }\n    this.nodeModulesPath = nodeModulesPath(this.root);\n\n    this.treePaths = {\n      app: 'app',\n      styles: 'app/styles',\n      templates: 'app/templates',\n      addon: 'addon',\n      'addon-styles': 'addon/styles',\n      'addon-templates': 'addon/templates',\n      vendor: 'vendor',\n      'test-support': 'test-support',\n      'addon-test-support': 'addon-test-support',\n      public: 'public',\n    };\n\n    this.treeForMethods = defaultsDeep({}, DEFAULT_TREE_FOR_METHODS);\n\n    p.setupRegistry(this);\n\n    if (!this.name) {\n      throw new SilentError('An addon must define a `name` property.');\n    }\n\n    this.__originalOptions = this.options = defaultsDeep(this.options, {\n      babel: DEFAULT_BABEL_CONFIG,\n    });\n\n    let emberCLIBabelConfigKey = this._emberCLIBabelConfigKey();\n    this.__originalOptions[emberCLIBabelConfigKey] = this.options[emberCLIBabelConfigKey] = defaultsDeep(this.options[emberCLIBabelConfigKey], {\n      compileModules: true,\n    });\n  },\n\n  hintingEnabled() {\n    let isProduction = process.env.EMBER_ENV === 'production';\n    let testsEnabledDefault = process.env.EMBER_CLI_TEST_COMMAND || !isProduction;\n    let explicitlyDisabled = this.app && this.app.options && this.app.options.hinting === false;\n\n    return testsEnabledDefault && !explicitlyDisabled;\n  },\n\n  /**\n    Loads all required modules for a build\n\n    @private\n    @method _requireBuildPackages\n   */\n\n  _requireBuildPackages() {\n    if (this._didRequiredBuildPackages === true) {\n      return;\n    } else {\n      this._didRequiredBuildPackages = true;\n    }\n\n    this.transpileModules = deprecatedAddonFilters(this, 'this.transpileModules', 'broccoli-es6modules',\n      (tree, options) => new (require('broccoli-es6modules'))(tree, options));\n\n    this.pickFiles = deprecatedAddonFilters(this, 'this.pickFiles', 'broccoli-funnel',\n      (tree, options) => new Funnel(tree, options));\n\n    this.Funnel = deprecatedAddonFilters(this, 'new this.Funnel(..)', 'broccoli-funnel',\n      (tree, options) => new Funnel(tree, options));\n\n    this.mergeTrees = deprecatedAddonFilters(this, 'this.mergeTrees', 'broccoli-merge-trees', mergeTrees);\n    this.walkSync = deprecatedAddonFilters(this, 'this.walkSync', 'node-walk-sync', walkSync);\n  },\n\n  /**\n    Shorthand method for [broccoli-concat](https://github.com/ember-cli/broccoli-concat)\n\n    @private\n    @method concatFiles\n    @param {tree} tree Tree of files\n    @param {Object} options Options for broccoli-concat\n    @return {tree} Modified tree\n  */\n  concatFiles(tree, options) {\n    options.sourceMapConfig = this.app.options.sourcemaps;\n    return require('broccoli-concat')(tree, options);\n  },\n\n  /**\n    Allows to mark the addon as developing, triggering live-reload in the project the addon is linked to.\n\n    #### Uses:\n\n    - Working on projects with internal addons\n\n    @public\n    @method isDevelopingAddon\n    @return {Boolean}\n  */\n  isDevelopingAddon() {\n    if (process.env.EMBER_ADDON_ENV === 'development' && (this.parent instanceof Project)) {\n      return this.parent.name() === this.name;\n    }\n    return false;\n  },\n\n  /**\n    Discovers all child addons of this addon and stores their names and\n    package.json contents in this.addonPackages as key-value pairs\n\n    @private\n    @method discoverAddons\n   */\n  discoverAddons() {\n    let addonsList = this.addonDiscovery.discoverChildAddons(this);\n\n    this.addonPackages = this.addonDiscovery.addonPackages(addonsList);\n  },\n\n  initializeAddons() {\n    if (this._addonsInitialized) {\n      return;\n    }\n    this._addonsInitialized = true;\n\n    logger.info('initializeAddons for: %s', this.name);\n\n    this.discoverAddons();\n\n    this.addons = this.addonsFactory.initializeAddons(this.addonPackages);\n    this.addons.forEach(addon => logger.info('addon: %s', addon.name));\n  },\n\n  /**\n    Invoke the specified method for each enabled addon.\n\n    @private\n    @method eachAddonInvoke\n    @param {String} methodName the method to invoke on each addon\n    @param {Array} args the arguments to pass to the invoked method\n  */\n  eachAddonInvoke: function eachAddonInvoke(methodName, args) {\n    this.initializeAddons();\n\n    let invokeArguments = args || [];\n\n    return this.addons.map(addon => {\n      if (addon[methodName]) {\n        return addon[methodName].apply(addon, invokeArguments);\n      }\n    }).filter(Boolean);\n  },\n\n  /**\n    Invoke the specified method for each of the project's addons.\n\n    @private\n    @method _eachProjectAddonInvoke\n    @param {String} methodName the method to invoke on each addon\n    @param {Array} args the arguments to pass to the invoked method\n  */\n  _eachProjectAddonInvoke(methodName, args) {\n    this.initializeAddons();\n\n    let invokeArguments = args || [];\n\n    return this.project.addons.map(addon => {\n      if (addon[methodName]) {\n        return addon[methodName].apply(addon, invokeArguments);\n      }\n    }).filter(Boolean);\n  },\n\n  _addonPreprocessTree(type, tree) {\n    return addonProcessTree(this, 'preprocessTree', type, tree);\n  },\n\n  _addonPostprocessTree(type, tree) {\n    return addonProcessTree(this, 'postprocessTree', type, tree);\n  },\n\n  /**\n    Generates a tree for the specified path\n\n    @private\n    @method treeGenerator\n    @return {tree}\n  */\n  treeGenerator(dir) {\n    let tree;\n\n    if (!this.project) {\n      this._warn(`Addon: \\`${this.name}\\` is missing addon.project, this may be the result of an addon forgetting to invoke \\`super\\` in its init.`);\n    }\n    // TODO: fix law of demeter `_watchmanInfo.canNestRoots` is obviously a poor idea\n    if ((this.project && this.project._watchmanInfo.canNestRoots) ||\n        this.isDevelopingAddon()) {\n      const WatchedDir = require('broccoli-source').WatchedDir;\n      tree = new WatchedDir(dir);\n    } else {\n      const UnwatchedDir = require('broccoli-source').UnwatchedDir;\n      tree = new UnwatchedDir(dir);\n    }\n\n    return tree;\n  },\n\n  _treePathFor: function _treePathFor(treeName) {\n    let treePath = this.treePaths[treeName];\n    let absoluteTreePath = path.join(this.root, treePath);\n    let normalizedAbsoluteTreePath = path.normalize(absoluteTreePath);\n\n    return ensurePosixPath(normalizedAbsoluteTreePath);\n  },\n\n  /* @private\n   * @method _warn\n   */\n  _warn: warn,\n\n  _emberCLIBabelConfigKey() {\n    // future versions of ember-cli-babel will be moving the location for its\n    // own configuration options out of `babel` and will be issuing a deprecation\n    // if used in the older way\n    //\n    // see: https://github.com/babel/ember-cli-babel/pull/105\n    let emberCLIBabelInstance = findAddonByName(this.addons, 'ember-cli-babel');\n    let emberCLIBabelConfigKey = (emberCLIBabelInstance && emberCLIBabelInstance.configKey) || 'babel';\n\n    return emberCLIBabelConfigKey;\n  },\n\n  /**\n    Returns a given type of tree (if present), merged with the\n    application tree. For each of the trees available using this\n    method, you can also use a direct method called `treeFor[Type]` (eg. `treeForApp`).\n\n    Available tree names:\n    - {{#crossLink \"Addon/treeForApp:method\"}}app{{/crossLink}}\n    - {{#crossLink \"Addon/treeForStyles:method\"}}styles{{/crossLink}}\n    - {{#crossLink \"Addon/treeForTemplates:method\"}}templates{{/crossLink}}\n    - {{#crossLink \"Addon/treeForAddonTemplates:method\"}}addon-templates{{/crossLink}}\n    - {{#crossLink \"Addon/treeForAddon:method\"}}addon{{/crossLink}}\n    - {{#crossLink \"Addon/treeForVendor:method\"}}vendor{{/crossLink}}\n    - {{#crossLink \"Addon/treeForTestSupport:method\"}}test-support{{/crossLink}}\n    - {{#crossLink \"Addon/treeForAddonTestSupport:method\"}}addon-test-support{{/crossLink}}\n    - {{#crossLink \"Addon/treeForPublic:method\"}}public{{/crossLink}}\n\n    #### Uses:\n\n    - manipulating trees at build time\n\n    @public\n    @method treeFor\n    @param {String} name\n    @return {Tree}\n  */\n  treeFor: function treeFor(treeType) {\n    this._requireBuildPackages();\n\n    let node = heimdall.start({\n      name: `treeFor(${this.name} - ${treeType})`,\n      addonName: this.name,\n      treeType,\n      treeFor: true,\n    });\n\n    let cacheKeyForTreeType;\n    if (experiments.ADDON_TREE_CACHING) {\n      cacheKeyForTreeType = this[experiments.ADDON_TREE_CACHING](treeType);\n\n      let cachedTree = ADDON_TREE_CACHE.getItem(cacheKeyForTreeType);\n      if (cachedTree) {\n        node.stop();\n        return cachedTree;\n      }\n    }\n\n    let trees = this.eachAddonInvoke('treeFor', [treeType]);\n    let tree = this._treeFor(treeType);\n\n    if (tree) {\n      trees.push(tree);\n    }\n\n    if (this.isDevelopingAddon() && this.hintingEnabled() && treeType === 'app') {\n      trees.push(this.jshintAddonTree());\n    }\n\n    let mergedTreesForType = mergeTrees(trees, {\n      overwrite: true,\n      annotation: `Addon#treeFor (${this.name} - ${treeType})`,\n    });\n\n    if (cacheKeyForTreeType) {\n      ADDON_TREE_CACHE.setItem(cacheKeyForTreeType, mergedTreesForType);\n    }\n\n    node.stop();\n\n    return mergedTreesForType;\n  },\n\n  /**\n    @private\n    @param {String} name\n    @method _treeFor\n    @return {tree}\n  */\n  _treeFor: function _treeFor(name) {\n    let treePath = path.resolve(this.root, this.treePaths[name]);\n    let treeForMethod = this.treeForMethods[name];\n    let tree;\n\n    if (existsSync(treePath)) {\n      tree = this.treeGenerator(treePath);\n    }\n\n    if (this[treeForMethod]) {\n      tree = this[treeForMethod](tree);\n    }\n\n    return tree;\n  },\n\n  /**\n    This method climbs up the hierarchy of addons\n    up to the host application.\n\n    This prevents previous addons (prior to `this.import`, ca 2.7.0)\n    to break at importing assets when they are used nested in other addons.\n\n    @private\n    @method _findHost\n  */\n  _findHost() {\n    let current = this;\n    let app;\n\n    // Keep iterating upward until we don't have a grandparent.\n    // Has to do this grandparent check because at some point we hit the project.\n    do {\n      app = current.app || app;\n    } while (current.parent.parent && (current = current.parent));\n\n    return app;\n  },\n\n  /**\n    This method is called when the addon is included in a build. You\n    would typically use this hook to perform additional imports\n\n    #### Uses:\n\n    - including vendor files\n    - setting configuration options\n\n    *Note:* Any options set in the consuming application will override the addon.\n\n    @public\n    @method included\n    @param {EmberApp|EmberAddon} parent The parent object which included this addon\n\n    @example\n    ```js\n    included: function(parent) {\n      this.import(somePath);\n    }\n    ```\n  */\n  included(/* parent */) {\n    if (!this._addonsInitialized) {\n      // someone called `this._super.included` without `apply` (because of older\n      // core-object issues that prevent a \"real\" super call from working properly)\n      return;\n    }\n\n    this.eachAddonInvoke('included', [this]);\n  },\n\n  /**\n     Imports an asset into this addon.\n\n     @public\n     @method import\n     @param {Object|String} asset Either a path to the asset or an object with environment names and paths as key-value pairs.\n     @param {Object} [options] Options object\n     @param {String} [options.type] Either 'vendor' or 'test', defaults to 'vendor'\n     @param {Boolean} [options.prepend] Whether or not this asset should be prepended, defaults to false\n     @param {String} [options.destDir] Destination directory, defaults to the name of the directory the asset is in\n     @since 2.7.0\n   */\n  import(asset, options) {\n    let app = this._findHost();\n    app.import(asset, options);\n  },\n\n  /**\n    Returns the tree for all app files\n\n    @public\n    @method treeForApp\n    @param {Tree} tree\n    @return {Tree} App file tree\n  */\n  treeForApp(tree) {\n    return tree;\n  },\n\n  /**\n    Returns the tree for all template files\n\n    @public\n    @method treeForTemplates\n    @param {Tree} tree\n    @return {Tree} Template file tree\n  */\n  treeForTemplates(tree) {\n    return tree;\n  },\n\n  /**\n    Returns the tree for this addon's templates\n\n    @public\n    @method treeForAddonTemplates\n    @param {Tree} tree\n    @return {Tree} Addon Template file tree\n  */\n  treeForAddonTemplates(tree) {\n    return tree;\n  },\n\n  /**\n    Returns a tree for this addon\n\n    @public\n    @method treeForAddon\n    @param {Tree} tree\n    @return {Tree} Addon file tree\n\n    @example\n    ```js\n    treeForAddon: function() {\n      var tree = this._super.treeForAddon.apply(this, arguments);\n      var checker = new VersionChecker(this);\n      var isOldEmber = checker.for('ember', 'bower').lt('1.13.0');\n\n      if (isOldEmber) {\n        tree = new Funnel(tree, { exclude: [ /instance-initializers/ ] });\n      }\n\n      return tree;\n    }\n    ```\n   */\n  treeForAddon(tree) {\n    this._requireBuildPackages();\n\n    if (!tree) {\n      return tree;\n    }\n\n    let addonTree = this.compileAddon(tree);\n    let stylesTree = this.compileStyles(this._treeFor('addon-styles'));\n\n    return mergeTrees([addonTree, stylesTree], {\n      annotation: `Addon#treeForAddon(${this.name})`,\n    });\n  },\n\n  /**\n    Returns the tree for all style files\n\n    @public\n    @method treeForStyles\n    @param {Tree} tree The tree to process, usually `app/styles/` in the addon.\n    @return {Tree} The return tree has the same contents as the input tree, but is moved so that the `app/styles/` path is preserved.\n  */\n  treeForStyles(tree) {\n    this._requireBuildPackages();\n\n    if (!tree) {\n      return tree;\n    }\n\n    return new Funnel(tree, {\n      destDir: 'app/styles',\n      annotation: `Addon#treeForStyles (${this.name})`,\n    });\n  },\n\n  /**\n    Returns the tree for all vendor files\n\n    @public\n    @method treeForVendor\n    @param {Tree} tree\n    @return {Tree} Vendor file tree\n  */\n  treeForVendor(tree) {\n    return tree;\n  },\n\n  /**\n    Returns the tree for all test support files\n\n    @public\n    @method treeForTestSupport\n    @param {Tree} tree\n    @return {Tree} Test Support file tree\n  */\n  treeForTestSupport(tree) {\n    return tree;\n  },\n\n  /**\n    Returns the tree for all public files\n\n    @public\n    @method treeForPublic\n    @param {Tree} tree\n    @return {Tree} Public file tree\n  */\n  treeForPublic(tree) {\n    this._requireBuildPackages();\n\n    if (!tree) {\n      return tree;\n    }\n\n    return new Funnel(tree, {\n      srcDir: '/',\n      destDir: `/${this.moduleName()}`,\n      annotation: `Addon#treeForPublic (${this.name})`,\n    });\n  },\n\n  /**\n   Returns the tree for all test files namespaced to a given addon.\n\n   @public\n   @method treeForAddonTestSupport\n   @param {Tree} tree\n   @return {Tree}\n   */\n  treeForAddonTestSupport(tree) {\n    if (!tree) {\n      return tree;\n    }\n\n    let namespacedTree = new Funnel(tree, {\n      srcDir: '/',\n      destDir: `/${this.moduleName()}/test-support`,\n      annotation: `Addon#treeForTestSupport (${this.name})`,\n    });\n\n    if (registryHasPreprocessor(this.registry, 'js')) {\n      return this.preprocessJs(namespacedTree, '/', this.name, {\n        registry: this.registry,\n      });\n    } else {\n      this._warn(`Addon test support files were detected in \\`${this._treePathFor('addon-test-support')}\\`, but no JavaScript ` +\n                 `preprocessors were found for \\`${this.name}\\`. Please make sure to add a preprocessor ` +\n                 `(most likely \\`ember-cli-babel\\`) to \\`dependencies\\` (NOT \\`devDependencies\\`) in ` +\n                 `\\`${this.name}\\`'s \\`package.json\\`.`);\n\n      let options = defaultsDeep({}, DEFAULT_BABEL_CONFIG, {\n        annotation: `Babel Fallback - Addon#treeForAddonTestSupport (${this.name})`,\n      });\n\n      const Babel = require('broccoli-babel-transpiler');\n      return new Babel(namespacedTree, options);\n    }\n  },\n\n  /**\n    Runs the styles tree through preprocessors.\n\n    @private\n    @method compileStyles\n    @param {Tree} addonStylesTree Styles file tree\n    @return {Tree} Compiled styles tree\n  */\n  compileStyles(addonStylesTree) {\n    this._requireBuildPackages();\n\n    if (addonStylesTree) {\n      let preprocessedStylesTree = this._addonPreprocessTree('css', addonStylesTree);\n\n      let processedStylesTree = preprocessCss(preprocessedStylesTree, '/', '/', {\n        outputPaths: { 'addon': `${this.name}.css` },\n        registry: this.registry,\n      });\n\n      return this._addonPostprocessTree('css', processedStylesTree);\n    }\n  },\n\n  /**\n    Looks in the addon/ and addon/templates trees to determine if template files\n    exists that need to be precompiled.\n\n    This is executed once when building, but not on rebuilds.\n\n    @private\n    @method shouldCompileTemplates\n    @return {Boolean} indicates if templates need to be compiled for this addon\n  */\n  shouldCompileTemplates() {\n    return this._fileSystemInfo().hasTemplates;\n  },\n\n  /**\n     Looks in the addon/ and addon/templates trees to determine if template files\n     exists in the pods format that need to be precompiled.\n\n     This is executed once when building, but not on rebuilds.\n\n     @private\n     @method _shouldCompilePodTemplates\n     @return {Boolean} indicates if pod based templates need to be compiled for this addon\n  */\n  _shouldCompilePodTemplates() {\n    return this._fileSystemInfo().hasPodTemplates;\n  },\n\n  _fileSystemInfo() {\n    if (this._cachedFileSystemInfo) {\n      return this._cachedFileSystemInfo;\n    }\n\n    let jsExtensions = this.registry.extensionsForType('js');\n    let templateExtensions = this.registry.extensionsForType('template');\n    let addonTreePath = this._treePathFor('addon');\n    let addonTemplatesTreePath = this._treePathFor('addon-templates');\n    let addonTemplatesTreeInAddonTree = addonTemplatesTreePath.indexOf(addonTreePath) === 0;\n\n    let files = this._getAddonTreeFiles();\n\n    let addonTemplatesRelativeToAddonPath = addonTemplatesTreeInAddonTree && addonTemplatesTreePath.replace(`${addonTreePath}/`, '');\n    let podTemplateMatcher = new RegExp(`template\\.(${templateExtensions.join('|')})$`);\n    let hasPodTemplates = files.some(file => {\n      // short curcuit if this is actually a `addon/templates` file\n      if (addonTemplatesTreeInAddonTree && file.indexOf(addonTemplatesRelativeToAddonPath) === 0) {\n        return false;\n      }\n\n      return file.match(podTemplateMatcher);\n    });\n\n    let jsMatcher = new RegExp(`(${jsExtensions.join('|')})$`);\n    let hasJSFiles = files.some(file => file.match(jsMatcher));\n\n    if (!addonTemplatesTreeInAddonTree) {\n      files = files.concat(this._getAddonTemplatesTreeFiles());\n    }\n\n    files = files.filter(Boolean);\n\n    let extensionMatcher = new RegExp(`(${templateExtensions.join('|')})$`);\n    let hasTemplates = files.some(file => file.match(extensionMatcher));\n\n    this._cachedFileSystemInfo = {\n      hasJSFiles,\n      hasTemplates,\n      hasPodTemplates,\n    };\n\n    return this._cachedFileSystemInfo;\n  },\n\n  _getAddonTreeFiles() {\n    let addonTreePath = this._treePathFor('addon');\n\n    if (existsSync(addonTreePath)) {\n      return walkSync(addonTreePath);\n    }\n\n    return [];\n  },\n\n  _getAddonTemplatesTreeFiles() {\n    let addonTemplatesTreePath = this._treePathFor('addon-templates');\n\n    if (existsSync(addonTemplatesTreePath)) {\n      return walkSync(addonTemplatesTreePath);\n    }\n\n    return [];\n  },\n\n  _addonTemplateFiles: function addonTemplateFiles(addonTree) {\n    this._requireBuildPackages();\n\n    if (this._cachedAddonTemplateFiles) {\n      return this._cachedAddonTemplateFiles;\n    }\n\n    let trees = [];\n    let addonTemplates = this._treeFor('addon-templates');\n    let standardTemplates;\n\n    if (addonTemplates) {\n      standardTemplates = new Funnel(addonTemplates, {\n        srcDir: '/',\n        destDir: `${this.name}/templates`,\n        annotation: `Addon#_addonTemplateFiles (${this.name})`,\n      });\n\n      trees.push(standardTemplates);\n    }\n\n    if (this._shouldCompilePodTemplates()) {\n      let includePatterns = this.registry.extensionsForType('template')\n        .map(extension => `**/*/template.${extension}`);\n\n      let podTemplates = new Funnel(addonTree, {\n        include: includePatterns,\n        destDir: `${this.name}/`,\n        annotation: 'Funnel: Addon Pod Templates',\n      });\n\n      trees.push(podTemplates);\n    }\n\n    this._cachedAddonTemplateFiles = mergeTrees(trees, {\n      annotation: `TreeMerge (${this.name} templates)`,\n    });\n\n    return this._cachedAddonTemplateFiles;\n  },\n\n  /**\n    Runs the templates tree through preprocessors.\n\n    @private\n    @method compileTemplates\n    @param {Tree} tree Templates file tree\n    @return {Tree} Compiled templates tree\n  */\n  compileTemplates(addonTree) {\n    this._requireBuildPackages();\n\n    if (this.shouldCompileTemplates()) {\n      if (!registryHasPreprocessor(this.registry, 'template')) {\n        throw new SilentError(`Addon templates were detected, but there are no template compilers registered for \\`${this.name}\\`. ` +\n          `Please make sure your template precompiler (commonly \\`ember-cli-htmlbars\\`) is listed in \\`dependencies\\` ` +\n          `(NOT \\`devDependencies\\`) in \\`${this.name}\\`'s \\`package.json\\`.`);\n      }\n\n      let preprocessedTemplateTree = this._addonPreprocessTree('template', this._addonTemplateFiles(addonTree));\n\n      let processedTemplateTree = preprocessTemplates(preprocessedTemplateTree, {\n        annotation: `compileTemplates(${this.name})`,\n        registry: this.registry,\n      });\n\n      let postprocessedTemplateTree = this._addonPostprocessTree('template', processedTemplateTree);\n\n      return processModulesOnly(postprocessedTemplateTree);\n    }\n  },\n\n  /**\n    Runs the addon tree through preprocessors.\n\n    @private\n    @method compileAddon\n    @param {Tree} tree Addon file tree\n    @return {Tree} Compiled addon tree\n  */\n  compileAddon(tree) {\n    this._requireBuildPackages();\n\n    if (!this.options) {\n      this._warn(\n        `Ember CLI addons manage their own module transpilation during the \\`treeForAddon\\` processing. ` +\n        `\\`${this.name}\\` (found at \\`${this.root}\\`) has removed \\`this.options\\` ` +\n        `which conflicts with the addons ability to transpile its \\`addon/\\` files properly. ` +\n        `Falling back to default babel configuration options.`\n      );\n\n      this.options = {};\n    }\n\n    if (!this.options.babel) {\n      this._warn(\n        `Ember CLI addons manage their own module transpilation during the \\`treeForAddon\\` processing. ` +\n        `\\`${this.name}\\` (found at \\`${this.root}\\`) has overridden the \\`this.options.babel\\` ` +\n        `options which conflicts with the addons ability to transpile its \\`addon/\\` files properly. ` +\n        `Falling back to default babel configuration options.`\n      );\n\n      this.options.babel = this.__originalOptions.babel;\n    }\n\n    let emberCLIBabelConfigKey = this._emberCLIBabelConfigKey();\n    if (!this.options[emberCLIBabelConfigKey] || !this.options[emberCLIBabelConfigKey].compileModules) {\n      this._warn(\n        `Ember CLI addons manage their own module transpilation during the \\`treeForAddon\\` processing. ` +\n        `\\`${this.name}\\` (found at \\`${this.root}\\`) has overridden the \\`this.options.${emberCLIBabelConfigKey}.compileModules\\` ` +\n        `value which conflicts with the addons ability to transpile its \\`addon/\\` files properly.`\n      );\n\n      this.options[emberCLIBabelConfigKey] = this.options[emberCLIBabelConfigKey] || {};\n      this.options[emberCLIBabelConfigKey].compileModules = true;\n    }\n\n    let addonJs = this.processedAddonJsFiles(tree);\n    let templatesTree = this.compileTemplates(tree);\n\n    let trees = [addonJs, templatesTree].filter(Boolean);\n\n    let combinedJSAndTemplates = mergeTrees(trees, {\n      overwrite: true,\n      annotation: `Addon#compileAddon(${this.name}) `,\n    });\n\n    return new Funnel(combinedJSAndTemplates, {\n      destDir: 'modules/',\n      annotation: 'Funnel: compileAddon',\n    });\n  },\n\n  /**\n    Returns a tree with JSHhint output for all addon JS.\n\n    @private\n    @method jshintAddonTree\n    @return {Tree} Tree with JShint output (tests)\n  */\n  jshintAddonTree() {\n    this._requireBuildPackages();\n\n    let addonPath = this._treePathFor('addon');\n\n    if (!existsSync(addonPath)) {\n      return;\n    }\n\n    let addonJs = this.addonJsFiles(addonPath);\n    let addonTemplates = this._addonTemplateFiles(addonPath);\n    let lintJsTrees = this._eachProjectAddonInvoke('lintTree', ['addon', addonJs]);\n    let lintTemplateTrees = this._eachProjectAddonInvoke('lintTree', ['templates', addonTemplates]);\n    let lintTrees = [].concat(lintJsTrees, lintTemplateTrees).filter(Boolean);\n    let lintedAddon = mergeTrees(lintTrees, {\n      overwrite: true,\n      annotation: 'TreeMerger (addon-lint)',\n    });\n\n    return new Funnel(lintedAddon, {\n      srcDir: '/',\n      destDir: `${this.name}/tests/`,\n      annotation: `Funnel: Addon#jshintAddonTree(${this.name})`,\n    });\n  },\n\n  /**\n    Returns a tree containing the addon's js files\n\n    @private\n    @method addonJsFiles\n    @return {Tree} The filtered addon js files\n  */\n  addonJsFiles(tree) {\n    this._requireBuildPackages();\n\n    let includePatterns = this.registry.extensionsForType('js')\n      .map(extension => new RegExp(`${extension}$`));\n\n    return new Funnel(tree, {\n      include: includePatterns,\n      destDir: this.moduleName(),\n      annotation: 'Funnel: Addon JS',\n    });\n  },\n\n\n  /**\n    Preprocesses a javascript tree.\n\n    @private\n    @method preprocessJs\n    @return {Tree} Preprocessed javascript\n  */\n  preprocessJs() {\n    return preprocessJs.apply(preprocessJs, arguments);\n  },\n\n  /**\n    Returns a tree with all javascript for this addon.\n\n    @private\n    @method processedAddonJsFiles\n    @param {Tree} the tree to preprocess\n    @return {Tree} Processed javascript file tree\n  */\n  processedAddonJsFiles(addonTree) {\n    let preprocessedAddonJS = this._addonPreprocessTree('js', this.addonJsFiles(addonTree));\n\n    let processedAddonJS = this.preprocessJs(preprocessedAddonJS, '/', this.name, {\n      annotation: `processedAddonJsFiles(${this.name})`,\n      registry: this.registry,\n    });\n\n    let postprocessedAddonJs = this._addonPostprocessTree('js', processedAddonJS);\n\n    if (!registryHasPreprocessor(this.registry, 'js')) {\n      this._warn(`Addon files were detected in \\`${this._treePathFor('addon')}\\`, but no JavaScript ` +\n                 `preprocessors were found for \\`${this.name}\\`. Please make sure to add a preprocessor ` +\n                 '(most likely `ember-cli-babel`) to in `dependencies` (NOT `devDependencies`) in ' +\n                 `\\`${this.name}\\`'s \\`package.json\\`.`);\n\n      let options = defaultsDeep({}, DEFAULT_BABEL_CONFIG, {\n        annotation: `Babel Fallback - Addon#processedAddonJsFiles(${this.name})`,\n      });\n\n      const Babel = require('broccoli-babel-transpiler');\n      postprocessedAddonJs = new Babel(postprocessedAddonJs, options);\n    }\n\n    return postprocessedAddonJs;\n  },\n\n  /**\n    Returns the module name for this addon.\n\n    @public\n    @method moduleName\n    @return {String} module name\n  */\n  moduleName() {\n    if (!this.modulePrefix) {\n      this.modulePrefix = (this.modulePrefix || this.name).toLowerCase().replace(/\\s/g, '-');\n    }\n\n    return this.modulePrefix;\n  },\n\n  /**\n    Returns the path for addon blueprints.\n\n    @public\n    @method blueprintsPath\n    @return {String} The path for blueprints\n\n    @example\n    - [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript/blob/v1.13.2/index.js#L26)\n  */\n  blueprintsPath() {\n    let blueprintPath = path.join(this.root, 'blueprints');\n\n    if (existsSync(blueprintPath)) {\n      return blueprintPath;\n    }\n  },\n\n  /**\n    Augments the applications configuration settings.\n\n    Object returned from this hook is merged with the application's configuration object.\n\n    Application's configuration always take precedence.\n\n    #### Uses:\n\n    - Modifying configuration options (see list of defaults [here](https://github.com/ember-cli/ember-cli/blob/v2.4.3/lib/broccoli/ember-app.js#L163))\n      - For example\n        - `minifyJS`\n        - `storeConfigInMeta`\n        - et, al\n\n    @public\n    @method config\n    @param {String} env Name of current environment (ie \"developement\")\n    @param {Object} baseConfig Initial application configuration\n    @return {Object} Configuration object to be merged with application configuration.\n\n    @example\n    ```js\n    config: function(environment, appConfig) {\n      return {\n        someAddonDefault: \"foo\"\n      };\n    }\n    ```\n  */\n  config(env, baseConfig) {\n    let configPath = path.join(this.root, 'config', 'environment.js');\n\n    if (existsSync(configPath)) {\n      const configGenerator = require(configPath);\n\n      return configGenerator(env, baseConfig);\n    }\n  },\n\n  /**\n    @public\n    @method dependencies\n    @return {Object} The addon's dependencies based on the addon's package.json\n  */\n  dependencies() {\n    let pkg = this.pkg || {};\n    return assign({}, pkg['devDependencies'], pkg['dependencies']);\n  },\n\n  /**\n    @public\n    @method isEnabled\n    @return {Boolean} Whether or not this addon is enabled\n  */\n  isEnabled() {\n    return true;\n  },\n\n  /**\n    Can be used to exclude addons from being added as a child addon.\n\n    #### Uses:\n\n    - Abstract away multiple addons while only including one into the built assets\n\n    @public\n    @method shouldIncludeChildAddon\n    @param {Addon} childAddon\n    @return {Boolean} Whether or not a child addon is supposed to be included\n\n    @example\n    ```js\n    shouldIncludeChildAddon: function(childAddon) {\n      if(childAddon.name === 'ember-cli-some-legacy-select-component') {\n        return this.options.legacyMode;\n      } else if(childAddon.name === 'ember-cli-awesome-new-select-component') {\n        return !this.options.legacyMode;\n      } else {\n        return this._super.shouldIncludeChildAddon.apply(this, arguments);\n      }\n    }\n    ```\n  */\n  shouldIncludeChildAddon() {\n    return true;\n  },\n};\n\n// Methods without default implementation\n\n/**\n  Allows the specification of custom addon commands.\n  Expects you to return an object whose key is the name of the command and value is the command instance..\n\n  This function is not implemented by default\n\n  #### Uses:\n\n  - Include custom commands into consuming application\n\n  @public\n  @method includedCommands\n  @return {Object} An object with included commands\n\n  @example\n  ```js\n  includedCommands: function() {\n    return {\n      'do-foo': require('./lib/commands/foo')\n    };\n  }\n  ```\n*/\n\n\n/**\n  Pre-process a tree\n\n  #### Uses:\n\n  - removing / adding files from the build.\n\n  @public\n  @method preprocessTree\n  @param {String} type What kind of tree (eg. 'javascript', 'styles')\n  @param {Tree} tree Tree to process\n  @return {Tree} Processed tree\n */\n\n\n/**\n  Post-process a tree\n\n  @public\n  @method postprocessTree\n  @param {String} type What kind of tree (eg. 'javascript', 'styles')\n  @param {Tree} tree Tree to process\n  @return {Tree} Processed tree\n\n  @example\n  - [broccoli-asset-rev](https://github.com/rickharrison/broccoli-asset-rev/blob/c82c3580855554a31f7d6600b866aecf69cdaa6d/index.js#L29)\n */\n\n\n/**\n  This hook allows you to make changes to the express server run by ember-cli.\n\n  It's passed a `startOptions` object which contains:\n  - `app` Express server instance\n  - `options` A hash with:\n    - `project` Current {{#crossLink \"Project\"}}project{{/crossLink}}\n    - `watcher`\n    - `environment`\n\n  This function is not implemented by default\n\n  #### Uses:\n\n  - Tacking on headers to each request\n  - Modifying the request object\n\n  *Note:* that this should only be used in development, and if you need the same behavior in production you'll\n  need to configure your server.\n\n  @public\n  @method serverMiddleware\n  @param {Object} startOptions Express server start options\n\n  @example\n  ```js\n  serverMiddleware: function(startOptions) {\n    var app = startOptions.app;\n\n    app.use(function(req, res, next) {\n      // Some middleware\n    });\n  }\n  ```\n\n  - [ember-cli-content-security-policy](https://github.com/rwjblue/ember-cli-content-security-policy/blob/v0.5.0/index.js#L84)\n  - [history-support-addon](https://github.com/ember-cli/ember-cli/blob/v2.4.3/lib/tasks/server/middleware/history-support/index.js#L25)\n */\n\n\n/**\n This hook allows you to make changes to the express server run by testem.\n\n This function is not implemented by default\n\n #### Uses:\n\n - Adding custom test-specific endpoints\n - Manipulating HTTP requests in tests\n\n @public\n @method testemMiddleware\n @param {Object} app the express app instance\n */\n\n\n/**\n  This hook is called before a build takes place.\n\n  @public\n  @method preBuild\n  @param {Object} result Build object\n*/\n\n\n/**\n  This hook is called after a build is complete.\n\n  It's passed a `result` object which contains:\n  - `directory` Path to build output\n\n  #### Uses:\n\n  - Slow tree listing\n  - May be used to manipulate your project after build has happened\n\n  @public\n  @method postBuild\n  @param {Object} result Build result object\n*/\n\n\n/**\n  This hook is called after the build has been processed and the build files have been copied to the output directory\n\n  It's passed a `result` object which contains:\n  - `directory` Path to build output\n\n  @public\n  @method outputReady\n  @param {Object} result Build result object\n\n  @example\n  - Opportunity to symlink or copy files elsewhere.\n  - [ember-cli-rails-addon](https://github.com/rondale-sc/ember-cli-rails-addon/blob/v0.7.0/index.js#L45)\n    - In this case we are using this in tandem with a rails middleware to remove a lock file.\n      This allows our ruby gem to block incoming requests until after the build happens reliably.\n */\n\n\n/**\n  This hook is called when an error occurs during the preBuild, postBuild or outputReady hooks\n  for addons, or when the build fails\n\n  #### Uses:\n\n  - Custom error handling during build process\n\n  @public\n  @method buildError\n  @param {Error} error The error that was caught during the processes listed above\n\n  @example\n  - [ember-cli-rails-addon](https://github.com/rondale-sc/ember-cli-rails-addon/blob/v0.7.0/index.js#L11)\n*/\n\n\n/**\n Used to add preprocessors to the preprocessor registry. This is often used by addons like [ember-cli-htmlbars](https://github.com/ember-cli/ember-cli-htmlbars)\n and [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript) to add a `template` or `js` preprocessor to the registry.\n\n **Uses:**\n\n - Adding preprocessors to the registry.\n\n @public\n @method setupPreprocessorRegistry\n @param {String} type either `\"self\"` or `\"parent\"`\n @param registry the registry to be set up\n\n @example\n ```js\n setupPreprocessorRegistry: function(type, registry) {\n   // ensure that broccoli-ember-hbs-template-compiler is not processing hbs files\n   registry.remove('template', 'broccoli-ember-hbs-template-compiler');\n\n   registry.add('template', {\n     name: 'ember-cli-htmlbars',\n     ext: 'hbs',\n     _addon: this,\n     toTree: function(tree) {\n       var htmlbarsOptions = this._addon.htmlbarsOptions();\n       return htmlbarsCompile(tree, htmlbarsOptions);\n     },\n\n     precompile: function(string) {\n       var htmlbarsOptions = this._addon.htmlbarsOptions();\n       var templateCompiler = htmlbarsOptions.templateCompiler;\n       return utils.template(templateCompiler, string);\n     }\n   });\n\n   if (type === 'parent') {\n     this.parentRegistry = registry;\n   }\n }\n ```\n*/\n\n\n/**\n Return value is merged into the **tests** tree. This lets you inject\n linter output as test results.\n\n **Uses:**\n\n - JSHint\n - any other form of automated test generation that turns code into tests\n\n @public\n @method lintTree\n @param {String} treeType `app`, `tests`, `templates`, or `addon`\n @param {Tree} tree tree of files (JavaScript files for `app`, `tests`, and `addon` types)\n\n @example\n - [ember-cli-qunit](https://github.com/ember-cli/ember-cli-qunit/blob/v1.4.1/index.js#L206)\n - [ember-cli-mocha](https://github.com/ef4/ember-cli-mocha/blob/66803037fe203b24e96dea83a2bd91de48b842e1/index.js#L101)\n*/\n\n\n/**\n Allow addons to implement contentFor method to add string output into the associated `{{content-for 'foo'}}` section in `index.html`\n\n **Uses:**\n\n - For instance, to inject analytics code into `index.html`\n\n @public\n @method contentFor\n @param type\n @param config\n @param content\n\n @example\n - [ember-cli-google-analytics](https://github.com/pgrippi/ember-cli-google-analytics/blob/v1.5.0/index.js#L79)\n*/\n\nfunction methodsForTreeType(treeType) {\n  let treeMethods = DEFAULT_TREE_FOR_METHOD_METHODS[treeType];\n\n  return GLOBAL_TREE_FOR_METHOD_METHODS.concat(treeMethods);\n}\n\n/*\n  `cacheKeyForTree` is currently hidden behind an experiment (pending review\n  and landing of https://github.com/ember-cli/rfcs/pull/90).\n\n  Once that RFC is accepted, a few things need to happen:\n\n  * Remove `ADDON_TREE_CACHING` from `lib/experiments/index.js`.\n  * Remove this guard.\n  * Remove guard around tests in `tests/unit/models/addon-test.js`.\n  * Move this code back up into the `addonProto` directly\n\n*/\nlet addonTreeCacheExperimentPresent = !!experiments.ADDON_TREE_CACHING;\nif (addonTreeCacheExperimentPresent) {\n  addonProto[experiments.ADDON_TREE_CACHING] = function cacheKeyForTree(treeType) {\n    let self = this;\n    let methodsToValidate = methodsForTreeType(treeType);\n    let cacheKeyStats = heimdall.statsFor('cache-key-for-tree');\n\n    // determine if treeFor* (or other methods for tree type) overrides for the given tree\n    let modifiedMethods = methodsToValidate.filter(methodName => self[methodName] !== addonProto[methodName]);\n\n    if (modifiedMethods.length) {\n      cacheKeyStats.modifiedMethods++;\n      cacheKeyLogger.info(`Opting out due to: modified methods: ${modifiedMethods.join(', ')}`);\n      return null; // uncacheable\n    }\n\n    // determine if treeForMethods overrides for given tree\n    if (self.treeForMethods[treeType] !== DEFAULT_TREE_FOR_METHODS[treeType]) {\n      cacheKeyStats.treeForMethodsOverride++;\n      cacheKeyLogger.info('Opting out due to: treeForMethods override');\n      return null; // uncacheable\n    }\n\n    // compute cache key\n    let cacheKey = calculateCacheKeyForTree(treeType, self);\n\n    return cacheKey; // profit?\n  };\n}\n\nlet Addon = CoreObject.extend(addonProto);\n\n/**\n  Returns the absolute path for a given addon\n\n  @private\n  @method resolvePath\n  @param {String} addon Addon name\n  @return {String} Absolute addon path\n*/\nAddon.resolvePath = function(addon) {\n  let addonMain = addon.pkg['ember-addon-main'];\n\n  if (addonMain) {\n    this.ui && this.ui.writeDeprecateLine(`${addon.pkg.name} is using the deprecated ember-addon-main definition. It should be updated to {'ember-addon': {'main': '${addon.pkg['ember-addon-main']}'}}`);\n  } else {\n    addonMain = (addon.pkg['ember-addon'] && addon.pkg['ember-addon'].main) || addon.pkg['main'] || 'index.js';\n  }\n\n  // Resolve will fail unless it has an extension\n  if (!path.extname(addonMain)) {\n    addonMain += '.js';\n  }\n\n  return path.resolve(addon.path, addonMain);\n};\n\n/**\n  Returns the addon class for a given addon name.\n  If the Addon exports a function, that function is used\n  as constructor. If an Object is exported, a subclass of\n  `Addon` is returned with the exported hash merged into it.\n\n  @private\n  @static\n  @method lookup\n  @param {String} addon Addon name\n  @return {Addon} Addon class\n*/\nAddon.lookup = function(addon) {\n  let Constructor, addonModule, modulePath, moduleDir;\n  let start = Date.now();\n\n  modulePath = Addon.resolvePath(addon);\n  moduleDir = path.dirname(modulePath);\n\n  if (existsSync(modulePath)) {\n    addonModule = require(modulePath);\n\n    if (typeof addonModule === 'function') {\n      Constructor = addonModule;\n      Constructor.prototype.root = Constructor.prototype.root || moduleDir;\n      Constructor.prototype.pkg = Constructor.prototype.pkg || addon.pkg;\n    } else {\n      Constructor = Addon.extend(assign({\n        root: moduleDir,\n        pkg: addon.pkg,\n      }, addonModule));\n    }\n  }\n\n  if (!Constructor) {\n    throw new SilentError(`The \\`${addon.pkg.name}\\` addon could not be found at \\`${addon.path}\\`.`);\n  }\n\n  let lookupDuration = Date.now() - start;\n\n  Constructor._meta_ = {\n    modulePath,\n    lookupDuration,\n    initializeIn: 0,\n  };\n\n  return Constructor;\n};\nmodule.exports = Addon;\nmodule.exports._resetTreeCache = _resetTreeCache;\n\nif (addonTreeCacheExperimentPresent) {\n  module.exports._treeCache = ADDON_TREE_CACHE;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/installation-checker.js":"'use strict';\n\nlet logger = require('heimdalljs-logger')('ember-cli:installation-checker');\nconst fs = require('fs-extra');\nconst existsSync = require('exists-sync');\nconst path = require('path');\nconst SilentError = require('silent-error');\n\nclass InstallationChecker {\n  constructor(options) {\n    this.project = options.project;\n  }\n\n  /**\n  * Check if npm and bower installation directories are present,\n  * and raise an error message with instructions on how to proceed.\n  *\n  * If some of these package managers aren't being used in the project\n  * we just ignore them. Their usage is considered by checking the\n  * presence of your manifest files: package.json for npm and bower.json for bower.\n  *\n  * @method checkInstallations\n  */\n  checkInstallations() {\n    let commands = [];\n\n    if (this.usingNpm() && this.npmDependenciesNotPresent()) {\n      logger.info('npm dependencies not installed');\n      commands.push('`npm install`');\n    }\n    if (this.usingBower() && this.bowerDependenciesNotPresent()) {\n      logger.info('bower dependencies not installed');\n      commands.push('`bower install`');\n    }\n    if (commands.length) {\n      let commandText = commands.join(' and ');\n      throw new SilentError(`No dependencies installed. Run ${commandText} to install missing dependencies.`);\n    }\n  }\n\n  hasBowerDeps() {\n    return hasDependencies(readJSON(path.join(this.project.root, 'bower.json')));\n  }\n\n  usingBower() {\n    return existsSync(path.join(this.project.root, 'bower.json')) && this.hasBowerDeps();\n  }\n\n  bowerDependenciesNotPresent() {\n    return !existsSync(this.project.bowerDirectory);\n  }\n\n  hasNpmDeps() {\n    return hasDependencies(readJSON(path.join(this.project.root, 'package.json')));\n  }\n\n  usingNpm() {\n    return existsSync(path.join(this.project.root, 'package.json')) && this.hasNpmDeps();\n  }\n\n  npmDependenciesNotPresent() {\n    return !existsSync(this.project.nodeModulesPath);\n  }\n}\n\nmodule.exports = InstallationChecker;\n\nfunction hasDependencies(pkg) {\n  return (pkg.dependencies && pkg.dependencies.length) ||\n         (pkg.devDependencies && pkg.devDependencies.length);\n}\n\nfunction readJSON(path) {\n  try {\n    return fs.readJsonSync(path);\n  } catch (e) {\n    throw new SilentError(`InstallationChecker: Unable to parse: ${path}`);\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/server-watcher.js":"'use strict';\n\nconst Watcher = require('./watcher');\n\nclass ServerWatcher extends Watcher {\n  constructor(options) {\n    super(options);\n\n    this.watcher.on('add', this.didAdd.bind(this));\n    this.watcher.on('delete', this.didDelete.bind(this));\n  }\n\n  constructWatcher(options) {\n    return new (require('sane'))(this.watchedDir, options);\n  }\n\n  didChange(relativePath) {\n    let description = `File changed: \"${relativePath}\"`;\n\n    this.ui.writeLine(description);\n    this.analytics.track({\n      name: 'server file changed',\n      description,\n    });\n  }\n\n  didAdd(relativePath) {\n    let description = `File added: \"${relativePath}\"`;\n\n    this.ui.writeLine(description);\n    this.analytics.track({\n      name: 'server file addition',\n      description,\n    });\n  }\n\n  didDelete(relativePath) {\n    let description = `File deleted: \"${relativePath}\"`;\n\n    this.ui.writeLine(description);\n    this.analytics.track({\n      name: 'server file deletion',\n      description,\n    });\n  }\n}\n\nmodule.exports = ServerWatcher;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/watcher.js":"'use strict';\n\nconst chalk = require('chalk');\nlet logger = require('heimdalljs-logger')('ember-cli:watcher');\nconst CoreObject = require('core-object');\n\nclass Watcher extends CoreObject {\n  constructor(_options) {\n    super(_options);\n\n    this.verbose = true;\n\n    let options = this.buildOptions();\n\n    logger.info('initialize %o', options);\n\n    this.watcher = this.watcher || this.constructWatcher(options);\n\n    this.watcher.on('error', this.didError.bind(this));\n    this.watcher.on('change', this.didChange.bind(this));\n  }\n\n  constructWatcher(options) {\n    return new (require('ember-cli-broccoli-sane-watcher'))(this.builder, options);\n  }\n\n  didError(error) {\n    logger.info('didError %o', error);\n    this.ui.writeError(error);\n    this.analytics.trackError({\n      description: error && error.message,\n    });\n  }\n\n  then() {\n    return this.watcher.then.apply(this.watcher, arguments);\n  }\n\n  didChange(results) {\n    logger.info('didChange %o', results);\n\n    let totalTime = results.totalTime / 1e6;\n\n    this.ui.writeLine('');\n    this.ui.writeLine(chalk.green(`Build successful - ${Math.round(totalTime)}ms.`));\n\n    this.analytics.track({\n      name: 'ember rebuild',\n      message: `broccoli rebuild time: ${totalTime}ms`,\n    });\n\n    /*\n     * We use the `rebuild` category in our analytics setup for both builds\n     * and rebuilds. This is a bit confusing, but the actual thing we\n     * delineate on in the reports is the `variable` value below. This is\n     * used both here and in `lib/tasks/build.js`.\n     */\n    this.analytics.trackTiming({\n      category: 'rebuild',\n      variable: 'rebuild time',\n      label: 'broccoli rebuild time',\n      value: Number(totalTime),\n    });\n  }\n\n  on() {\n    this.watcher.on.apply(this.watcher, arguments);\n  }\n\n  off() {\n    this.watcher.off.apply(this.watcher, arguments);\n  }\n\n  buildOptions() {\n    let watcher = this.options && this.options.watcher;\n\n    if (watcher && ['polling', 'watchman', 'node', 'events'].indexOf(watcher) === -1) {\n      throw new Error(`Unknown watcher type --watcher=[polling|watchman|node] but was: ${watcher}`);\n    }\n\n    return {\n      verbose: this.verbose,\n      poll: watcher === 'polling',\n      watchman: watcher === 'watchman' || watcher === 'events',\n      node: watcher === 'node',\n    };\n  }\n}\n\nmodule.exports = Watcher;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/models/task.js":"'use strict';\n\nconst CoreObject = require('core-object');\n\nclass Task extends CoreObject {\n  run(/*options*/) {\n    throw new Error('Task needs to have run() defined.');\n  }\n}\n\nmodule.exports = Task;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/addon-install.js":"'use strict';\n\nconst Task = require('../models/task');\nconst SilentError = require('silent-error');\nconst merge = require('ember-cli-lodash-subset').merge;\nconst getPackageBaseName = require('../utilities/get-package-base-name');\nconst Promise = require('rsvp').Promise;\n\nclass AddonInstallTask extends Task {\n  constructor(options) {\n    super(options);\n\n    this.NpmInstallTask = this.NpmInstallTask || require('./npm-install');\n    this.BlueprintTask = this.BlueprintTask || require('./generate-from-blueprint');\n  }\n\n  run(options) {\n    const chalk = require('chalk');\n    let ui = this.ui;\n    let packageNames = options.packages;\n    let blueprintOptions = options.blueprintOptions || {};\n    let commandOptions = blueprintOptions;\n\n    let npmInstall = new this.NpmInstallTask({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n    });\n\n    let blueprintInstall = new this.BlueprintTask({\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      testing: this.testing,\n    });\n\n    ui.startProgress(chalk.green('Installing addon package'), chalk.green('.'));\n\n    return npmInstall.run({\n      'packages': packageNames,\n      'save': commandOptions.save,\n      'save-dev': !commandOptions.save,\n      'save-exact': commandOptions.saveExact,\n    }).then(() => this.project.reloadAddons())\n      .then(() => this.installBlueprint(blueprintInstall, packageNames, blueprintOptions))\n      .finally(() => ui.stopProgress())\n      .then(() => ui.writeLine(chalk.green('Installed addon package.')));\n  }\n\n  installBlueprint(install, packageNames, blueprintOptions) {\n    let blueprintName, taskOptions, addonInstall = this;\n\n    return packageNames.reduce((promise, packageName) =>\n      promise.then(() => {\n        blueprintName = addonInstall.findDefaultBlueprintName(packageName);\n        if (blueprintName) {\n          taskOptions = merge({\n            args: [blueprintName],\n            ignoreMissingMain: true,\n          }, blueprintOptions || {});\n\n          return install.run(taskOptions);\n\n        } else {\n          addonInstall.ui.writeWarnLine(`Could not figure out blueprint name from: \"${packageName}\". ` +\n            `Please install the addon blueprint via \"ember generate <addon-name>\" if necessary.`);\n        }\n      }), Promise.resolve());\n  }\n\n  findDefaultBlueprintName(givenName) {\n    let packageName = getPackageBaseName(givenName);\n    if (!packageName) {\n      return null;\n    }\n\n    let addon = this.project.findAddonByName(packageName);\n    if (!addon) {\n      throw new SilentError(`Install failed. Could not find addon with name: ${givenName}`);\n    }\n\n    let emberAddon = addon.pkg['ember-addon'];\n\n    if (emberAddon && emberAddon.defaultBlueprint) {\n      return emberAddon.defaultBlueprint;\n    }\n\n    return packageName;\n  }\n}\n\nmodule.exports = AddonInstallTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/get-package-base-name.js":"'use strict';\n\nconst npa = require('npm-package-arg');\n\n\nmodule.exports = function(name) {\n  let parsed, parsedName;\n\n  if (!name) {\n    return null;\n  }\n\n  parsed = npa(name);\n  parsedName = parsed.name;\n\n  if (parsed.scope) {\n    parsedName = parsedName.replace(parsed.scope, '').slice(1);\n  }\n\n  return parsedName;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/bower-install.js":"'use strict';\n\n// Runs `bower install` in cwd\nconst fs = require('fs-extra');\nconst path = require('path');\nconst existsSync = require('exists-sync');\nconst execa = require('execa');\nconst RSVP = require('rsvp');\nconst SilentError = require('silent-error');\nconst Task = require('../models/task');\nconst formatPackageList = require('../utilities/format-package-list');\n\nconst logger = require('heimdalljs-logger')('ember-cli:tasks:bower-install');\n\nconst Promise = RSVP.Promise;\nconst resolve = RSVP.denodeify(require('resolve'));\nconst writeJson = RSVP.denodeify(fs.writeJson);\n\nconst cliPath = path.resolve(`${__dirname}/../..`);\n\nclass BowerInstallTask extends Task {\n\n  resolveBower() {\n    logger.info('Resolving \"bower\" from %s ...', cliPath);\n    return resolve('bower', { basedir: cliPath });\n  }\n\n  importBower(path) {\n    logger.info('Importing \"bower\" from: %s', path);\n    this.bower = require(path);\n  }\n\n  ensureBower() {\n    if (this.bower) {\n      return Promise.resolve();\n    }\n\n    return this.resolveBower()\n      .catch(error => {\n        if (error.message.indexOf('Cannot find module \\'bower\\'') === -1) {\n          throw error;\n        }\n\n        return this.installBower().then(() => this.resolveBower());\n      })\n      .then(bowerPath => this.importBower(bowerPath));\n  }\n\n  installBower() {\n    logger.info('Installing \"bower\" via NPM into: %s', cliPath);\n\n    let ui = this.ui;\n    const chalk = require('chalk');\n\n    ui.startProgress(chalk.green('NPM: Installing bower ...'));\n\n    return Promise.resolve(execa('npm', ['install', 'bower@^1.3.12'], { cwd: cliPath }))\n      .finally(() => ui.stopProgress())\n      .catch(error => this.handleInstallBowerError(error))\n      .then(() => ui.writeLine(chalk.green('NPM: Installed bower')));\n  }\n\n  handleInstallBowerError(error) {\n    if (error.message.indexOf('Cannot read property \\'target\\' of null') !== -1) {\n      throw new SilentError('Bower could not be installed due to a bug in your npm installation.\\n' +\n        'Please update your npm version by running: npm install -g npm');\n    }\n\n    throw error;\n  }\n\n  get bowerJsonPath() {\n    return path.join(this.project.root, 'bower.json');\n  }\n\n  hasBowerJson() {\n    return existsSync(this.bowerJsonPath);\n  }\n\n  hasBowerDependencies() {\n    if (!this.hasBowerJson()) {\n      return false;\n    }\n\n    let json = fs.readJsonSync(this.bowerJsonPath);\n    let deps = Object.keys(json.dependencies || {});\n    let devDeps = Object.keys(json.devDependencies || {});\n    return deps.length || devDeps.length;\n  }\n\n  ensureBowerJson() {\n    if (this.hasBowerJson()) {\n      return Promise.resolve();\n    }\n\n    let projectName = this.project.name();\n    let bowerJsonPath = this.bowerJsonPath;\n\n    logger.info('Creating \"bower.json\" for: %s at: %s', projectName, bowerJsonPath);\n\n    return writeJson(bowerJsonPath, { name: projectName });\n  }\n\n  // Options: Boolean verbose\n  run(options) {\n    let ui = this.ui;\n\n    let packages = options.packages || [];\n    let installOptions = options.installOptions || {};\n    let savePackages = installOptions.save || installOptions.saveDev;\n\n    // if we are running \"bower install\" from \"ember init\" and there is\n    // no \"bower.json\" we return early\n    if (!savePackages && !this.hasBowerDependencies()) {\n      logger.info('Skipping \"bower install\" since \"bower.json\" does not exist or is empty');\n      return Promise.resolve();\n    }\n\n    // resolve \"bower\" and install via NPM if necessary\n    // -> then check if a \"bower.json\" file exists and create if necessary\n    // -> then run the actual \"bower install\"\n    return this.ensureBower().then(() => this.ensureBowerJson()).then(() => {\n      const chalk = require('chalk');\n      let bowerConfig = this.bowerConfig || require('bower-config');\n\n      let startMessage = this.formatStartMessage(packages);\n      let completeMessage = this.formatCompleteMessage(packages);\n\n      logger.info('Installing %j via Bower with options: %j', packages, installOptions);\n\n      ui.startProgress(chalk.green(startMessage));\n\n      let config = bowerConfig.read();\n      config.interactive = true;\n\n      return new Promise((resolve, reject) => {\n        this.bower.commands.install(packages, installOptions, config) // Packages, options, config\n          .on('log', logBowerMessage)\n          .on('prompt', ui.prompt.bind(ui))\n          .on('error', reject)\n          .on('end', resolve);\n      })\n        .finally(() => ui.stopProgress())\n        .then(() => ui.writeLine(chalk.green(completeMessage)));\n\n      function logBowerMessage(message) {\n        if (message.level === 'conflict') {\n          // e.g.\n          //   conflict Unable to find suitable version for ember-data\n          //     1) ember-data 1.0.0-beta.6\n          //     2) ember-data ~1.0.0-beta.7\n          ui.writeLine(`  ${chalk.red('conflict')} ${message.message}`);\n          message.data.picks.forEach((pick, index) => {\n            ui.writeLine(`    ${chalk.green(`${index + 1})`)} ${message.data.name} ${pick.endpoint.target}`);\n          });\n        } else if (message.level === 'info' && options.verbose) {\n          // e.g.\n          //   cached git://example.com/some-package.git#1.0.0\n          ui.writeLine(`  ${chalk.green(message.id)} ${message.message}`);\n        }\n      }\n    });\n  }\n\n  formatStartMessage(packages) {\n    return `Bower: Installing ${formatPackageList(packages)} ...`;\n  }\n\n  formatCompleteMessage(packages) {\n    return `Bower: Installed ${formatPackageList(packages)}`;\n  }\n}\n\nmodule.exports = BowerInstallTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/format-package-list.js":"'use strict';\n\nmodule.exports = function formatPackageList(packages) {\n  if (Array.isArray(packages)) {\n    if (packages.length === 1) {\n      return packages[0];\n    } else if (packages.length === 2) {\n      return `${packages[0]} and ${packages[1]}`;\n    } else if (packages.length === 3) {\n      return `${packages[0]}, ${packages[1]} and ${packages[2]}`;\n    } else if (packages.length > 3) {\n      return `${packages[0]}, ${packages[1]} and ${packages.length - 2} other packages`;\n    }\n  }\n\n  return 'dependencies';\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/create-and-step-into-directory.js":"'use strict';\n\n// Creates a directory with the name directoryName in cwd and then sets cwd to\n// this directory.\n\nconst RSVP = require('rsvp');\nconst fs = require('fs');\nconst existsSync = require('exists-sync');\nconst Task = require('../models/task');\nconst SilentError = require('silent-error');\n\nconst Promise = RSVP.Promise;\nconst mkdir = RSVP.denodeify(fs.mkdir);\n\nclass CreateTask extends Task {\n  // Options: String directoryName, Boolean: dryRun\n\n  warnDirectoryAlreadyExists() {\n    let message = `Directory '${this.directoryName}' already exists.`;\n    return new SilentError(message);\n  }\n\n  run(options) {\n    let directoryName = this.directoryName = options.directoryName;\n    if (options.dryRun) {\n      return new Promise((resolve, reject) => {\n        if (existsSync(directoryName) && fs.readdirSync(directoryName).length) {\n          return reject(this.warnDirectoryAlreadyExists());\n        }\n        resolve();\n      });\n    }\n\n    return mkdir(directoryName)\n      .catch(err => {\n        if (err.code === 'EEXIST') {\n          // Allow using directory if it is empty.\n          if (fs.readdirSync(directoryName).length) {\n            throw this.warnDirectoryAlreadyExists();\n          }\n        } else {\n          throw err;\n        }\n      })\n      .then(() => {\n        let cwd = process.cwd();\n        process.chdir(directoryName);\n        return { initialDirectory: cwd };\n      });\n  }\n}\n\nmodule.exports = CreateTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/destroy-from-blueprint.js":"'use strict';\n\nconst GenerateTask = require('./generate-from-blueprint');\n\nclass DestroyTask extends GenerateTask {\n  constructor(options) {\n    super(options);\n    this.blueprintFunction = 'uninstall';\n  }\n}\n\nmodule.exports = DestroyTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/generate-from-blueprint.js":"'use strict';\n\nconst Promise = require('rsvp').Promise;\nconst Blueprint = require('../models/blueprint');\nconst Task = require('../models/task');\nconst parseOptions = require('../utilities/parse-options');\nconst merge = require('ember-cli-lodash-subset').merge;\n\nclass GenerateTask extends Task {\n\n  constructor(options) {\n    super(options);\n    this.blueprintFunction = 'install';\n  }\n\n  run(options) {\n    let self = this;\n    let name = options.args[0];\n    let noAddonBlueprint = ['mixin', 'blueprint-test'];\n\n    let mainBlueprint = this.lookupBlueprint(name, options.ignoreMissingMain);\n    let testBlueprint = this.lookupBlueprint(`${name}-test`, true);\n    // lookup custom addon blueprint\n    let addonBlueprint = this.lookupBlueprint(`${name}-addon`, true);\n    // otherwise, use default addon-import\n\n    if (noAddonBlueprint.indexOf(name) < 0 && !addonBlueprint && (mainBlueprint && mainBlueprint.supportsAddon()) && options.args[1]) {\n      addonBlueprint = this.lookupBlueprint('addon-import', true);\n    }\n\n    if (options.ignoreMissingMain && !mainBlueprint) {\n      return Promise.resolve();\n    }\n\n    if (options.dummy) {\n      // don't install test or addon reexport for dummy\n      if (this.project.isEmberCLIAddon()) {\n        testBlueprint = null;\n        addonBlueprint = null;\n      }\n    }\n\n    let entity = {\n      name: options.args[1],\n      options: parseOptions(options.args.slice(2)),\n    };\n\n    let blueprintOptions = {\n      target: this.project.root,\n      entity,\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      settings: this.settings,\n      testing: this.testing,\n      taskOptions: options,\n      originBlueprintName: name,\n    };\n\n    blueprintOptions = merge(blueprintOptions, options || {});\n\n    return mainBlueprint[this.blueprintFunction](blueprintOptions)\n      .then(() => {\n        if (!testBlueprint) { return; }\n\n        if (testBlueprint.locals === Blueprint.prototype.locals) {\n          testBlueprint.locals = function(options) {\n            return mainBlueprint.locals(options);\n          };\n        }\n\n        let testBlueprintOptions = merge({}, blueprintOptions, { installingTest: true });\n\n        return testBlueprint[self.blueprintFunction](testBlueprintOptions);\n      })\n      .then(() => {\n        if (!addonBlueprint || name.match(/-addon/)) { return; }\n        if (!this.project.isEmberCLIAddon() && blueprintOptions.inRepoAddon === null) { return; }\n\n        if (addonBlueprint.locals === Blueprint.prototype.locals) {\n          addonBlueprint.locals = function(options) {\n            return mainBlueprint.locals(options);\n          };\n        }\n\n        let addonBlueprintOptions = merge({}, blueprintOptions, { installingAddon: true });\n\n        return addonBlueprint[self.blueprintFunction](addonBlueprintOptions);\n      });\n  }\n\n  lookupBlueprint(name, ignoreMissing) {\n    return Blueprint.lookup(name, {\n      paths: this.project.blueprintLookupPaths(),\n      ignoreMissing,\n    });\n  }\n}\n\nmodule.exports = GenerateTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/parse-options.js":"'use strict';\n\nmodule.exports = function parseOptions(args) {\n  return args.reduce((result, arg) => {\n    let parts = arg.split(':');\n    result[parts[0]] = parts.slice(1).join(':');\n    return result;\n  }, {});\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/install-blueprint.js":"'use strict';\n\nconst Blueprint = require('../models/blueprint');\nconst Task = require('../models/task');\nconst RSVP = require('rsvp');\nconst isGitRepo = require('is-git-url');\nconst temp = require('temp');\nconst childProcess = require('child_process');\nconst path = require('path');\nconst merge = require('ember-cli-lodash-subset').merge;\n\n// Automatically track and cleanup temp files at exit\ntemp.track();\n\nlet mkdir = RSVP.denodeify(temp.mkdir);\nlet exec = RSVP.denodeify(childProcess.exec);\n\nclass InstallBlueprintTask extends Task {\n  run(options) {\n    let cwd = process.cwd();\n    let name = options.rawName;\n    let blueprintOption = options.blueprint;\n    // If we're in a dry run, pretend we changed directories.\n    // Pretending we cd'd avoids prompts in the actual current directory.\n    let fakeCwd = path.join(cwd, name);\n    let target = options.dryRun ? fakeCwd : cwd;\n\n    let installOptions = {\n      target,\n      entity: { name },\n      ui: this.ui,\n      analytics: this.analytics,\n      project: this.project,\n      dryRun: options.dryRun,\n      targetFiles: options.targetFiles,\n      rawArgs: options.rawArgs,\n    };\n\n    installOptions = merge(installOptions, options || {});\n\n    if (isGitRepo(blueprintOption)) {\n      return mkdir('ember-cli').then(pathName => {\n        let execArgs = ['git', 'clone', blueprintOption, pathName].join(' ');\n        return exec(execArgs).then(() => exec('npm install', { cwd: pathName }).then(() => {\n          let blueprint = Blueprint.load(pathName);\n          return blueprint.install(installOptions);\n        }));\n      });\n    } else {\n      let blueprintName = blueprintOption || 'app';\n      let blueprint = Blueprint.lookup(blueprintName, {\n        paths: this.project.blueprintLookupPaths(),\n      });\n      return blueprint.install(installOptions);\n    }\n  }\n}\n\nmodule.exports = InstallBlueprintTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/npm-install.js":"'use strict';\n\n// Runs `npm install` in cwd\nconst path = require('path');\nconst existsSync = require('exists-sync');\nconst NpmTask = require('./npm-task');\nconst formatPackageList = require('../utilities/format-package-list');\nconst Promise = require('rsvp').Promise;\n\nclass NpmInstallTask extends NpmTask {\n\n  constructor(options) {\n    super(options);\n    this.command = 'install';\n  }\n\n  run(options) {\n    let ui = this.ui;\n    let packageJson = path.join(this.project.root, 'package.json');\n\n    if (!existsSync(packageJson)) {\n      ui.writeWarnLine('Skipping npm install: package.json not found');\n      return Promise.resolve();\n    } else {\n      return super.run(options);\n    }\n  }\n\n  formatStartMessage(packages) {\n    return `NPM: Installing ${formatPackageList(packages)} ...`;\n  }\n\n  formatCompleteMessage(packages) {\n    return `NPM: Installed ${formatPackageList(packages)}`;\n  }\n}\n\nmodule.exports = NpmInstallTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/npm-task.js":"'use strict';\n\n// Runs `npm install` in cwd\n\nconst chalk = require('chalk');\nconst execa = require('execa');\nconst semver = require('semver');\nconst RSVP = require('rsvp');\nconst SilentError = require('silent-error');\n\nconst logger = require('heimdalljs-logger')('ember-cli:npm-task');\n\nconst Task = require('../models/task');\n\nclass NpmTask extends Task {\n\n  constructor(options) {\n    super(options);\n\n    // The command to run: can be 'install' or 'uninstall'\n    this.command = '';\n\n    this.versionConstraints = '3 || 4';\n  }\n\n  npm(args) {\n    logger.info('npm: %j', args);\n    return RSVP.resolve(execa('npm', args, { preferLocal: false }));\n  }\n\n  checkVersion() {\n    return this.npm(['--version']).then(result => {\n      let version = result.stdout;\n      logger.info('npm --version: %s', version);\n\n      let ok = semver.satisfies(version, this.versionConstraints);\n      if (!ok) {\n        logger.warn('npm --version is outside of version constraint: %s', this.versionConstraints);\n\n        let below = semver.ltr(version, this.versionConstraints);\n        if (below) {\n          throw new SilentError('Ember CLI is now using the global NPM, but your NPM version is outdated.\\n' +\n            'Please update your global NPM version by running: npm install -g npm');\n        }\n\n        this.ui.writeWarnLine('Ember CLI is using the global NPM, but your NPM version has not yet been ' +\n          'verified to work with the current Ember CLI release.');\n      }\n\n    }).catch(error => {\n      logger.error('npm --version failed: %s', error);\n\n      if (error.code === 'ENOENT') {\n        throw new SilentError('Ember CLI is now using the global NPM, but was not able to find it.\\n' +\n          'Please install NPM using the instructions at https://github.com/npm/npm');\n      }\n\n      throw error;\n    });\n  }\n\n  run(options) {\n    return this.checkVersion().then(() => {\n\n      let ui = this.ui;\n      let startMessage = this.formatStartMessage(options.packages);\n      let completeMessage = this.formatCompleteMessage(options.packages);\n\n      ui.startProgress(chalk.green(startMessage));\n\n      let args = [this.command];\n\n      if (options.save) {\n        args.push('--save');\n      }\n\n      if (options['save-dev']) {\n        args.push('--save-dev');\n      }\n\n      if (options['save-exact']) {\n        args.push('--save-exact');\n      }\n\n      if ('optional' in options && !options.optional) {\n        args.push('--no-optional');\n      }\n\n      if (options.verbose) {\n        args.push('--loglevel verbose');\n      } else {\n        args.push('--loglevel error');\n      }\n\n      if (options.packages) {\n        args = args.concat(options.packages);\n      }\n\n      return this.npm(args)\n        .finally(() => ui.stopProgress())\n        .then(() => ui.writeLine(chalk.green(completeMessage)));\n    });\n  }\n\n  formatStartMessage(/* packages */) {\n    return '';\n  }\n\n  formatCompleteMessage(/* packages */) {\n    return '';\n  }\n}\n\nmodule.exports = NpmTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/npm-uninstall.js":"'use strict';\n\n// Runs `npm uninstall` in cwd\n\nconst NpmTask = require('./npm-task');\nconst formatPackageList = require('../utilities/format-package-list');\n\nclass NpmUninstallTask extends NpmTask {\n\n  constructor(options) {\n    super(options);\n    this.command = 'uninstall';\n  }\n\n  formatStartMessage(packages) {\n    return `NPM: Uninstalling ${formatPackageList(packages)} ...`;\n  }\n\n  formatCompleteMessage(packages) {\n    return `NPM: Uninstalled ${formatPackageList(packages)}`;\n  }\n}\n\nmodule.exports = NpmUninstallTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/load-config.js":"'use strict';\n\nconst findup = require('find-up');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\n\nlet parsers = {\n  '.yml': yaml.safeLoad,\n  '.yaml': yaml.safeLoad,\n  '.json': JSON.parse,\n};\n\nfunction loadConfig(file, basedir) {\n  basedir = basedir || __dirname;\n  let ext = path.extname(file);\n  let configPath = findup.sync(file, { cwd: basedir });\n\n  let content;\n  try {\n    content = fs.readFileSync(configPath, 'utf8');\n    if (parsers[ext]) {\n      content = parsers[ext](content);\n    }\n  } catch (e) {\n    // ESLint doesn't like this.\n  }\n\n  return content;\n}\n\nmodule.exports = loadConfig;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/platform-checker.js":"'use strict';\n\nconst semver = require('semver');\nlet logger = require('heimdalljs-logger')('ember-cli:platform-checker:');\nconst loadConfig = require('./load-config');\n\nlet testedEngines;\nif (process.platform === 'win32') {\n  testedEngines = loadConfig('appveyor.yml')\n    .environment.matrix\n    .map(element => element.nodejs_version)\n    .join(' || ');\n} else {\n  testedEngines = loadConfig('.travis.yml')\n    .node_js\n    .join(' || ');\n}\n\nlet supportedEngines = loadConfig('package.json').engines.node;\n\nclass PlatformChecker {\n  constructor(version) {\n    this.version = version;\n    this.isValid = this.checkIsValid();\n    this.isTested = this.checkIsTested();\n    this.isDeprecated = this.checkIsDeprecated();\n\n    logger.info('%o', {\n      version: this.version,\n      isValid: this.isValid,\n      isTested: this.isTested,\n      isDeprecated: this.isDeprecated,\n    });\n  }\n\n  checkIsValid(range) {\n    range = range || supportedEngines;\n    return semver.satisfies(this.version, range) || semver.gtr(this.version, supportedEngines);\n  }\n\n  checkIsDeprecated(range) {\n    range = range || supportedEngines;\n    return !this.checkIsValid(range);\n  }\n\n  checkIsTested(range) {\n    range = range || testedEngines;\n    return semver.satisfies(this.version, range);\n  }\n}\n\nmodule.exports = PlatformChecker;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/require-local.js":"'use strict';\n\nconst path = require('path');\nconst nodeModulesPath = require('node-modules-path');\n\nmodule.exports = function requireLocal(lib) {\n  return require(path.join(nodeModulesPath(process.cwd()), lib));\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/stringify-and-normalize.js":"'use strict';\n\nmodule.exports = function stringifyAndNormalize(contents) {\n  return `${JSON.stringify(contents, null, 2)}\\n`;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/utilities/symbol.js":"'use strict';\n\nmodule.exports = function symbol(name) {\n  let id = `EMBER_CLI${Math.floor(Math.random() * new Date())}`;\n  return `__${name}__ [id=${id}]`;\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/server/express-server.js":"'use strict';\n\nconst path = require('path');\nconst EventEmitter = require('events').EventEmitter;\nconst chalk = require('chalk');\nconst fs = require('fs');\nconst existsSync = require('exists-sync');\nconst debounce = require('ember-cli-lodash-subset').debounce;\nconst mapSeries = require('promise-map-series');\nconst Promise = require('rsvp').Promise;\nconst Task = require('../../models/task');\nconst SilentError = require('silent-error');\n\nconst cleanBaseURL = require('clean-base-url');\n\nclass ExpressServerTask extends Task {\n  constructor(options) {\n    super(options);\n    this.emitter = new EventEmitter();\n    this.express = this.express || require('express');\n    this.http = this.http || require('http');\n    this.https = this.https || require('https');\n\n    let serverRestartDelayTime = this.serverRestartDelayTime || 100;\n    this.scheduleServerRestart = debounce(function() {\n      this.restartHttpServer();\n    }, serverRestartDelayTime);\n  }\n\n  on() {\n    this.emitter.on.apply(this.emitter, arguments);\n  }\n\n  off() {\n    this.emitter.off.apply(this.emitter, arguments);\n  }\n\n  emit() {\n    this.emitter.emit.apply(this.emitter, arguments);\n  }\n\n  displayHost(specifiedHost) {\n    return specifiedHost || 'localhost';\n  }\n\n  setupHttpServer() {\n    if (this.startOptions.ssl) {\n      this.httpServer = this.createHttpsServer();\n    } else {\n      this.httpServer = this.http.createServer(this.app);\n    }\n\n    // We have to keep track of sockets so that we can close them\n    // when we need to restart.\n    this.sockets = {};\n    this.nextSocketId = 0;\n    this.httpServer.on('connection', socket => {\n      let socketId = this.nextSocketId++;\n      this.sockets[socketId] = socket;\n\n      socket.on('close', () => {\n        delete this.sockets[socketId];\n      });\n    });\n  }\n\n  createHttpsServer() {\n    if (!existsSync(this.startOptions.sslKey)) {\n      throw new TypeError(`SSL key couldn't be found in \"${this.startOptions.sslKey}\", ` +\n        `please provide a path to an existing ssl key file with --ssl-key`);\n    }\n\n    if (!existsSync(this.startOptions.sslCert)) {\n      throw new TypeError(`SSL certificate couldn't be found in \"${this.startOptions.sslCert}\", ` +\n        `please provide a path to an existing ssl certificate file with --ssl-cert`);\n    }\n\n    let options = {\n      key: fs.readFileSync(this.startOptions.sslKey),\n      cert: fs.readFileSync(this.startOptions.sslCert),\n    };\n\n    return this.https.createServer(options, this.app);\n  }\n\n  listen(port, host) {\n    let server = this.httpServer;\n\n    return new Promise((resolve, reject) => {\n      server.listen(port, host);\n      server.on('listening', () => {\n        resolve();\n        this.emit('listening');\n      });\n      server.on('error', reject);\n    });\n  }\n\n  processAddonMiddlewares(options) {\n    this.project.initializeAddons();\n\n    return mapSeries(this.project.addons, function(addon) {\n      if (addon.serverMiddleware) {\n        return addon.serverMiddleware({\n          app: this.app,\n          options,\n        });\n      }\n    }, this);\n  }\n\n  processAppMiddlewares(options) {\n    if (this.project.has(this.serverRoot)) {\n      let server = this.project.require(this.serverRoot);\n\n      if (typeof server !== 'function') {\n        throw new TypeError('ember-cli expected ./server/index.js to be the entry for your mock or proxy server');\n      }\n\n      if (server.length === 3) {\n        // express app is function of form req, res, next\n        return this.app.use(server);\n      }\n\n      return server(this.app, options);\n    }\n  }\n\n  start(options) {\n    options.project = this.project;\n    options.watcher = this.watcher;\n    options.serverWatcher = this.serverWatcher;\n    options.ui = this.ui;\n\n    this.startOptions = options;\n\n    if (this.serverWatcher) {\n      this.serverWatcher.on('change', this.serverWatcherDidChange.bind(this));\n      this.serverWatcher.on('add', this.serverWatcherDidChange.bind(this));\n      this.serverWatcher.on('delete', this.serverWatcherDidChange.bind(this));\n    }\n\n    return this.startHttpServer().then(() => {\n      let baseURL = options.rootURL === '' ? '/' : cleanBaseURL(options.rootURL || options.baseURL);\n\n      options.ui.writeLine(`Serving on http${options.ssl ? 's' : ''}://${this.displayHost(options.host)}:${options.port}${baseURL}`);\n    });\n  }\n\n  serverWatcherDidChange() {\n    this.scheduleServerRestart();\n  }\n\n  restartHttpServer() {\n    if (!this.serverRestartPromise) {\n      this.serverRestartPromise = this.stopHttpServer().then(() => {\n        this.invalidateCache(this.serverRoot);\n        return this.startHttpServer();\n      }).then(() => {\n        this.emit('restart');\n        this.ui.writeLine('');\n        this.ui.writeLine(chalk.green('Server restarted.'));\n        this.ui.writeLine('');\n      }).catch(err => {\n        this.ui.writeError(err);\n      }).finally(() => {\n        this.serverRestartPromise = null;\n      });\n\n      return this.serverRestartPromise;\n    } else {\n      return this.serverRestartPromise\n        .then(() => this.restartHttpServer());\n    }\n  }\n\n  stopHttpServer() {\n    return new Promise((resolve, reject) => {\n      if (!this.httpServer) {\n        return resolve();\n      }\n      this.httpServer.close(err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        this.httpServer = null;\n        resolve();\n      });\n\n      // We have to force close all sockets in order to get a fast restart\n      let sockets = this.sockets;\n      for (let socketId in sockets) {\n        sockets[socketId].destroy();\n      }\n    });\n  }\n\n  startHttpServer() {\n    this.app = this.express();\n    this.app.use(require('compression')());\n\n    this.setupHttpServer();\n\n    let options = this.startOptions;\n    options.httpServer = this.httpServer;\n\n    return Promise.resolve()\n      .then(() => this.processAppMiddlewares(options))\n      .then(() => this.processAddonMiddlewares(options))\n      .then(() => this.listen(options.port, options.host)\n        .catch(() => {\n          throw new SilentError(`Could not serve on http://${this.displayHost(options.host)}:${options.port}. ` +\n            `It is either in use or you do not have permission.`);\n        }));\n  }\n\n  invalidateCache(serverRoot) {\n    let absoluteServerRoot = path.resolve(serverRoot);\n    if (absoluteServerRoot[absoluteServerRoot.length - 1] !== path.sep) {\n      absoluteServerRoot += path.sep;\n    }\n\n    let allKeys = Object.keys(require.cache);\n    for (let i = 0; i < allKeys.length; i++) {\n      if (allKeys[i].indexOf(absoluteServerRoot) === 0) {\n        delete require.cache[allKeys[i]];\n      }\n    }\n  }\n}\n\nmodule.exports = ExpressServerTask;\n","/home/travis/build/npmtest/node-npmtest-ember-cli/node_modules/ember-cli/lib/tasks/server/livereload-server.js":"'use strict';\n\nconst Promise = require('rsvp').Promise;\nconst fs = require('fs');\nconst Task = require('../../models/task');\nconst SilentError = require('silent-error');\nconst walkSync = require('walk-sync');\nconst path = require('path');\nconst FSTree = require('fs-tree-diff');\nlet logger = require('heimdalljs-logger')('ember-cli:live-reload:');\n\nfunction createServer(options) {\n  let instance;\n\n  const Server = (require('tiny-lr')).Server;\n  Server.prototype.error = function() {\n    instance.error.apply(instance, arguments);\n  };\n  instance = new Server(options);\n  return instance;\n}\n\nfunction isNotRemoved(entryTuple) {\n  let operation = entryTuple[0];\n  return operation !== 'unlink' && operation !== 'rmdir';\n}\n\nfunction isNotDirectory(entryTuple) {\n  let entry = entryTuple[2];\n  return entry && !entry.isDirectory();\n}\n\nfunction relativePath(patch) {\n  return patch[1];\n}\n\nfunction isNotSourceMapFile(file) {\n  return !(/\\.map$/.test(file));\n}\n\nclass LiveReloadServerTask extends Task {\n  liveReloadServer(options) {\n    if (this._liveReloadServer) {\n      return this._liveReloadServer;\n    }\n\n    this._liveReloadServer = createServer(options);\n    return this._liveReloadServer;\n  }\n\n  listen(options) {\n    let server = this.liveReloadServer(options);\n\n    return new Promise((resolve, reject) => {\n      server.error = reject;\n      server.listen(options.port, options.host, resolve);\n    });\n  }\n\n  start(options) {\n    let tlroptions = {};\n\n    tlroptions.ssl = options.ssl;\n    tlroptions.host = options.liveReloadHost || options.host;\n    tlroptions.port = options.liveReloadPort;\n\n    if (options.liveReload !== true) {\n      return Promise.resolve('Livereload server manually disabled.');\n    }\n\n    if (options.ssl) {\n      tlroptions.key = fs.readFileSync(options.sslKey);\n      tlroptions.cert = fs.readFileSync(options.sslCert);\n    }\n\n    this.tree = new FSTree.fromEntries([]);\n\n    // Reload on file changes\n    this.watcher.on('change', function() {\n      try {\n        this.didChange.apply(this, arguments);\n      } catch (e) {\n        this.ui.writeError(e);\n      }\n    }.bind(this));\n\n    this.watcher.on('error', this.didChange.bind(this));\n\n    // Reload on express server restarts\n    this.expressServer.on('restart', this.didRestart.bind(this));\n\n    let url = `http${options.ssl ? 's' : ''}://${this.displayHost(tlroptions.host)}:${tlroptions.port}`;\n    // Start LiveReload server\n    return this.listen(tlroptions)\n      .then(this.writeBanner.bind(this, url))\n      .catch(this.writeErrorBanner.bind(this, url));\n  }\n\n  displayHost(specifiedHost) {\n    return specifiedHost || 'localhost';\n  }\n\n  writeBanner(url) {\n    this.ui.writeLine(`Livereload server on ${url}`);\n  }\n\n  writeErrorBanner(url) {\n    throw new SilentError(`Livereload failed on ${url}.  It is either in use or you do not have permission.`);\n  }\n\n  writeSkipBanner(filePath) {\n    this.ui.writeLine(`Skipping livereload for: ${filePath}`);\n  }\n\n  getDirectoryEntries(directory) {\n    return walkSync.entries(directory);\n  }\n\n  shouldTriggerReload(options) {\n    let result = true;\n\n    if (this.project.liveReloadFilterPatterns.length > 0) {\n      let filePath = path.relative(this.project.root, options.filePath || '');\n\n      result = this.project.liveReloadFilterPatterns\n        .every(pattern => pattern.test(filePath) === false);\n\n      if (result === false) {\n        this.writeSkipBanner(filePath);\n      }\n    }\n\n    return result;\n  }\n\n  didChange(results) {\n    let previousTree = this.tree;\n    let files;\n\n    if (results.directory) {\n      this.tree = new FSTree.fromEntries(this.getDirectoryEntries(results.directory), { sortAndExpand: true });\n      files = previousTree.calculatePatch(this.tree)\n        .filter(isNotRemoved)\n        .filter(isNotDirectory)\n        .map(relativePath)\n        .filter(isNotSourceMapFile);\n\n    } else {\n      files = ['LiveReload files'];\n    }\n\n    logger.info('files %a', files);\n\n    if (this.shouldTriggerReload(results)) {\n      this.liveReloadServer().changed({\n        body: {\n          files,\n        },\n      });\n\n      this.analytics.track({\n        name: 'broccoli watcher',\n        message: 'live-reload',\n      });\n    }\n  }\n\n  didRestart() {\n    this.liveReloadServer().changed({\n      body: {\n        files: ['LiveReload files'],\n      },\n    });\n\n    this.analytics.track({\n      name: 'express server',\n      message: 'live-reload',\n    });\n  }\n}\n\nmodule.exports = LiveReloadServerTask;\n"}